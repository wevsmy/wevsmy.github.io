[{"categories":null,"content":"Linux内核中的namespace和cgroups技术实现了各种资源的隔离与控制。\nNamespace Namespace 是将内核的全局资源做封装，使得每个namespace 都有一份独立的资源，因此不同的进程在各自的namespace内对同一种资源的使用互不干扰。\n1 Namespace技术实现了各种资源的隔离。 Namespace 名称 作用 内核版本 Mount(mnt) 隔离挂载点 2.4.19 Process ID(pid) 隔离进程ID 2.6.24 Network(net) 隔离网络设备、端口号等 2.6.29 Interprocess Communication (ipc) 隔离进程间通信 System V IPC 和 POSIX message queues 2.6.19 UTS Namespace(uts) 隔离主机名和域名 2.6.19 User Namespace(user) 隔离用户和用户组 3.8 Control group(cgroups)Namespace 隔离cgroups根目录 4.6 Time Namespace 隔离系统时间 5.6 3.8 的内核开始，/proc/[pid]/ns 目录下会包含进程所属的 namespace 信息. 使用下面的命令可以查看当前进程所属的 namespace 信息：ll /proc/$$/ns ex:\nvagrant@ubuntu20-04:~$ ll /proc/$$/ns total 0 dr-x--x--x 2 vagrant vagrant 0 Aug 23 03:38 ./ dr-xr-xr-x 9 vagrant vagrant 0 Aug 23 03:38 ../ lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 cgroup -\u003e 'cgroup:[4026531835]' lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 ipc -\u003e 'ipc:[4026531839]' lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 mnt -\u003e 'mnt:[4026531840]' lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 net -\u003e 'net:[4026531992]' lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 pid -\u003e 'pid:[4026531836]' lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 pid_for_children -\u003e 'pid:[4026531836]' lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 user -\u003e 'user:[4026531837]' lrwxrwxrwx 1 vagrant vagrant 0 Aug 23 03:38 uts -\u003e 'uts:[4026531838]' 隔离挂载点（mount） Mount Namespace 实现了不同进程可以看到不同的挂载信息。\n1 换句话说说，容器内的挂载操作不会影响到主机。 ex: 使用unshare命令新建一个mount namespace\n1 sudo unshare --mount --fork /bin/bash 创建一个临时挂载目录\n1 mkdir /tmp/tmpfs 使用tmpfs挂载一个目录\n1 mount -t tmpfs -o size=1024k tmpfs /tmp/tmpfs 当前窗口查看挂载信息\nroot@ubuntu20-04:~# mkdir /tmp/tmpfs root@ubuntu20-04:~# mount -t tmpfs -o size=1024k tmpfs /tmp/tmpfs root@ubuntu20-04:~# df -h Filesystem Size Used Avail Use% Mounted on /dev/sda1 39G 1.3G 38G 4% / udev 977M 0 977M 0% /dev tmpfs 994M 0 994M 0% /dev/shm tmpfs 199M 924K 198M 1% /run tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 199M 0 199M 0% /run/user/1000 tmpfs 994M 0 994M 0% /sys/fs/cgroup /dev/loop1 56M 56M 0 100% /snap/core18/2128 /dev/loop0 71M 71M 0 100% /snap/lxd/21029 /dev/loop2 33M 33M 0 100% /snap/snapd/12704 tmpfs 1.0M 0 1.0M 0% /tmp/tmpfs vagrant@ubuntu20-04:~$ 新开一个窗口查看挂载信息,看到没有/tmp/tmpfs挂载信息\nLast login: Mon Aug 23 03:38:34 2021 from 10.0.2.2 vagrant@ubuntu20-04:~$ df -h Filesystem Size Used Avail Use% Mounted on udev 977M 0 977M 0% /dev tmpfs 199M 932K 198M 1% /run /dev/sda1 39G 1.3G 38G 4% / tmpfs 994M 0 994M 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 994M 0 994M 0% /sys/fs/cgroup /dev/loop1 56M 56M 0 100% /snap/core18/2128 /dev/loop0 71M 71M 0 100% /snap/lxd/21029 /dev/loop2 33M 33M 0 100% /snap/snapd/12704 tmpfs 199M 0 199M 0% /run/user/1000 vagrant@ubuntu20-04:~$ 隔离进程ID(pid) 用于实现不同PID Namespace内的进程拥有相同的ID.\n创建一个pid namespace\n1 sudo unshare --pid --fork --mount-proc /bin/bash 查看进程信息，1号进程为bash\nroot@ubuntu20-04:~# root@ubuntu20-04:~# sudo unshare --pid --fork --mount-proc /bin/bash root@ubuntu20-04:~# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 8960 3892 pts/0 S 03:52 0:00 /bin/bash root 8 0.0 0.1 10616 3440 pts/0 R+ 03:52 0:00 ps aux root@ubuntu20-04:~# 隔离网络设备、端口号(net) net namespace实现网络设备的隔离。\n查看主机网络信息\nroot@ubuntu20-04:~# root@ubuntu20-04:~# ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 02:14:28:cf:54:43 brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3 valid_lft 85336sec preferred_lft 85336sec inet6 fe80::14:28ff:fecf:5443/64 scope link valid_lft forever preferred_lft forever root@ubuntu20-04:~# 创建一个net namespace\n1 sudo unshare --net --fork /bin/bash 查看此net namespace下网络信息\nroot@ubuntu20-04:~# root@ubuntu20-04:~# sudo unshare --net --fork /bin/bash root@ubuntu20-04:~# ip a 1: lo: \u003cLOOPBACK\u003e mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 root@ubuntu20-04:~# 隔离主机名（uts） UTS Namespace主要是用来隔离主机名的，它允许每个UTS Namespace拥有一个独立的主机名。\n创建一个 UTS Namespace\n1 sudo unshare --uts --fork /bin/bash 创建完namespace后当前终端已经处于一个独立的UTS Namespace中了。 先看下主机名、然后在修改主机名、最后查看主机。\nroot@ubuntu20-04:~# sudo unshare --uts --fork /bin/bash root@ubuntu20-04:~# hostname ubuntu20-04 root@ubuntu20-04:~# hostname -b changehostname root@ubuntu20-04:~# hostname changehostname root@ubuntu20-04:~# 上面输出已经看到成功修改了主机名。 打开新的bash终端查看主机名\nLast login: Mon Aug 23 03:43:22 2021 from 10.0.2.2 vagrant@ubuntu20-04:~$ sudo -i root@ubuntu20-04:~# hostname ubuntu20-04 root@ubuntu20-04:~# 主机名并未被修改，验证UTS Namespace隔离主机名。\n隔离进程间通信（ipc） IPC Namespace主要是用来隔离进程间通信的。 ex:\n1 PID Namespace 和 IPC Namespace 一起使用可以实现同一 IPC Namespace 内的进程彼此可以通信，不同 IPC Namespace 的进程却不能通信。 使用unshare命令来创建一个IPC Namespace\n1 sudo unshare --ipc --fork /bin/bash ipcs -q 命令用于查看系统间通信队列列表。 ipcmk -Q 命令用于创建系统间通信队列。 root@ubuntu20-04:~# root@ubuntu20-04:~# sudo unshare --ipc --fork /bin/bash root@ubuntu20-04:~# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages root@ubuntu20-04:~# ipcmk -Q Message queue id: 0 root@ubuntu20-04:~# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xf350f2cb 0 root 644 0 0 root@ubuntu20-04:~# 打开新新窗口终端，查看系统通信队列。\nLast login: Mon Aug 23 04:07:29 2021 from 10.0.2.2 vagrant@ubuntu20-04:~$ sudo -i root@ubuntu20-04:~# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages root@ubuntu20-04:~# 结果可以看到，在单独的IPC Namespace内创建的系统通信队列在主机上无法查看，即IPC Namespace实现了系统间通信对列的隔离。\n隔离用户和用户组（user） User Namespace 主要是用来隔离用户和用户组的。\n一个比较典型的应用场景就是在主机上以非root用户运行的进程可以在一个单独的User Namespace中映射成root用户。 使用User Namespace可以实现进程在容器内拥有root权限，而在主机上却只是普通用户。\nUser Namesapce的创建是可以不使用 root 权限的。 下面我们以普通用户的身份创建一个User Namespace，命令如下：\n1 unshare --user -r /bin/bash vagrant@ubuntu20-04:~$ vagrant@ubuntu20-04:~$ unshare --user -r /bin/bash root@ubuntu20-04:~# id uid=0(root) gid=0(root) groups=0(root) root@ubuntu20-04:~# reboot Failed to connect to bus: Operation not permitted Failed to open initctl fifo: Permission denied Failed to talk to init daemon. root@ubuntu20-04:~# 可以看到，在新创建的User Namespace内虽然是root用户，但是并没有权限执行reboot命令。这说明在隔离的User Namespace中，并不能获取到主机的root权限，也就是说User Namespace实现了用户和用户组的隔离。\nCgroups Cgroups，其名称源自控制组群（control groups）的简写，也是Linux内核的一个功能，用来限制、控制与统计一个进程组的资源（如CPU、内存、磁盘输入输出等）。\n1 Cgroups技术用来限制容器内进程使用CPU、内存的资源的使用量。 cgroups的主要作用 cgroups的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups四大功能:\n资源限制：cgroups可以对任务要求的总资源总额进行限制。诸如，设定任务运行时使用的内存上限，一旦超出内核就发OOM killer(Out-Of-Memory killer)。 资源统计：cgoups可以统计系统的资源使用量，比如CPU使用时长、内存用量等。当前云端产品按使用量计费的方式采用的底层实现方式。 任务控制：cgroups可以对任务执行挂起、恢复等操作。 优先级分配：通过分配的CPU时间片数量和磁盘IO带宽，实际上就等同于控制了任务运行的优先级。 cgroups的文件系统接口 cgroups以文件的方式提供应用接口，可以通过mount命令查看cgroups默认的挂载点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 root@ubuntu20-04:~# mount | grep cgroup tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755) cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate) cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids) cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio) root@ubuntu20-04:~# Subsystem(子系统) 子系统 作用 hugetlb 限制HugeTLB(内存页)的使用 net_cls 配合流控限制网络带宽 net_prio 设置进程的网络流量优先级 freezer 暂停/恢复cgroup中的任务/进程 pids 限制任务/进程的数量 rdma 限制RDMA/IB资源 devices 设备访问权限控制 cpuset 分配指定的CPU和内存节点 perf_event 允许Perf工具基于Cgroup分组做性能检测 cpu 控制CPU使用率 cpuacct 统计CPU使用情况 memory 限制内存的使用上限 blkio 对块设备的IO进行限制 Tip\n23333\n","description":"容器底层原理之namespace和cgroups","tags":["namespace","cgroups","docker","linux"],"title":"容器底层原理之namespace和cgroups","uri":"/2021/08/23/namespace_cgroups/"},{"categories":null,"content":"利用wireguard内网穿透并用nginx反代,实现访问域名到达指定内网服务\nserver{ set $forward_scheme http; set $server \"localhost\"; set $port 8181; listen 8080; listen [::]:8080; listen 4443 ssl http2; listen [::]:4443; server_name *.m.weii.ink; # crypt SSL include conf.d/include/letsencrypt-acme-challenge.conf; include conf.d/include/ssl-ciphers.conf; ssl_certificate /etc/letsencrypt/live/npm-6/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/npm-6/privkey.pem; access_log /config/log/proxy_host-0.log proxy; location / { rewrite_by_lua_block { --判断ip是否合法 local function JudgeIPString(ipStr) if type(ipStr) ~= \"string\" then return false; end --判断长度 local len = string.len(ipStr); if len \u003c 7 or len \u003e 15 then --长度不对 return false; end --判断出现的非数字字符 local point = string.find(ipStr, \"%p\", 1); --字符\".\"出现的位置 local pointNum = 0; --字符\".\"出现的次数 正常ip有3个\".\" while point ~= nil do if string.sub(ipStr, point, point) ~= \".\" then --得到非数字符号不是字符\".\" return false; end pointNum = pointNum + 1; point = string.find(ipStr, \"%p\", point + 1); if pointNum \u003e 3 then return false; end end if pointNum ~= 3 then --不是正确的ip格式 return false; end --判断数字对不对 local num = {}; for w in string.gmatch(ipStr, \"%d+\") do num[#num + 1] = w; local kk = tonumber(w); if kk == nil or kk \u003e 255 then --不是数字或超过ip正常取值范围了 return false; end end if #num ~= 4 then --不是4段数字 return false; end return ipStr; end --判断此字符串是否为纯数字 local function IsNumber(words) if string.len(words) \u003c 1 then return false end for i=1,string.len(words) do if string.byte(string.sub(words,i,i)) \u003c 48 or string.byte(string.sub(words,i,i)) \u003e 57 then return false end end return true end local s = ngx.var.host local proxy_str = \"\" local i = 0 for x in string.gmatch(s, \"([^.]+)\") do if i \u003e 0 then break end i = i + 1 proxy_str = x end local t={} for y in string.gmatch(proxy_str, \"([^-]+)\") do table.insert(t, y) end local server = string.format(\"%s.%s.%s.%s\", t[1], t[2], t[3], t[4]) local port = t[5] if JudgeIPString(server) == false or IsNumber(port) == false then ngx.var.server = \"localhost\" ngx.var.port = 8181 --条件不对禁止访问 return ngx.exit(ngx.HTTP_FORBIDDEN) else ngx.var.server = server ngx.var.port = port end } add_header X-Served-By $host; proxy_set_header Host $host; proxy_set_header X-Forwarded-Scheme $scheme; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Real-IP $remote_addr; proxy_pass $forward_scheme://$server:$port; } } 在nginx中进行路由转发\n1 route add -net 10.13.13.0/24 gw 172.19.0.6 172.19.0.6 为wireguard容器IP\nps: 访问10_13_13_13_8080.m.weii.ink即访问内网10.13.13.13:8080服务\n参考链接\n","description":"","tags":["wireguard","linux","network","docker","nginx"],"title":"利用wireguard内网穿透并用nginx反代","uri":"/2021/07/17/wireguard_nginx_proxy/"},{"categories":null,"content":"利用wireguard内网穿透web访问管理配置\n配置文件\n1 2 3 4 5 6 7 8 9 wevsmy@SINOWEL-PC:~/d_project/Lab/docker-compose/wireguard$ tree . ├── docker-compose.yml ├── init.sh ├── watch.sh ├── wg-api └── wg-api.sh 0 directories, 5 files docker-compose.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 version: \"3.6\" services: wireguard: image: ghcr.io/linuxserver/wireguard container_name: wireguard cap_add: - NET_ADMIN - SYS_MODULE environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai # - SERVERURL=wireguard.domain.com #optional - SERVERURL=192.168.59.253 #optional - SERVERPORT=51821 #optional - PEERS=1 #optional - PEERDNS=10.13.13.1 #optional - INTERNAL_SUBNET=10.13.13.0 #optional - ALLOWEDIPS=0.0.0.0/0 #optional volumes: - /lib/modules:/lib/modules - ./volumes/wireguard/config:/config - ./init.sh:/config/custom-cont-init.d/init.sh:ro - ./watch.sh:/config/custom-services.d/watch.sh:ro - ./wg-api:/app/wg-api:ro - ./wg-api.sh:/config/custom-services.d/wg-api.sh:ro ports: - 51821:51820/udp sysctls: - net.ipv4.conf.all.src_valid_mark=1 restart: unless-stopped dns: - 114.114.114.114 wg-gen-web-demo: image: vx3r/wg-gen-web:latest container_name: wg-gen-web-demo restart: unless-stopped expose: - 8080/tcp ports: - 51822:8080 environment: - WG_CONF_DIR=/data - WG_INTERFACE_NAME=wg0.conf - WG_STATS_API=http://wireguard:8080 - WG_STATS_API_USER= - WG_STATS_API_PASS= # - SMTP_HOST=smtp.gmail.com # - SMTP_PORT=587 # - SMTP_USERNAME=no-reply@gmail.com # - SMTP_PASSWORD=****************** # - SMTP_FROM=Wg Gen Web \u003cno-reply@gmail.com\u003e # - OAUTH2_PROVIDER_NAME=github # - OAUTH2_PROVIDER=https://github.com # - OAUTH2_CLIENT_ID=****************** # - OAUTH2_CLIENT_SECRET=****************** # - OAUTH2_REDIRECT_URL=https://wg-gen-web-demo.127-0-0-1.fr volumes: - ./volumes/wireguard/config:/data depends_on: - wireguard init.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #!/usr/bin/with-contenv bash echo \"**** installing inotify-tools ****\" apt-get update \u0026\u0026 apt-get install inotify-tools -y echo \"**** installing config ****\" echo ' [Interface] Address = '$(echo \"$INTERNAL_SUBNET\" | awk 'BEGIN{FS=OFS=\".\"} NF--')'.1 ListenPort = 51820 PrivateKey = '$(cat /config/server/privatekey-server)' PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE ' \u003e /config/wg0.conf echo ' { \"address\": [ \"'$(echo \"$INTERNAL_SUBNET\" | awk 'BEGIN{FS=OFS=\".\"} NF--')'.1/24\" ], \"listenPort\": 51820, \"mtu\": 0, \"privateKey\": \"'$(cat /config/server/privatekey-server)'\", \"publicKey\": \"'$(cat /config/server/publickey-server)'\", \"endpoint\": \"'${SERVERURL}:${SERVERPORT}'\", \"persistentKeepalive\": 16, \"dns\": [ \"'$(echo \"$INTERNAL_SUBNET\" | awk 'BEGIN{FS=OFS=\".\"} NF--')'.1\" ], \"allowedips\": [ \"'${ALLOWEDIPS}'\" ], \"preUp\": \"echo WireGuard PreUp\", \"postUp\": \"iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\", \"preDown\": \"echo WireGuard PreDown\", \"postDown\": \"iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE\", \"updatedBy\": \"\", \"created\": \"'$(date +%Y-%m-%dT%H:%M:%S.%NZ)'\", \"updated\": \"'$(date +%Y-%m-%dT%H:%M:%S.%NZ)'\" } ' \u003e /config/server.json COREDNSID='44d338ce-e383-11eb-b7fa-0b1c92374c21' echo ' { \"id\": \"'$COREDNSID'\", \"name\": \"CoreDNS\", \"email\": \"CoreDNS@example.com\", \"enable\": false, \"ignorePersistentKeepalive\": false, \"presharedKey\": \"\", \"allowedIPs\": [ \"'${ALLOWEDIPS}'\" ], \"address\": [ \"'$(echo \"$INTERNAL_SUBNET\" | awk 'BEGIN{FS=OFS=\".\"} NF--')'.1/32\" ], \"tags\": [], \"privateKey\": \"\", \"publicKey\": \"\", \"createdBy\": \"\", \"updatedBy\": \"\", \"created\": \"'$(date +%Y-%m-%dT%H:%M:%S.%NZ)'\", \"updated\": \"'$(date +%Y-%m-%dT%H:%M:%S.%NZ)'\" } ' \u003e /config/$COREDNSID watch.sh\n1 2 3 4 5 6 #!/usr/bin/with-contenv bash while inotifywait -e modify -e create /config/wg0.conf; do wg-quick down wg0 wg-quick up wg0 done wg-api.sh\n1 2 3 4 5 6 7 8 9 #!/usr/bin/with-contenv bash if netstat -apn | grep -q \":8080 \"; then echo \"Another service is using port 8080, disabling wg-api\" sleep infinity else exec \\ /app/wg-api --device wg0 --listen 0.0.0.0:8080 fi ps: wg-api\n1 2 3 4 git clone https://github.com/jamescun/wg-api.git cd wg-api CGO_ENABLED=0 GOOS=linux go build -o wg-api cmd/wg-api.go cp wg-api ../. ","description":"","tags":["wireguard","linux","network","docker"],"title":"利用wireguard内网穿透","uri":"/2021/07/13/wireguard_web/"},{"categories":null,"content":"利用socat来进行端口转发\nsocat.sh 文件 1 2 3 4 5 6 7 8 9 10 11 #!/bin/bash DEF_REMOTE_HOST=127.0.0.1 DEF_REMOTE_PORT=80 DEF_LOCAL_PORT=80 REMOTE_HOST=$DEF_REMOTE_HOST REMOTE_PORT=$DEF_REMOTE_PORT LOCAL_PORT=$DEF_LOCAL_PORT socat tcp-listen:$LOCAL_PORT,reuseaddr,fork tcp:$REMOTE_HOST:$REMOTE_PORT \u0026 pid=$! \u0026\u0026 trap \"kill $pid\" SIGINT \u0026\u0026 echo \"Socat started listening on $LOCAL_PORT: Redirecting traffic to $REMOTE_HOST:$REMOTE_PORT ($pid)\" \u0026\u0026 wait $pid docker-compose.yml 文件 1 2 3 4 5 6 7 8 9 10 11 version: \"3.7\" services: port-forward: image: marcnuri/port-forward:latest container_name: port-forward network_mode: host restart: always environment: REMOTE_HOST: 127.0.0.1 REMOTE_PORT: 80 LOCAL_PORT: 80 使用方式： Variable Description Optional DEF_/REMOTE_HOST IP or address of the host you want to forward traffic to no DEF_/REMOTE_PORT Port on remote host to forward traffic to yes (80) DEF_/LOCAL_PORT Port where container listens yes (80) 参考链接： Port Forwarding for Docker ","description":"","tags":["socat","forward"],"title":"端口转发","uri":"/2020/03/19/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"},{"categories":null,"content":"wsl2使用本地127.0.0.1访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $remoteport = bash.exe -c \"ifconfig eth0 | grep 'inet '\" $found = $remoteport -match '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'; if( $found ){ $remoteport = $matches[0]; } else{ echo \"The Script Exited, the ip address of WSL 2 cannot be found\"; exit; } #[Ports] #All the ports you want to forward separated by coma $ports=@(80,443,8011,8080); #[Static ip] #You can change the addr to your ip config to listen to a specific address $addr='0.0.0.0'; $ports_a = $ports -join \",\"; #Remove Firewall Exception Rules #iex \"Remove-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' \"; #adding Exception Rules for inbound and outbound Rules #iex \"New-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' -Direction Outbound -LocalPort $ports_a -Action Allow -Protocol TCP\"; #iex \"New-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' -Direction Inbound -LocalPort $ports_a -Action Allow -Protocol TCP\"; for( $i = 0; $i -lt $ports.length; $i++ ){ $port = $ports[$i]; iex \"netsh interface portproxy delete v4tov4 listenport=$port listenaddress=$addr\"; iex \"netsh interface portproxy add v4tov4 listenport=$port listenaddress=$addr connectport=$port connectaddress=$remoteport\"; } # show all netsh interface portproxy show all 使用管理员权限执行\n1 sudo ./proxy.ps1 ps: 对$ports参数进行增删，自行定义\n","description":"","tags":["win10","wls2","笔记","network"],"title":"win10 wsl2 端口转发到宿主机","uri":"/2019/11/15/win10_wsl2_port_forward/"},{"categories":null,"content":"由于国内墙的存在go get经常失败，记录安装依赖时go代理设置\ngo代理设置 在Go 1.13中，我们可以通过GOPROXY来控制代理，以及通过GOPRIVATE控制私有库不走代理\nGOPROXY 国内常用代理\n1 2 3 https://goproxy.cn https://goproxy.io https://mirrors.aliyun.com/goproxy/ 设置GOPROXY代理\n1 go env -w GOPROXY=https://goproxy.cn,direct GOPRIVATE 设置GOPRIVATE来跳过私有库，比如常用的Gitlab或Gitee，中间使用逗号分隔：\n1 go env -w GOPRIVATE=*.gitlab.com,*.gitee.com GOSUMDB 如果在运行go mod vendor时，提示: Get https://sum.golang.org/lookup/xxxxxx: dial tcp 216.58.200.49:443: i/o timeout 则是因为Go 1.13设置了默认的GOSUMDB=sum.golang.org，这个网站是被墙了的，用于验证包的有效性，可以通过如下命令关闭：\n1 go env -w GOSUMDB=off 可以设置GOSUMDB=\"sum.golang.google.cn\"， 这个是专门为国内提供的sum验证服务。\n1 go env -w GOSUMDB=\"sum.golang.google.cn\" ","description":"go代理设置","tags":["go","proxy","golang"],"title":"go代理设置","uri":"/2019/10/09/goproxy/"},{"categories":null,"content":"记录OpenShift安装过程\nOpenShift安装过程 安装流程 master 8 vCpu 16G RAM 60G Disk CentOS 7 IP 172.31.66.25 node1 4 vCpu 8G RAM 50G Disk CentOS 7 IP 172.31.66.26 node2 4 vCpu 8G RAM 50G Disk CentOS 7 IP 172.31.66.161 官方最低硬件要求\n俺们公司网络需要配置代理\n为啥?因为公司办公网段172.31.xx.xx有权限控制，服务器网段没有。\nyum vim /etc/yum.conf\n1 proxy=http://10.10.192.18:3128 wgetvim /etc/wgetrc\n1 2 3 4 https_proxy = http://10.10.192.18:3128/ http_proxy = http://10.10.192.18:3128/ ftp_proxy = http://10.10.192.18:3128/ use_proxy = on pipvim /etc/profile\n1 2 export https_proxy=http://10.10.192.18:3128 export http_proxy=http://10.10.192.18:3128 配置国内源更新源\n1 2 3 4 5 6 cd /etc/yum.repos.d/ \u0026\u0026 mkdir repo_bak \u0026\u0026 mv *.repo repo_bak/ \\ \u0026\u0026 wget http://mirrors.aliyun.com/repo/Centos-7.repo -O /etc/yum.repos.d/Centos-7.repo \\ \u0026\u0026 wget http://mirrors.163.com/.help/CentOS7-Base-163.repo -O /etc/yum.repos.d/CentOS7-Base-163.repo \\ \u0026\u0026 yum clean all \u0026\u0026 yum makecache \u0026\u0026 yum update \\ \u0026\u0026 yum -y install git python-pip \\ \u0026\u0026 pip install --upgrade setuptools 克隆openshift-ansible代码\u0026切换分支\u0026安装ansible\n1 2 3 4 5 cd /tmp \\ \u0026\u0026 git clone https://github.com/openshift/openshift-ansible \\ \u0026\u0026 cd openshift-ansible \\ \u0026\u0026 git checkout release-3.11 \\ \u0026\u0026 pip install -r requirements.txt 配置/etc/hosts\n1 2 3 172.31.66.25 openshift-master 172.31.66.26 openshift-node1 172.31.66.161 openshift-node2 配置ssh免密\n1 2 3 4 ssh-keygen ssh-copy-id root@openshift-master ssh-copy-id root@openshift-node1 ssh-copy-id root@openshift-node2 ansible ping测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [root@localhost openshift-ansible]# ansible all -m ping openshift-master | SUCCESS =\u003e { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } openshift-node2 | SUCCESS =\u003e { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } openshift-node1 | SUCCESS =\u003e { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } 分发/etc/hosts文件至其他节点\n1 ansible all -m copy -a \"src=/etc/hosts dest=/etc/hosts\" 安装\n1 2 ansible-playbook -i inventory/hosts.localhost playbooks/prerequisites.yml ansible-playbook -i inventory/hosts.localhost playbooks/deploy_cluster.yml 官方安装文档 Openshift OKD v3.11 高级安装\n","description":"OpenShift安装记录","tags":["OpenShift","Docker","K8S","OKD"],"title":"OpenShift OKD v3.11 安装记录","uri":"/2019/09/17/openshift_install/"},{"categories":["docker"],"content":"DNSmasq是一个小巧且方便地用于配置DNS和DHCP的工具。 用docker搭建一下用用。\nDocker搭建DNS服务器 编写docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: '2' services: dnsmasq: image: andyshinn/dnsmasq container_name: dnsmasq restart: always ports: - 53:53/tcp - 53:53/udp cap_add: - NET_ADMIN command: --log-facility=- volumes: - ./dnsmasq.d:/etc/dnsmasq.d 创建配置文件 base.conf 路径./dnsmasq.d/base.conf\n1 2 3 4 5 6 7 8 9 domain-needed bogus-priv no-hosts keep-in-foreground no-resolv expand-hosts server=114.114.114.114 server=10.10.192.1 server=10.10.10.1 host.conf 路径./dnsmasq.d/host.conf\n1 2 address=/test.local/192.168.1.1 address=/willson.wu/172.31.66.194 检查53端口 检查53端口是否被占用，要是被占用就干掉它，不然用不起来！ sudo lsof -i:53\n启动\u0026测试 启动 docker-compose up -d 测试 dig test.local\n","description":"docker环境搭建DNS服务器","tags":["docker","dns","dnsmasq"],"title":"Docker搭建DNS服务器","uri":"/2019/09/17/docker%E6%90%AD%E5%BB%BAdns%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"配置过docker开启2376采用远程访问，挺方便的，但是需要在服务器防火请放开2376端口（这是废话） 配置个nginx反向代理，直接采用域名443代理访问\n配置nginx反向代理使Docker采用域名远程访问 该方案实现的功能与放开2376端口访问的效果是一毛一样的，区别在于使用代理\n环境前期准备 环境 1 2 ubuntu 18.04 docker community 19.03 准备 预先生成CA证书 自个写的生成记录 官方Docker文档 了解一下nginx-proxy的使用 使用nginx-proxy代理 官方nginx-proxy文档 概念 默认情况下，docker守护进程dockerd使用 Unix socket（/var/run/docker.sock）来进行本地进程通信，而不会监听任何端口。 如果想在其他主机上操作docker主机，就需要让docker守护进程dockerd打开一个HTTP Socket，这样才能实现远程通信。\n在本地使用docker ps命令与 docker -H unix:///var/run/docker.sock ps命令效果一样\n1 2 3 4 5 6 7 8 9 ubuntu@VM-0-6-ubuntu:~$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6a60494e8756 jwilder/nginx-proxy:alpine \"/app/docker-entrypo…\" 41 minutes ago Up 41 minutes 0.0.0.0:80-\u003e80/tcp, 0.0.0.0:443-\u003e443/tcp nginx-proxy 72d843c3164f portainer/portainer \"/portainer -H unix:…\" 21 hours ago Up 17 hours 9000/tcp portainer ubuntu@VM-0-6-ubuntu:~$ docker -H unix:///var/run/docker.sock images REPOSITORY TAG IMAGE ID CREATED SIZE jwilder/nginx-proxy alpine 730317336993 2 days ago 54.4MB portainer/portainer latest 2b4ddf654e1c 6 weeks ago 77.7MB ubuntu@VM-0-6-ubuntu:~$ 在使用nginx-proxy项目中其，也是使用的-v /var/run/docker.sock:/tmp/docker.sock:ro 把本机的docker.sock挂载到容器内部使用 那么思路很清晰，在nginx-proxy容器中反向代理/tmp/docker.sock即可\n配置 在conf.d下添加docker.weii.ink.conf配置 把证书文件放到certs中 路径是nginx-proxy容器中conf.d挂载的路径，参考上篇文章ngixn-proxy配置 以下配置是俺的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ubuntu@VM-0-6-ubuntu:~/project/nginx-proxy/nginx/conf.d$ cat docker.weii.ink.conf upstream docker.weii.ink { ## Can be connected with \"nginx_networks\" network # docker server unix:///tmp/docker.sock; } server { server_name docker.weii.ink; listen 80 ; access_log /var/log/nginx/access.log vhost; return 301 https://$server_name$request_uri; } server { server_name docker.weii.ink; listen 443 ssl http2 ; access_log /var/log/nginx/access.log vhost; ssl_certificate /etc/nginx/certs/docker-server-cert.pem; ssl_certificate_key /etc/nginx/certs/docker-server-key.pem; ssl_client_certificate /etc/nginx/certs/docker-ca.pem; ssl_verify_client on; ssl_session_timeout 5m; ssl_session_cache shared:SSL:50m; ssl_session_tickets off; add_header Strict-Transport-Security \"max-age=31536000\" always; location / { proxy_pass http://docker.weii.ink; } } ubuntu@VM-0-6-ubuntu:~/project/nginx-proxy/nginx/conf.d$ 然后重启nginx-proxy就成了 注： nginx日志如果提示对unix:///tmp/docker.sock没有权限 那就开放权限docker exec -it nginx-proxy chmod 777 /tmp/docker.sock\n验证 1 2 3 4 5 6 ubuntu@VM-0-6-ubuntu:~/project/CA/Client$ curl https://docker.weii.ink/images/json --cert cert.pem --key key.pem --cacert ca.pem [{\"Containers\":-1,\"Created\":1568041593,\"Id\":\"sha256:73031733699358abfc15a2953e496e0edddb127123e51a099aa953391c6db542\",\"Labels\":{\"maintainer\":\"Jason Wilder mail@jasonwilder.com\"},\"ParentId\":\"\",\"RepoDigests\":[\"jwilder/nginx-proxy@sha256:07c0e9866ce0e974b92173542ebdaa2dc03315ec8269e0718dcca5bb3450a430\"],\"RepoTags\":[\"jwilder/nginx-proxy:alpine\"],\"SharedSize\":-1,\"Size\":54365911,\"VirtualSize\":54365911},{\"Containers\":-1,\"Created\":1564107108,\"Id\":\"sha256:2b4ddf654e1c413b21c7253125aa0f34a4ff74154558940fa689f8754ec853c5\",\"Labels\":null,\"ParentId\":\"\",\"RepoDigests\":[\"portainer/portainer@sha256:a16919b3e02323e4bd0a8c5023d6fd569525297b9dc9a028d778cb6e13512be5\"],\"RepoTags\":[\"portainer/portainer:latest\"],\"SharedSize\":-1,\"Size\":77680455,\"VirtualSize\":77680455}] ubuntu@VM-0-6-ubuntu:~/project/CA/Client$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE jwilder/nginx-proxy alpine 730317336993 2 days ago 54.4MB portainer/portainer latest 2b4ddf654e1c 6 weeks ago 77.7MB 后续就可以直接用IDEA链接远程docker进行开发了\n","description":"docker使用Nginx反向代理","tags":["nginx","docker","proxy","domain"],"title":"配置nginx反向代理使Docker采用域名远程访问API","uri":"/2019/09/12/docker_use_domain_name/"},{"categories":null,"content":"nginx-proxy设置一个运行nginx和docker-gen的容器。docker-gen为nginx生成反向代理配置，并在启动和停止容器时重新加载nginx。 使用nginx-proxy来反向代理portainer，并且使用https域名加密访问。\nportainer使用nginx-proxy配置代理添加证书 创建一个bridge网络 1 docker network create nginx_networks 验证:\n1 2 3 4 5 6 ubuntu@VM-0-6-ubuntu:~/project$ docker network ls NETWORK ID NAME DRIVER SCOPE 0ebf5e273b13 bridge bridge local fd601333f19e host host local c0dbfc8d59a8 nginx_networks bridge local 6e07cf9aa154 none null local nginx-proxy配置 采用docker-compose项目进行服务编排\n创建项目文件夹 1 2 mkdir nginx-proxy cd nginx-proxy 创建项目文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 version: '3' services: nginx-proxy: image: jwilder/nginx-proxy:alpine container_name: nginx-proxy restart: always ports: - 80:80 - 443:443 volumes: - ./nginx/log:/var/log/nginx - ./nginx/conf.d:/etc/nginx/conf.d - ./nginx/certs:/etc/nginx/certs - /var/run/docker.sock:/tmp/docker.sock:ro networks: - nginx_networks whoami: image: jwilder/whoami environment: - VIRTUAL_HOST=whoami.local networks: - nginx_networks networks: nginx_networks: external: true 注：\nnetworks加入上一步已经创建好的网络中 whoami用来测试 volumes挂载相应的数据 log把日志挂出来 conf.d便于自定义 certs配置SSL证书 *docker.sock*主要用于监听docker容器为nginx生成反向代理配置，并在启动和停止容器时重新加载nginx。 启动项目容器 1 docker-compose up -d 验证 1 2 ubuntu@VM-0-6-ubuntu:~/project/nginx-proxy$ curl -H \"Host: whoami.local\" localhost I'm eb5b18a676c8 会输出jwilder/whoami的容器ID\nportainer配置 同样是采用docker-compose项目进行服务编排\n创建项目文件夹 1 2 3 cd .. mkdir portainer cd portainer 创建项目文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 version: '3' services: portainer: image: portainer/portainer container_name: portainer restart: always command: -H unix:///var/run/docker.sock environment: - VIRTUAL_HOST=portainer.weii.ink volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data networks: - nginx_networks volumes: portainer_data: networks: nginx_networks: external: true 注：\nnetworks与nginx-proxy加入同一个网络中 volumes存放portainer数据 environment环境变量配置portainer容器使用的域名，这个变量是nginx-proxy使用的 启动 1 docker-compose up -d 然后就可以用http://portainer.weii.ink访问啦！\n启用证书加密 申请免费的域名证书 我已经申请过了...不在说了 证书文件命名为portainer.weii.ink.crt和portainer.weii.ink.key 证书文件放到nginx-proxy/nginx/certs路径下 重启nginx-proxy 验证 ubuntu@VM-0-6-ubuntu:~/project/nginx-proxy$ docker exec -it nginx-proxy cat /etc/nginx/conf.d/default.conf # If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the # scheme used to connect to this server map $http_x_forwarded_proto $proxy_x_forwarded_proto { default $http_x_forwarded_proto; '' $scheme; } # If we receive X-Forwarded-Port, pass it through; otherwise, pass along the # server port the client connected to map $http_x_forwarded_port $proxy_x_forwarded_port { default $http_x_forwarded_port; '' $server_port; } # If we receive Upgrade, set Connection to \"upgrade\"; otherwise, delete any # Connection header that may have been passed to this server map $http_upgrade $proxy_connection { default upgrade; '' close; } # Apply fix for very long server names server_names_hash_bucket_size 128; # Default dhparam ssl_dhparam /etc/nginx/dhparam/dhparam.pem; # Set appropriate X-Forwarded-Ssl header map $scheme $proxy_x_forwarded_ssl { default off; https on; } gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; log_format vhost '$host $remote_addr - $remote_user [$time_local] ' '\"$request\" $status $body_bytes_sent ' '\"$http_referer\" \"$http_user_agent\"'; access_log off; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384'; ssl_prefer_server_ciphers off; resolver 127.0.0.11; # HTTP 1.1 support proxy_http_version 1.1; proxy_buffering off; proxy_set_header Host $http_host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $proxy_connection; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto; proxy_set_header X-Forwarded-Ssl $proxy_x_forwarded_ssl; proxy_set_header X-Forwarded-Port $proxy_x_forwarded_port; # Mitigate httpoxy attack (see README for details) proxy_set_header Proxy \"\"; server { server_name _; # This is just an invalid value which will never trigger on a real hostname. listen 80; access_log /var/log/nginx/access.log vhost; return 503; } # portainer.weii.ink upstream portainer.weii.ink { ## Can be connected with \"nginx_networks\" network # portainer server 192.168.0.2:9000; } server { server_name portainer.weii.ink; listen 80 ; access_log /var/log/nginx/access.log vhost; return 301 https://$host$request_uri; } server { server_name portainer.weii.ink; listen 443 ssl http2 ; access_log /var/log/nginx/access.log vhost; ssl_session_timeout 5m; ssl_session_cache shared:SSL:50m; ssl_session_tickets off; ssl_certificate /etc/nginx/certs/portainer.weii.ink.crt; ssl_certificate_key /etc/nginx/certs/portainer.weii.ink.key; add_header Strict-Transport-Security \"max-age=31536000\" always; location / { proxy_pass http://portainer.weii.ink; } } # whoami.local upstream whoami.local { ## Can be connected with \"nginx_networks\" network # nginx-proxy_whoami_1 server 192.168.0.4:8000; } server { server_name whoami.local; listen 80 ; access_log /var/log/nginx/access.log vhost; location / { proxy_pass http://whoami.local; } } ubuntu@VM-0-6-ubuntu:~/project/nginx-proxy$ nginx-proxy已经自动配置好代理，以及SSL证书\n最后 访问https://portainer.weii.ink就会有SSL证书啦！\n参考链接 nginx-proxy\n","description":"portainer使用nginx-proxy配置代理添加证书","tags":["portainer","nginx","docker","proxy"],"title":"portainer使用nginx-proxy配置代理添加证书","uri":"/2019/09/11/nginx_proxy-portainer/"},{"categories":null,"content":"默认情况下，Docker通过非联网的UNIX套接字运行。它还可以选择使用HTTP套接字进行通信。 如果您需要以安全的方式通过网络访问Docker，则可以通过指定tlsverify标志并将Docker的tlscacert标志指向 可信CA证书来启用TLS 。 在守护程序模式下，它仅允许来自由该CA签名的证书进行身份验证的客户端的连接。在客户端模式下，它仅连接到具有由该CA签名的证书的服务器。\ndocker开启2376端口CA认证 环境 1 2 ubuntu 18.04 docker community 19.03 生成CA私钥和公钥 1 openssl genrsa -aes256 -out ca-key.pem 4096 按提示输入密码，两次\n1 openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem 按照提示依次输入密码、国家、省、市、组织名称等 如下俺的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ubuntu@VM-0-6-ubuntu:~/project$ openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem Enter pass phrase for ca-key.pem: Can't load /home/ubuntu/.rnd into RNG 139779211444672:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/ubuntu/.rnd You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]:CN State or Province Name (full name) [Some-State]:BeiJing Locality Name (eg, city) []:Beijing Organization Name (eg, company) [Internet Widgits Pty Ltd]:Weii Corp Organizational Unit Name (eg, section) []:Admin Common Name (e.g. server FQDN or YOUR name) []:Weii Email Address []:admin@weii.ink 创建服务器密钥和证书签名请求（CSR） 1 openssl genrsa -out server-key.pem 4096 1 openssl req -subj \"/CN=$HOST\" -sha256 -new -key server-key.pem -out server.csr 注：将$HOST替换为换成你自己服务器外网的IP或者域名。 确保“Common Name”与用于连接Docker的主机名匹配。 比如俺的\n1 openssl req -subj \"/CN=docker.weii.ink\" -sha256 -new -key server-key.pem -out server.csr 配置白名单 0.0.0.0表示所有ip都可以连接(但只有拥有证书的才可以连接成功)\n1 echo subjectAltName = DNS:docker.weii.ink,IP:127.0.0.1,IP:192.168.0.1 \u003e\u003e extfile.cnf 将Docker守护程序密钥的扩展使用情况属性设置为仅用于服务器身份验证 1 echo extendedKeyUsage = serverAuth \u003e\u003e extfile.cnf 生成签名证书(输入之前设置的密码) 1 openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf 客户端key 1 2 openssl genrsa -out key.pem 4096 openssl req -subj '/CN=client' -new -key key.pem -out client.csr 认证 1 echo extendedKeyUsage = clientAuth \u003e extfile-client.cnf 生成cert.pem,需要输入前面设置的密码，生成签名证书 1 openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnf 删除不需要的文件，两个证书签名请求 1 rm -v client.csr server.csr 修改权限 1 2 chmod -v 0400 ca-key.pem key.pem server-key.pem chmod -v 0444 ca.pem server-cert.pem cert.pem 归集服务器证书 1 2 cp server-*.pem /etc/docker/ cp ca.pem /etc/docker/ 修改docker配置 1 vim /lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd 下面增加\n1 2 3 4 5 6 --tlsverify \\ --tlscacert=/etc/docker/ca.pem \\ --tlscert=/etc/docker/server-cert.pem \\ --tlskey=/etc/docker/server-key.pem \\ -H tcp://0.0.0.0:2376 \\ -H unix:///var/run/docker.sock \\ 重新加载daemon并重启docker 1 2 systemctl daemon-reload systemctl restart docker 客户端相关证书 1 2 3 \u003e --cert cert.pem \u003e --key key.pem \u003e --cacert ca.pem 验证 1 2 3 4 5 ubuntu@VM-0-6-ubuntu:~/project/CA$ curl https://127.0.0.1:2376/images/json \\ \u003e --cert cert.pem \\ \u003e --key key.pem \\ \u003e --cacert ca.pem [{\"Containers\":-1,\"Created\":1566349217,\"Id\":\"sha256:ed7d2ff5a6232b43bdc89a2220ed989f532c3794422aa2a86823b8bc62e71447\",\"Labels\":null,\"ParentId\":\"\",\"RepoDigests\":[\"redis@sha256:50899ea1ceed33fa03232f3ac57578a424faa1742c1ac9c7a7bdb95cdf19b858\"],\"RepoTags\":[\"redis:alpine\"],\"SharedSize\":-1,\"Size\":29331594,\"VirtualSize\":29331594},{\"Containers\":-1,\"Created\":1565904159,\"Id\":\"sha256:5a3221f0137beb960c34b9cf4455424b6210160fd618c5e79401a07d6e5a2ced\",\"Labels\":{\"maintainer\":\"NGINX Docker Maintainers \u003cdocker-maint@nginx.com\u003e\"},\"ParentId\":\"\",\"RepoDigests\":[\"nginx@sha256:53ddb41e46de3d63376579acf46f9a41a8d7de33645db47a486de9769201fec9\"],\"RepoTags\":[\"nginx:latest\"],\"SharedSize\":-1,\"Size\":125958368,\"VirtualSize\":125958368},{\"Containers\":-1,\"Created\":1565786892,\"Id\":\"sha256:cfcdf565ff94de927d0a86c60e78f7d27e82da313f805d66310785cba4e8452a\",\"Labels\":null,\"ParentId\":\"\",\"RepoDigests\":[\"python@sha256:553fd76c04ee1ac1db8ef518161bb6ec325cc3ce3e55bbad73bf40e3abe23960\"],\"RepoTags\":[\"python:3.6\"],\"SharedSize\":-1,\"Size\":913432043,\"VirtualSize\":913432043},{\"Containers\":-1,\"Created\":1564107108,\"Id\":\"sha256:2b4ddf654e1c413b21c7253125aa0f34a4ff74154558940fa689f8754ec853c5\",\"Labels\":null,\"ParentId\":\"\",\"RepoDigests\":[\"portainer/portainer@sha256:a16919b3e02323e4bd0a8c5023d6fd569525297b9dc9a028d778cb6e13512be5\"],\"RepoTags\":[\"portainer/portainer:latest\"],\"SharedSize\":-1,\"Size\":77680455,\"VirtualSize\":77680455},{\"Containers\":-1,\"Created\":1562403218,\"Id\":\"sha256:d279b4072846e89af1dfeb2982addf8c4f2125ad929bb536875e3a32700b86ec\",\"Labels\":{\"maintainer\":\"sameer@damagehead.com\"},\"ParentId\":\"\",\"RepoDigests\":[\"sameersbn/squid@sha256:e98299069f0c6e3d9b9188903518e2f44ac36b1fa5007e879af518e1c0a234af\"],\"RepoTags\":[\"sameersbn/squid:3.5.27-2\"],\"SharedSize\":-1,\"Size\":162465195,\"VirtualSize\":162465195},{\"Containers\":-1,\"Created\":1558433068,\"Id\":\"sha256:704607fca3b537a687a24da68993280d1f4030d138a844d9d5dea650f115f0c7\",\"Labels\":null,\"ParentId\":\"\",\"RepoDigests\":[\"filebrowser/filebrowser@sha256:dda58e42fe876520aa2f4a1087023a90ae894263707c4f701d36fda124a20741\"],\"RepoTags\":[\"filebrowser/filebrowser:latest\"],\"SharedSize\":-1,\"Size\":32732332,\"VirtualSize\":32732332}] 另一种验证方式\n1 ubuntu@VM-0-6-ubuntu:~/project/CA$ docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem -H=docker.weii.ink:443 ps 参考链接 Docker文档\n","description":"Docker开启2376端口使用CA认证","tags":["Docker","CA","SSL"],"title":"Docker开启2376端口使用CA认证","uri":"/2019/09/11/docker_ca/"},{"categories":null,"content":"HDP(2.6.5)集群安装记录\nHDP(2.6.5)集群安装记录 网络配置(所有节点执行) 1 2 3 4 5 | hostname | IP | 说明 | | :------: | :-----------: | :----: | | hdp01 | 172.31.66.32 | master | | hdp02 | 172.31.66.34 | node1 | | hdp03 | 172.31.66.170 | node2 | 检查ip\n1 ifconfig 更改hostname\n1 vim /etc/hostname 将localhost更改成表格中的hostname(根据业务自行定义)\n更改SELINUX\n1 2 3 vim /etc/sysconfig/selinux #修改以下内容 SELINUX=disabled 重启服务器\n1 reboot 修改hosts文件\n1 vim /etc/hosts 对应上表hostname,为hosts文件添加路由\nSSH免密登录\n1 2 ssh-keygen #enter 复制生成的公钥到每个节点(主节点执行)\n1 2 scp /root/.ssh/id_rsa.put hdop02:/tmp/ #除master外都需要指向执行 其他节点执行\n1 cat /tmp/id_rsa.pub \u003e\u003e/root/.ssh/authorized_keys 检查一哈\n关闭防火墙\n1 2 systemctl stop firewalld.service systemctl disable firewalld.service 开启ntp服务\n1 2 3 yum install -y ntp systemctl enble ntpd systemctl start ntpd 安装JDK 下载jdk\njdk8 下载\n在当前目录打开shell\n1 2 3 4 5 6 7 tar -zxvf jdk-8u181-linux-x64.tar.gz -C /opt/java/ vi /etc/profile export JAVA_HOME=/opt/java/jdk1.8.0_181 export JRE_HOE=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export PATH=$PATH:$JAVA_HOME/bin 远程分发到其他服务器\n1 2 3 4 5 6 7 scp -r /opt/java/jdk1.8.0_181/ root@hdp02:/opt/java/ scp -r /opt/java/jdk1.8.0_181/ root@hdp03:/opt/java/ scp /etc/profile root@hdp02:/etc/ scp /etc/profile root@hdp03:/etc/ source /etc/profile Ambari安装 下载资源安装包\n1 2 3 4 wget http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.0/ambari-2.6.2.0-centos7.tar.gz wget http://public-repo-1.hortonworks.com/HDP/centos7/2.x/updates/2.6.5.0/HDP-2.6.5.0-centos7-rpm.tar.gz wget http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7/HDP-UTILS-1.1.0.22-centos7.tar.gz wget http://public-repo-1.hortonworks.com/HDP-GPL/centos7/2.x/updates/2.6.5.0/HDP-GPL-2.6.5.0-centos7-gpl.tar.gz 安装Apache HTTP 服务器\n1 2 3 4 yum install httpd -y #开启服务并设置开机自启动 systemctl start httpd.service systemctl enable httpd.service 安装制作yum源\n1 yum install yum-utils createrepo 创建http服务器\nhttp根目录默认是即/var/www/html/\n1 2 3 4 5 6 7 8 9 10 11 12 13 mkdir -p /var/www/html/ambari #cd /var/www/html/ambari #将下载好的安装包上传并解压 tar xvf HDP-2.6.5.0-centos7-rpm.tar.gz -C /var/www/html/ambari tar xvf ambari-2.6.2.0-centos7.tar.gz -C /var/www/html/ambari tar xvf HDP-UTILS-1.1.0.22-centos7.tar.gz -C /var/www/html/ambari tar xvf HDP-GPL-2.6.5.0-centos7-gpl.tar.gz -C /var/www/html/ambari # 删除压缩包 rm -rf ambari-2.6.2.0-centos7.tar.gz rm -rf HDP-2.6.5.0-centos7-rpm.tar.gz rm -rf HDP-UTILS-1.1.0.22-centos7.tar.gz rm -rf HDP-GPL-2.6.5.0-centos7-gpl.tar.gz 验证一哈\n配置ambari、HDP、HDP-UTILS的本地源\n1 2 3 4 cd /etc/yum.repos.d/ wget http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.0/ambari.repo wget http://public-repo-1.hortonworks.com/HDP/centos7/2.x/updates/2.6.5.0/hdp.repo wget http://public-repo-1.hortonworks.com/HDP-GPL/centos7/2.x/updates/2.6.5.0/hdp.gpl.repo 编辑ambari.repo，修改baseurl和gpgkey\n1 2 3 4 5 6 7 8 9 10 11 12 13 [root@hdc-data1 yum.repos.d]# vi ambari.repo #IP均为主节点IP,以下命令需变更IP #VERSION_NUMBER=2.6.2.0-155 [ambari-2.6.2.0] name=ambari Version - ambari-2.6.2.0 #baseurl=http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.0 baseurl=http://master/ambari/ambari/centos7/2.6.2.0-155 gpgcheck=1 #gpgkey=http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.0/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins gpgkey=http://master/ambari/ambari/centos7/2.6.2.0-155/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins enabled=1 priority=1 编辑hdp.repo，修改baseurl和gpgkey\nIP均为主节点IP\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [root@hdc-data1 yum.repos.d]# vi hdp.repo #VERSION_NUMBER=2.6.5.0-292 [HDP-2.6.5.0] name=HDP Version - HDP-2.6.5.0 #baseurl=http://public-repo-1.hortonworks.com/HDP/centos7/2.x/updates/2.6.5.0 baseurl=http://master/ambari/HDP/centos7/2.6.5.0-292 gpgcheck=1 #gpgkey=http://public-repo-1.hortonworks.com/HDP/centos7/2.x/updates/2.6.5.0/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins gpgkey=http://master/ambari/HDP/centos7/2.6.5.0-292/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins enabled=1 priority=1 [HDP-UTILS-1.1.0.22] name=HDP-UTILS Version - HDP-UTILS-1.1.0.22 #baseurl=http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.22/repos/centos7 baseurl=http://master/ambari/HDP-UTILS/centos7/1.1.0.22 gpgcheck=1 #gpgkey=http://public-repo-1.hortonworks.com/HDP/centos7/2.x/updates/2.6.5.0/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins gpgkey=http://master/ambari/HDP-UTILS/centos7/1.1.0.22/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins enabled=1 priority=1 编辑hdp.gpl.repo，修改baseurl和gpgkey\n1 2 3 4 5 6 7 8 9 10 11 12 [root@hdc-data1 yum.repos.d]# vi hdp.gpl.repo #VERSION_NUMBER=2.6.5.0-292 [HDP-GPL-2.6.5.0] name=HDP-GPL Version - HDP-GPL-2.6.5.0 #baseurl=http://public-repo-1.hortonworks.com/HDP-GPL/centos7/2.x/updates/2.6.5.0 baseurl=http://master/ambari/HDP-GPL/centos7/2.6.5.0-292 gpgcheck=1 #gpgkey=http://public-repo-1.hortonworks.com/HDP-GPL/centos7/2.x/updates/2.6.5.0/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins gpgkey=http://master/ambari/HDP-GPL/centos7/2.6.5.0-292/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins enabled=1 priority=1 分发到其他机器\n1 2 3 4 5 6 scp /etc/yum.repos.d/ambari.repo root@hdp02:/etc/yum.repos.d/ scp /etc/yum.repos.d/ambari.repo root@hdp03:/etc/yum.repos.d/ scp /etc/yum.repos.d/hdp.repo root@hdp02:/etc/yum.repos.d/ scp /etc/yum.repos.d/hdp.repo root@hdp03:/etc/yum.repos.d/ scp /etc/yum.repos.d/hdp.gpl.repo root@hdp02:/etc/yum.repos.d/ scp /etc/yum.repos.d/hdp.gpl.repo root@hdp03:/etc/yum.repos.d/ 每台机器yum配置\n1 2 3 yum clean all yum makecache yum list 安装Mysql 安装及初始化设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [root@hdc-data1 ~]# yum install mariadb-server [root@hdc-data1 ~]# systemctl start mariadb [root@hdc-data1 ~]# systemctl enable mariadb [root@hdc-data1 ~]# mysql_secure_installation #首先是设置密码，会提示先输入密码 Enter current password for root (enter for none):\u003c–初次运行直接回车 #设置密码 Set root password? [Y/n] \u003c– 是否设置root用户密码，输入y并回车或直接回车 New password: \u003c– 设置root用户的密码 Re-enter new password: \u003c– 再输入一次你设置的密码 #其他配置 Remove anonymous users? [Y/n] \u003c– 是否删除匿名用户，回车 Disallow root login remotely? [Y/n] \u003c–是否禁止root远程登录,回车, Remove test database and access to it? [Y/n] \u003c– 是否删除test数据库，回车 Reload privilege tables now? [Y/n] \u003c– 是否重新加载权限表，回车 安装完成后创建ambari数据库及用户\n1 2 #进入mysql shell mysql -uroot -p 1 2 3 4 create database ambari character set utf8 ; CREATE USER 'ambari'@'%'IDENTIFIED BY 'ambari123'; GRANT ALL PRIVILEGES ON *.* TO 'ambari'@'%'; FLUSH PRIVILEGES; 如果要安装Hive，创建Hive数据库和用户\n1 2 3 4 create database hive character set utf8 ; CREATE USER 'hive'@'%'IDENTIFIED BY 'hive123'; GRANT ALL PRIVILEGES ON *.* TO 'hive'@'%'; FLUSH PRIVILEGES; 如果要安装Oozie，创建Oozie数据库和用户\n1 2 3 4 create database oozie character set utf8 ; CREATE USER 'oozie'@'%'IDENTIFIED BY 'oozie123'; GRANT ALL PRIVILEGES ON *.* TO 'oozie'@'%'; FLUSH PRIVILEGES; 安装ambari\n1 yum install ambari-server 下载mysql驱动 mysql-connector-java 下载 将mysql-connector-Java.jar复制到/usr/share/java目录下\n1 2 mkdir /usr/share/java cp mysql-connector-java-5.1.40.jar /usr/share/java/mysql-connector-java.jar 将mysql-connector-java.jar复制到/var/lib/ambari-server/resources目录下\n1 cp mysql-connector-java-5.1.40.jar /var/lib/ambari-server/resources/mysql-jdbc-driver.jar 编辑/etc/ambari-server/conf/ambari.properties，添加如下内容\n1 2 3 server.jdbc.driver.path=/usr/share/java/mysql-connector-java.jar #【可选】修改默认8080端口 #client.api.port=18080 ambaria初始化\n1 2 3 #设置mysql驱动 ambari-server setup --jdbc-db=mysql --jdbc-driver=/usr/share/java/mysql-connector-java.jar ambari-server setup 完整初始化如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 [root@hdc-data1 ~]# ambari-server setup Using python /usr/bin/python Setup ambari-server Checking SELinux... SELinux status is 'disabled' Customize user account for ambari-server daemon [y/n] (n)? y Enter user account for ambari-server daemon (root): Adjusting ambari-server permissions and ownership... Checking firewall status... Checking JDK... [1] Oracle JDK 1.8 + Java Cryptography Extension (JCE) Policy Files 8 [2] Oracle JDK 1.7 + Java Cryptography Extension (JCE) Policy Files 7 [3] Custom JDK ============================================================================== Enter choice (1): 3 WARNING: JDK must be installed on all hosts and JAVA_HOME must be valid on all hosts. WARNING: JCE Policy files are required for configuring Kerberos security. If you plan to use Kerberos,please make sure JCE Unlimited Strength Jurisdiction Policy Files are valid on all hosts. Path to JAVA_HOME: /opt/java/jdk1.8.0_181 Validating JDK on Ambari Server...done. Checking GPL software agreement... GPL License for LZO: https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html Enable Ambari Server to download and install GPL Licensed LZO packages [y/n] (n)? y Completing setup... Configuring database... Enter advanced database configuration [y/n] (n)? y Configuring database... ============================================================================== Choose one of the following options: [1] - PostgreSQL (Embedded) [2] - Oracle [3] - MySQL / MariaDB [4] - PostgreSQL [5] - Microsoft SQL Server (Tech Preview) [6] - SQL Anywhere [7] - BDB ============================================================================== Enter choice (1): 3 Hostname (localhost): Port (3306): Database name (ambari): Username (ambari): Enter Database Password (bigdata): Re-enter password: Configuring ambari database... Configuring remote database connection properties... WARNING: Before starting Ambari Server, you must run the following DDL against the database to create the schema: /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql Proceed with configuring remote database connection properties [y/n] (y)? y Extracting system views... .....ambari-admin-2.6.2.0.155.jar ...... Adjusting ambari-server permissions and ownership... Ambari Server 'setup' completed successfully. 将Ambari数据库脚本导入到数据库\n1 2 3 4 #用Ambari用户（上面设置的用户）登录mysql mysql -u ambari -p use ambari; source /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql 启动Ambari\n1 ambari-server start WebUI配置 图截得有点糊...\n创建集群名称\n选择HDP版本和选择本地仓库\n配置HDP的Repository\n输入集群节点host(FQDN)和Ambari节点SSH的私钥\n等待ambari-agents注册\n若报错\n【遇到问题 Confirm Hosts】 注册ambari-agents时failed NetUtil.py:96 - EOF occurred in violation of protocol (_ssl.c:579) SSLError: Failed to connect. Please check openssl library versions. 解决：如下第三个方案，/etc/ambari-agent/conf/ambari-agent.ini文件只有执行该步骤进行注册才生成。修改后点击“Retry Failed”按钮，等待注册成功进入下一步。\n注:无报错时无此文件,需报错后再行处理\n1 2 3 4 5 6 7 8 9 # 1、yum upgrade openssl 已是最新本版，未解决 # 2、vi /etc/python/cert-verification.cfg 修改 verify=disable，未解决 [https] #verify=platform_default verify=disable # 3、最后解决方案 在ambari-agent的配置文件/etc/ambari-agent/conf/ambari-agent.ini 在 ［security］标签下面增加一项 [security] force_https_protocol=PROTOCOL_TLSv1_2 选择安装组件，（最小化安装HDFS+YARN+MAPREDUCE2+Ambari Metrics+SmartSense+ZooKeeper+Hbase）\n不必要的组件可以暂时不安装节省安装时间，后续可以再添加安装组件\n实际部署时需按规划设计进行分配（注意：Hbase HA 的话在Hbase Master 点击后面的小绿色+号，添加standby master）：\n工作节点角色分配(生产环境全勾了)\n组件配置信息修改 通常数据目录修改到/data/目录下，有红色信息提示的组件表示要输入相应的账号密码。以下示例，可根据自己的实际情况配置。\nHDFS\nHIVE,若数据库端口修改按实际填写\nOozie\nZookeeper\n暂时修改了以下属性，具体配置信息可根据实际情况后续相应修改\n1 2 3 4 5 6 | 端口属性 | 修改值 | | :---------------------------------------- | :------------------------------------ | | dfs.namenode.http-address | octserver1.hadoop:50770 （def:50070） | | yarn.resourcemanager.webapp.address | octserver2.hadoop:18088 （def:8088） | | yarn.resourcemanager.webapp.https.address | octserver2.hadoop:18090(def:8090) | | mapreduce.jobhistory.webapp.address | octserver2.hadoop:19898 (def:19888) | 等待安装完成\n直到所有节点成功安装完成才能进行下一步操作\n最终结果界面类似如下：\n","description":"hadoop集群安装记录,大数据平台","tags":["HDP","大数据平台","集群","记录"],"title":"HDP(2.6.5)集群安装记录","uri":"/2019/09/06/hdp_cluster_install/"},{"categories":["计算机","Linux","Docker"],"content":"前段时间搭建gitlab服务harbor仓库，需要用到SMTP服务用于发送邮件，用的自己办公邮箱做的测试，给别人自动发的邮件显示的是自己的邮箱。。。不正规😋申请公司的公共邮箱流程太繁琐了😥 还是自己搭建一个SMTP服务吧，自己动手丰衣足食。\ndocker使用SMTP搭建邮件发送服务 下载镜像 1 docker pull namshi/smtp 服务编排 采用docker-compose进行服务编排 启动docker-compose up -d or docker-compose -f docker-compose.yml up -d\n文件结构 1 2 3 4 5 6 7 8 9 . ├── conf │ ├── hosts │ └── resolv.conf ├── docker-compose.yml ├── README.md └── smtp.py 1 directory, 5 files docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 version: '3' services: SMTP: image: namshi/smtp container_name: SMTP restart: always ports: - \"10025:25\" environment: RELAY_NETWORKS: :0.0.0.0/0 volumes: - ./conf/hosts:/etc/hosts - ./conf/resolv.conf:/etc/resolv.conf 1.用为没有加密，所有就把默认的25端口给换个端口映射到宿主机，再说反正是公司内网环境。。。😎 2.RELAY_NETWORKS这个环境变量的作用是负责发件请求的拦截，当设置为“:0.0.0.0/0”时表示任意客户端皆可发起发件请求😁 3.指定主机域，不然发送出去的邮件，发件人为Mail Delivery System \u003cMailer-Daemon@c4de06bf41e5\u003e，添加主机名后就可以伪造发件人啦🤔\n4.邮件发送搜索goertek.com的域，因为公司内网DNS的MX邮件解析问题，在内网找不到要发送给内网邮箱用户的MX记录。。。就是内网找不到xxx@goertek.com的MX记录，所以指定DNS解析resolv.conf🌚 hosts 1 127.0.0.1 goertek.local resolv.conf 1 2 3 search goertek.com options ndots:0 nameserver 114.114.114.114 smtp.py 测试py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/python3 import smtplib from email.header import Header from email.mime.text import MIMEText sender = 'willson-wu-shi-ge-dao-lao-ma?@goertek.local' receivers = ['willson.wu@goertek.com'] message = MIMEText('SMTP服务邮件发送测试... 请勿回复！', 'plain', 'utf-8') subject = 'SMTP服务邮件测试' message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP('10.10.192.18', 10025) smtpObj.sendmail(sender, receivers, message.as_string()) print (\"邮件发送成功\") except smtplib.SMTPException: print (\"Error: 无法发送邮件\") 执行测试python3 smtp.py 亲测内网环境下发邮件没问题！满足需求！ 这下搭建的服务都可以配置SMTP邮件通知啦！👌\n参考资料 镜像namshi/smtp docker hub 上 pulls 10M+ 镜像作者的GayHub 使用Docker搭建SMTP服务器 ","description":"","tags":["SMTP","Docker","订阅"],"title":"使用docker搭建smtp服务","uri":"/2019/08/31/docker_install_smtp_server/"},{"categories":["计算机","Linux","n2n"],"content":"N2N 安装记录，至于N2N是用来做什么的，我也不知道，猪头保命🐷\n下载源码 1 wget https://github.com/ntop/n2n/archive/2.4.tar.gz 编译安装 1 2 3 tar xzvf 2.4.tar.gz cd /n2n-2.4 make \u0026\u0026 make install 注:make时有的机器可能需要安装依赖sudo apt install subversion build-essential libssl-dev net-tools\nsupernode 1 sudo nohup supernode -l 7443 -v \u0026 注：supernode需要运行在公网上。使用nobup后台运行，-l 7443监听7443端口，-v用于输出日志，便于调试。 查看日志tail -f nohup.out\nedge 1 2 3 4 5 edge -a 10.233.233.1 -c N2NNetwork -k 85f7a0affa50d933485a215eb10fb921 -l 106.53.85.19:7443 -p 3447 -m 16:0c:98:c8:b7:92 edge -a 10.233.233.2 -c N2NNetwork -k 85f7a0affa50d933485a215eb10fb921 -l 106.53.85.19:7443 -p 3447 -m 6e:30:77:c9:4f:bf edge -a 10.233.233.3 -c N2NNetwork -k 85f7a0affa50d933485a215eb10fb921 -l 106.53.85.19:7443 -p 3447 -m 82:e9:fc:be:e9:a7 参数说明：\n“-a \u003cIP地址\u003e”选项（静态地）指定了分配给 TAP 接口的 VPN 的 IP 地址。如果你想要使用 DHCP，你需要在其中一台边缘节点上配置一台 DHCP 服务器，然后使用“-a dhcp:0.0.0.0”选项来代替。 “-c \u003c组名\u003e”选项指定了 VPN 组的名字（最大长度为 16 个字节）。这个选项可以被用来在同样一组节点中创建多个 VPN。 “-k \u003c密钥\u003e”选项指定了一个由 twofish 加密的密钥来使用。如果你想要将密钥从命令行中隐藏，你可以使用 N2N_KEY 环境变量。 “-l \u003cIP地址:端口\u003e”选项指定了超级节点的监听 IP 地址和端口号。为了冗余，你可以指定最多两个不同的超级节点（比如 -l \u003c超级节点 A\u003e -l \u003c超级节点 B\u003e）。 “-p \u003c端口\u003e” 边缘节点暴露端口 “-m ”给 TAP 接口分配了一个静态的 MAC 地址。不使用这个参数的话，edge 命令将会随机生成一个 MAC 地址。事实上，为一个 VPN 接口强制指定一个静态的 MAC 地址是被强烈推荐的做法。否则，比如当你在一个节点上重启了 edge 守护程序的时候，其它节点的 ARP 缓存将会由于新生成的 MAC 地址而遭到污染，它们将不能向这个节点发送数据，直到被污染的 ARP 记录被消除。 注：以上3条命令为三台机器上执行的,其中10.233.233.1，运行在supernode节点上，另外其中ip自定义，但是需要注意别与需要组网的机器中的IP冲突了，不然会找不到路由！\n测试 查看ip 1 2 3 ubuntu@master01:~/project/n2n$ ip r default via 172.16.0.1 dev eth0 proto dhcp src 172.16.0.6 metric 100 10.233.233.0/24 dev edge0 proto kernel scope link src 10.233.233.1 1 2 3 ubuntu@master02:~/project/n2n$ ip r default via 172.16.0.1 dev eth0 proto dhcp src 172.16.0.6 metric 100 10.233.233.0/24 dev edge0 proto kernel scope link src 10.233.233.2 ping测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ubuntu@master01:~/project/n2n$ ping -c 1 10.233.233.2 PING 10.233.233.2 (10.233.233.2) 56(84) bytes of data. 64 bytes from 10.233.233.2: icmp_seq=1 ttl=64 time=39.1 ms --- 10.233.233.2 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 39.125/39.125/39.125/0.000 ms ubuntu@master01:~/project/n2n$ ping -c 1 10.233.233.3 PING 10.233.233.3 (10.233.233.3) 56(84) bytes of data. 64 bytes from 10.233.233.3: icmp_seq=1 ttl=64 time=39.1 ms --- 10.233.233.3 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 39.138/39.138/39.138/0.000 ms 查看vlan中的节点 1 2 3 4 5 6 7 8 9 10 11 12 13 ubuntu@master01:~/project/n2n$ sudo nmap -sP 10.233.233.0-255 Starting Nmap 7.60 ( https://nmap.org ) at 2019-08-25 12:00 CST Nmap scan report for 10.233.233.2 Host is up (-0.16s latency). MAC Address: 6E:30:77:C9:4F:BF (Unknown) Nmap scan report for 10.233.233.3 Host is up (-0.11s latency). MAC Address: 82:E9:FC:BE:E9:A7 (Unknown) Nmap scan report for VM-0-6-ubuntu (10.233.233.1) Host is up. Nmap done: 256 IP addresses (3 hosts up) scanned in 5.31 seconds 后续 组网后可以用来干啥？你猜!(逃)\n参考 ntop/n2n 异地也要玩局域网——使用N2N，实现异地服务器快速组建内网 使用N2N，实现异地服务器快速组建内网 使用n2n搭建虚拟局域网 ","description":"","tags":["Linux","n2n","科学"],"title":"使用N2N实现异地组网","uri":"/2019/08/25/n2n%E5%AE%89%E8%A3%85/"},{"categories":["计算机","Linux","Docker"],"content":"记录一下配置代理的过程。\ndocker使用squid搭建代理服务 记录一下 docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 version: '3' services: squid: image: sameersbn/squid:3.5.27-2 ports: - \"3128:3128\" volumes: - /home/dev/srv/docker/squid/cache:/var/spool/squid - ./squid.conf:/etc/squid/squid.conf restart: always squid.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 acl all src 0.0.0.0/0.0.0.0 acl SSL_ports port 443 acl Safe_ports port 80 # http acl Safe_ports port 443 # https acl CONNECT method CONNECT http_access allow all http_port 3128 visible_hostname proxy 使用 export ftp_proxy=http://10.10.192.18:3128 export http_proxy=http://10.10.192.18:3128 export https_proxy=http://10.10.192.18:3128 ","description":"","tags":["Docker","笔记","代理"],"title":"docker使用squid搭建代理服务","uri":"/2019/07/17/docker_uses_squid_to_set_up_proxy_services/"},{"categories":["计算机","Linux","Docker"],"content":"docker-compose 启动的网桥使用的网段与公司172.31.xx.xx网段冲突\ndocker使用docker-compose造成网段冲突 现象 docker-compose每次创建新的网桥的时候，还是使用默认的172.xx.xx.xx 在使用docker-compose启动服务其，创建了一个172.31.0.1的网桥，你说巧不巧，恰好公司使用的网络网段为172.31.66.xx所以使用172.31.xx.xx的网络，访问不了，哭死，咋办，不能改公司网络，只能修改docker网络配置了\n需求 只需修改一个地方，然后docker-compose up创建新网桥的时候就会使用我们设置的那个网段和子网；像修改docker0的网段一样，修改/etc/docker/daemon.json配置文件，docker0的网段就会变为在daemon.json里设置的这个；有没有类似于只要修改一个配置文件，docker-compose每次创建新的网桥的时候都会按照配置文件里的来\n解决方案 在/etc/docker/daemon.json添加\n1 2 3 4 5 6 7 8 9 { \"debug\" : true, \"default-address-pools\" : [ { \"base\" : \"12.11.0.0/16\", \"size\" : 24 } ] } 然后重启docker服务\n1 service docker restart 亲测可以使用\n","description":"","tags":["Docker","笔记","Network"],"title":"docker修改默认网段","uri":"/2019/07/17/docker_modifies_default_segments/"},{"categories":["计算机","Linux","Docker"],"content":"😂昨天刚建的GitLab服务今天就报500了，哭死😭排查发现是/var/lib/docker目录满了，咱也不知道原来里面放的啥，咱也不敢动，咱走还不行嘛！\n原因 1 2 3 [gitlab@cep-server-bj ~]$ df -h /var/lib/docker 文件系统 容量 已用 可用 已用% 挂载点 /dev/mapper/cl-root 50G 50G 180M 100% / 解决方案 先看看哪里还有地方让俺去\n1 2 3 4 5 6 7 8 9 10 11 12 13 [gitlab@cep-server-bj ~]$ df -h 文件系统 容量 已用 可用 已用% 挂载点 /dev/mapper/cl-root 50G 50G 180M 100% / devtmpfs 63G 0 63G 0% /dev tmpfs 63G 96K 63G 1% /dev/shm tmpfs 63G 4.2G 59G 7% /run tmpfs 63G 0 63G 0% /sys/fs/cgroup /dev/sda2 1014M 165M 850M 17% /boot /dev/sda1 200M 9.5M 191M 5% /boot/efi /dev/mapper/cl-home 5.7T 1.6T 4.2T 28% /home tmpfs 13G 20K 13G 1% /run/user/1000 tmpfs 13G 0 13G 0% /run/user/987 tmpfs 13G 0 13G 0% /run/user/1001 嘿，/dev/mapper/cl-home这个地方挺大的，就搬到这里吧🙂\n停了docker服务\n1 systemctl stop docker 给docker建个窝\n1 sudo mkdir -p /home/dev/var/lib/docker 搬家\n1 sudo rsync -avz /var/lib/docker/ /home/dev/var/lib/docker 改配置，指向新家\n添加dockerd的项\n1 sudo vim /lib/systemd/system/docker.service 把dockerd的启动参数添加--graph=/home/dev/var/lib/docker 修改如下内容：\n1 2 [Service] ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --graph=/home/dev/var/lib/docker 启动docker\n1 2 systemctl daemon-reload systemctl start docker 确认一哈 确认Docker Root Dir修改是否已经生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [gitlab@cep-server-bj lib]$ docker info Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 2 Server Version: 18.09.7 Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: false Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 894b81a4b802e4eb2a91d1ce216b8817763c29fb runc version: 425e105d5a03fabd737a126ad93d62a9eeede87f init version: fec3683 Security Options: seccomp Profile: default Kernel Version: 3.10.0-514.el7.x86_64 Operating System: CentOS Linux 7 (Core) OSType: linux Architecture: x86_64 CPUs: 24 Total Memory: 125.1GiB Name: cep-server-bj ID: HL4V:SNMX:2JYC:WISH:K6HM:J4YR:4GQG:SAFL:7YS4:MHNE:WK3I:XRTW Docker Root Dir: /home/dev/var/lib/docker Debug Mode (client): false Debug Mode (server): false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false Product License: Community Engine 看到Docker Root Dir: /home/dev/var/lib/docker我就知道这次搬家稳了😁\n话说上面这配置，玩吃鸡卡不卡🙃\n看看原来的镜像还在嘛\n1 2 3 4 [gitlab@cep-server-bj lib]$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE sameersbn/gitlab 12.0.0 6f35c078d0de 2 days ago 2.48GB sameersbn/redis 4.0.9-2 8f89b2ebe8be 6 months ago 90.3MB 确认没问题删除/var/lib/docker/中文件\n深入思考 深层次的问题点找到了。。。\n我是猪🐷\n系统盘总共才有50G的磁盘空间，我却把gitlab的数据全放到了系统根目录下了😂\ngitlab的数据占了40多个G的空间\n下次注意：启动docker其使用的volumes要放个大点的地方😁\n","description":"","tags":["Docker","笔记"],"title":"Docker目录磁盘空间满了","uri":"/2019/07/16/docker_low_disk_space/"},{"categories":["计算机","Linux","Docker"],"content":"公司有需求安装在172.31.66.63的gitlab服务需要迁移到10.10.192.18上，记录一下迁移过程。\n安装docker环境 新机器CentOS安装docker环境\n清理自带的docker 1 2 3 4 5 6 7 8 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装依赖 1 2 3 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加仓库 1 2 3 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装docker-ce 1 sudo yum install docker-ce docker-ce-cli containerd.io 安装docker-compose 1 sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 1 sudo chmod +x /usr/local/bin/docker-compose 迁移gitlab 把gitlab的数据迁移到新的机器中/srv/docker/gitlab\nscp -r 目录名 用户名@计算机IP或者计算机名称:远程路径\n备份 bundle exec bin/rake gitlab:backup:create RAILS_ENV=production\n恢复备份 bundle exec bin/rake gitlab:backup:restore RAILS_ENV=production BACKUP=1563163325_2019_07_15_11.1.4\ndocker-compose文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 version: '2' services: redis: restart: always image: sameersbn/redis:4.0.9-2 command: - --loglevel warning volumes: - /srv/docker/gitlab/redis:/var/lib/redis postgresql: restart: always image: sameersbn/postgresql:10-2 volumes: - /srv/docker/gitlab/postgresql:/var/lib/postgresql environment: - DB_USER=gitlab - DB_PASS=password - DB_NAME=gitlabhq_production - DB_EXTENSION=pg_trgm gitlab: restart: always image: sameersbn/gitlab:12.0.0 depends_on: - redis - postgresql ports: - \"80:80\" - \"10022:22\" volumes: - /srv/docker/gitlab/gitlab:/home/git/data environment: - DEBUG=false - DB_ADAPTER=postgresql - DB_HOST=postgresql - DB_PORT=5432 - DB_USER=gitlab - DB_PASS=password - DB_NAME=gitlabhq_production - REDIS_HOST=redis - REDIS_PORT=6379 - TZ=UTC - GITLAB_TIMEZONE=UTC - GITLAB_HTTPS=false - SSL_SELF_SIGNED=false - GITLAB_HOST=10.10.192.18 - GITLAB_PORT=80 - GITLAB_SSH_PORT=10022 - GITLAB_RELATIVE_URL_ROOT= - GITLAB_SECRETS_DB_KEY_BASE=9LMMzdfMCTwmmJLcq37kThXbv4xPrMCmWpmqcKxgTnvhg3VRVF4PTXXmXvv7twfr - GITLAB_SECRETS_SECRET_KEY_BASE=w9stWVkKTsj3qcPcV4vrCWhcmbrMm9W9fVvLKfV9NvgqXJwf9XKpbb43h4KnHsxR - GITLAB_SECRETS_OTP_KEY_BASE=KWFp9CgzRwWLFPKMTgHfwK4mVWtLTcFssw3JbnzkRHpPzcVWwFTww4wkzTxxvLwb - GITLAB_ROOT_PASSWORD= - GITLAB_ROOT_EMAIL=willson.wu@goertek.com - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true - GITLAB_NOTIFY_PUSHER=false - GITLAB_EMAIL=willson.wu@goertek.com - GITLAB_EMAIL_REPLY_TO=willson.wu@goertek.com - GITLAB_INCOMING_EMAIL_ADDRESS=willson.wu@goertek.com - GITLAB_BACKUP_SCHEDULE=daily - GITLAB_BACKUP_TIME=04:00 - SMTP_ENABLED=true - SMTP_DOMAIN=www.goertek.com - SMTP_HOST=smtp.goertek.com - SMTP_PORT=465 - SMTP_USER=willson.wu@goertek.com - SMTP_PASS=xxxxxxx - SMTP_STARTTLS=false - SMTP_TLS=true - SMTP_AUTHENTICATION=login - IMAP_ENABLED=false - IMAP_HOST=imap.gmail.com - IMAP_PORT=993 - IMAP_USER=mailer@example.com - IMAP_PASS=password - IMAP_SSL=true - IMAP_STARTTLS=false - OAUTH_ENABLED=false - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER= - OAUTH_ALLOW_SSO= - OAUTH_BLOCK_AUTO_CREATED_USERS=true - OAUTH_AUTO_LINK_LDAP_USER=false - OAUTH_AUTO_LINK_SAML_USER=false - OAUTH_EXTERNAL_PROVIDERS= - OAUTH_CAS3_LABEL=cas3 - OAUTH_CAS3_SERVER= - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false - OAUTH_CAS3_LOGIN_URL=/cas/login - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate - OAUTH_CAS3_LOGOUT_URL=/cas/logout - OAUTH_GOOGLE_API_KEY= - OAUTH_GOOGLE_APP_SECRET= - OAUTH_GOOGLE_RESTRICT_DOMAIN= - OAUTH_FACEBOOK_API_KEY= - OAUTH_FACEBOOK_APP_SECRET= - OAUTH_TWITTER_API_KEY= - OAUTH_TWITTER_APP_SECRET= - OAUTH_GITHUB_API_KEY= - OAUTH_GITHUB_APP_SECRET= - OAUTH_GITHUB_URL= - OAUTH_GITHUB_VERIFY_SSL= - OAUTH_GITLAB_API_KEY= - OAUTH_GITLAB_APP_SECRET= - OAUTH_BITBUCKET_API_KEY= - OAUTH_BITBUCKET_APP_SECRET= - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL= - OAUTH_SAML_IDP_CERT_FINGERPRINT= - OAUTH_SAML_IDP_SSO_TARGET_URL= - OAUTH_SAML_ISSUER= - OAUTH_SAML_LABEL=\"Our SAML Provider\" - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient - OAUTH_SAML_GROUPS_ATTRIBUTE= - OAUTH_SAML_EXTERNAL_GROUPS= - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL= - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME= - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME= - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME= - OAUTH_CROWD_SERVER_URL= - OAUTH_CROWD_APP_NAME= - OAUTH_CROWD_APP_PASSWORD= - OAUTH_AUTH0_CLIENT_ID= - OAUTH_AUTH0_CLIENT_SECRET= - OAUTH_AUTH0_DOMAIN= - OAUTH_AZURE_API_KEY= - OAUTH_AZURE_API_SECRET= - OAUTH_AZURE_TENANT_ID= - NGINX_WORKERS=4 #- GITLAB_MATTERMOST_ENABLED=true #- GITLAB_MATTERMOST_URL=\"http://10.10.192.18:10080/\" ","description":"","tags":["Docker","笔记"],"title":"Gitlab服务器迁移","uri":"/2019/07/15/gitlab_server_migration/"},{"categories":["计算机","Linux","Docker"],"content":"docker构建部署vue项目，减少构建后的docker镜像的大小，采用分阶段构建，只保留build\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 第一阶段,拉取node基础镜像并安装依赖,执行构建 FROM node:latest as builder # 标签 LABEL maintainer=\"\u003cwillson.wu@goertek.com\u003e\" # 参数 ARG WEB_GIT_URL=http://willson.wu:12345678@10.10.192.18/cep/BigData/energy-web.git # npm源 淘宝源 ARG NPM_REGISTRY=https://registry.npm.taobao.org # APT换源加速 阿里源 COPY .docker/conf/sources.list /etc/apt # 更新并安装git RUN apt-get -q update \u0026\u0026 \\ apt-get -q install -y git # 拉取代码 RUN git clone \"$WEB_GIT_URL\" # 设置工作目录 WORKDIR /energy-web # 换源加速并安装项目依赖 RUN npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver \u0026\u0026 \\ npm config set registry \"$NPM_REGISTRY\" \u0026\u0026 \\ npm install \u0026\u0026 \\ npm rebuild node-sass # 构建项目 RUN npm run build --scripts-prepend-node-path=auto # 第二阶段,将构建完的产物dist文件夹COPY到实际release的镜像中,并会丢弃第一阶段中其他的文件 FROM nginx:latest # copy nginx配置 COPY .docker/conf/default.conf /etc/nginx/conf.d # copy 项目编译生成文件 COPY --from=builder /energy-web/dist /usr/share/nginx/html # 暴露端口 EXPOSE 8080 ","description":"","tags":["Docker","笔记"],"title":"编写Dockerfile分阶段构建Vue项目","uri":"/2019/07/15/docker_build_vue/"},{"categories":["笔记","hexo"],"content":"现在使用的主题只有文章创建时间，并没有文章更新时间，就自己捣鼓捣鼓添加了一个文章更新时间，记录一下。\n注：在aria主题捣鼓的，别的不一定使用，但可以参考。\n_config.yml 修改主题的配置 主题配置文件添加开关，便于不想显示了可以关掉。\n1 2 # 显示更新日期 默认为post文件修改日期 display_updated: true index.njk 修改样式 修改主页的样式，在创建日期{% if post.date %} xxxxx {% endif %}下方添加下面代码。\n注：只有在主题配置中打开显示更新日期的开关，并且更新时间大于创建时间1天，才会显示更新时间。\n{%if theme.display_updated and post.updated - post.date \u003e 86400000 %} \u003cspan class=\"post-updated\"\u003e \u003cspan class=\"post-meta-divider divider\"\u003e|\u003c/span\u003e \u003ci class=\"far fa-calendar-plus\"\u003e\u003c/i\u003e \u003cspan\u003e \u003ctime title=\"post-updated\" itemprop=\"dateUpdated datePublished\" datetime=\"{{ moment(post.updated).format() }}\"\u003e {{ date(post.updated, config.date_format) }} \u003c/time\u003e \u003c/span\u003e \u003c/span\u003e {% endif %} post.njk 修改每一页详细内容的样式。 修改内容与index.njk一样。\n","description":"","tags":["hexo"],"title":"hexo添加文章更新时间","uri":"/2019/07/09/hexo_add_updated/"},{"categories":["计算机","Linux","Django"],"content":"使用Django==2.0.4报错缺少mysqlclient模块的解决方案\n写Django项目的时，启动Django==2.0.4启动直接报错，也是醉了。\ndjango.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module. Did you install mysqlclient? 说缺少mysqlclient模块。 简单pip install mysqlclient 😭也报错了。。。👇\n(venv) wilson@goertek-pc:~/Project/electric$ pip install mysqlclient Collecting mysqlclient Using cached https://files.pythonhosted.org/packages/f4/f1/3bb6f64ca7a429729413e6556b7ba5976df06019a5245a43d36032f1061e/mysqlclient-1.4.2.post1.tar.gz ERROR: Complete output from command python setup.py egg_info: ERROR: /bin/sh: 1: mysql_config: not found Traceback (most recent call last): File \"\u003cstring\u003e\", line 1, in \u003cmodule\u003e File \"/tmp/pip-install-rfq3y_2k/mysqlclient/setup.py\", line 16, in \u003cmodule\u003e metadata, options = get_config() File \"/tmp/pip-install-rfq3y_2k/mysqlclient/setup_posix.py\", line 51, in get_config libs = mysql_config(\"libs\") File \"/tmp/pip-install-rfq3y_2k/mysqlclient/setup_posix.py\", line 29, in mysql_config raise EnvironmentError(\"%s not found\" % (_mysql_config_path,)) OSError: mysql_config not found ---------------------------------------- ERROR: Command \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-install-rfq3y_2k/mysqlclient/ 不会百度啊！一查原来是缺少依赖libmysqld-dev 安装一哈\nsudo apt-get install libmysqld-dev ok 没毛病，解决了，记录一下。\n","description":"","tags":["Python","Django","笔记"],"title":"pip安装mysqlclient报错","uri":"/2019/06/18/pip_install_mysqlclient_reported_error/"},{"categories":["计算机","Linux","Docker"],"content":"在公司内网搭建个聊天服务，专门用来唠嗑，吹牛逼。为啥不用公司内网的通讯工具？俺又不傻，万一被公司逮到在上班时间闲聊，其实也没事哈。主要还是想搞点东西练手☺简单记录一下采用Docker安装Zulip的过程\nZulip的docker镜像在国外比较慢，我才用的是自己阿里云的镜像加速。\n修改docker-compose.yml文件，其中由个别需要记录的。\n就拿邮箱配置吧，由于公司邮箱对随机token的名字的邮箱会识别为垃圾邮件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 version: '2' services: database: image: 'zulip/zulip-postgresql' environment: POSTGRES_DB: 'zulip' POSTGRES_USER: 'zulip' # Note that you need to do a manual `ALTER ROLE` query if you # change this on a system after booting the postgres container # the first time on a host. Instructions are available in README.md. POSTGRES_PASSWORD: 'REPLACE_WITH_SECURE_POSTGRES_PASSWORD' volumes: - '/opt/docker/zulip/postgresql/data:/var/lib/postgresql/data:rw' memcached: image: 'quay.io/sameersbn/memcached:latest' restart: always rabbitmq: image: 'rabbitmq:3.7.7' hostname: zulip-rabbit restart: always environment: RABBITMQ_DEFAULT_USER: 'zulip' RABBITMQ_DEFAULT_PASS: 'REPLACE_WITH_SECURE_RABBITMQ_PASSWORD' volumes: - '/opt/docker/zulip/rabbitmq:/var/lib/rabbitmq:rw' redis: image: 'quay.io/sameersbn/redis:latest' volumes: - '/opt/docker/zulip/redis:/var/lib/redis:rw' zulip: image: 'zulip/docker-zulip:2.0.4-0' ports: - '80:80' - '443:443' environment: DB_HOST: 'database' DB_HOST_PORT: '5432' DB_USER: 'zulip' SSL_CERTIFICATE_GENERATION: 'self-signed' SETTING_MEMCACHED_LOCATION: 'memcached:11211' SETTING_RABBITMQ_HOST: 'rabbitmq' SETTING_REDIS_HOST: 'redis' # 这是邮件的密码，用来配置SMTP的，所以邮箱需要打开SMTP支持 SECRETS_email_password: 'xxxxxx' # These should match POSTGRES_PASSWORD and RABBITMQ_DEFAULT_PASS. SECRETS_rabbitmq_password: 'REPLACE_WITH_SECURE_RABBITMQ_PASSWORD' SECRETS_postgres_password: 'REPLACE_WITH_SECURE_POSTGRES_PASSWORD' SECRETS_secret_key: 'REPLACE_WITH_SECURE_SECRET_KEY' SETTING_EXTERNAL_HOST: '172.31.66.194' SETTING_ZULIP_ADMINISTRATOR: 'willson.wu@goertek.com' # 公司的DNS服务器经常性的被污染，直接用IP访问 SETTING_EMAIL_HOST: '123.133.65.6' # e.g. smtp.example.com SETTING_EMAIL_HOST_USER: 'willson.wu@goertek.com' SETTING_EMAIL_PORT: '25' # It seems that the email server needs to use ssl or tls and can't be used without it # 公司邮箱支持SSL，但是使用SSL需要用域名，直接不用也没有事，反正是公司内网 SETTING_EMAIL_USE_SSL: 'False' SETTING_EMAIL_USE_TLS: 'False' # 下面这两个配置，小坑了一下，由于公司邮箱对垃圾邮件的拦截策略，所以需要把随机发送的邮箱名字给禁掉，并且固化为自己固定的邮箱。 SETTING_ADD_TOKENS_TO_NOREPLY_ADDRESS: 'False' SETTING_NOREPLY_EMAIL_ADDRESS: 'willson.wu@goertek.com' ZULIP_AUTH_BACKENDS: 'EmailAuthBackend' # Uncomment this when configuring the mobile push notifications service # SETTING_PUSH_NOTIFICATION_BOUNCER_URL: 'https://push.zulipchat.com' volumes: - '/opt/docker/zulip/zulip:/data:rw' ulimits: nofile: soft: 40000 hard: 50000 ","description":"","tags":["Python","Docker","Zulip","笔记"],"title":"zulip安装记录","uri":"/2019/06/18/zulip_installation_record/"},{"categories":["笔记","博客园"],"content":"最近有些空闲时间想着把原来自学python的时候在博客园写的乱七八糟的东西给迁移到Hexo托管到github pages.\n毕竟那也算是我写的，虽然有的地方抄的别人的，但是我会了，那就是我的！（牛逼坏了，叉腰！）\n迁移准备 下载博客园备份文件 使用python写个脚本 脚本原理 使用sax解析xml数据，然后使用html2text转换成markdown文档，然后分成单个文件存储。 就这么简单，没啥难度。\n运行脚本 运行python脚本，迁移就算完成了，简不简单，意不意外，惊不惊喜！\n迁移脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 import xml.sax from datetime import datetime import html2text class CNBlogsHandler(xml.sax.ContentHandler): def __init__(self): self.CurrentData = \"\" self.title = \"\" self.author = \"\" self.pubDate = \"\" self.guid = \"\" self.description = \"\" self.fileName = \"\" self.date = \"\" self.url = \"\" # 元素开始调用 def startElement(self, tag, attributes): self.CurrentData = tag if tag == \"item\": print(\"*****item*****\") # 元素结束调用 def endElement(self, tag): if self.CurrentData == \"title\": print(\"title:\", self.title) elif self.CurrentData == \"author\": print(\"author:\", self.author) elif self.CurrentData == \"pubDate\": print(\"pubDate:\", self.pubDate) elif self.CurrentData == \"guid\": print(\"guid:\", self.guid) elif self.CurrentData == \"description\": # print(\"description:\", self.description) self.saveFile() self.CurrentData = \"\" # 读取字符时调用 def characters(self, content): if self.CurrentData == \"title\": self.title = content elif self.CurrentData == \"author\": self.author = content elif self.CurrentData == \"pubDate\": self.pubDate = content GMT_FORMAT = '%a, %d %b %Y %H:%M:%S GMT' self.date = datetime.strptime(self.pubDate, GMT_FORMAT) elif self.CurrentData == \"guid\": self.guid = content name = \"cnblog_\" + self.guid.split(\"/\")[-1].replace(\".html\", \"\").replace(\"_\", \"-\") self.fileName = name + \".md\" self.url = \"../../../../{}/{:0\u003e2}/{:0\u003e2}/{}/\".format(self.date.year, self.date.month, self.date.day, name) elif self.CurrentData == \"description\": self.description += content # 保存Md文件 def saveFile(self): if self.fileName != \"\": md = html2text.html2text(self.description) with open(self.fileName, mode=\"w\", encoding=\"utf-8\") as f: s = \"\"\"--- title: {0} date: {1} categories: - 笔记 - 博客园 tags: - 博客园 - 搬家 - cnblogs --- # [这是👉{0}👈的摘要]({3}) \u003c!--more--\u003e {2} \"\"\".format(self.title, self.date, md, self.url) f.write(s) self.description = \"\" if (__name__ == \"__main__\"): # 创建一个 XMLReader parser = xml.sax.make_parser() # 关闭命名空间 parser.setFeature(xml.sax.handler.feature_namespaces, 0) # 重写 ContextHandler Handler = CNBlogsHandler() parser.setContentHandler(Handler) parser.parse(\"CNBlogs_BlogBackup_131_201712_201906.xml\") 博客园备份xml文件\n迁移脚本py文件\n","description":"","tags":["Python","cnblogs","hexo","教程","搬家"],"title":"博客园文章迁移到Hexo","uri":"/2019/06/10/cnblog_to_hexo/"},{"categories":["计算机","Linux","Docker"],"content":"拉取centos基础镜像，用容器启动该基础镜像，直接在容器中部署宝塔管理面板\n1.拉取纯净系统镜像\ndocker pull centos:7.2.1511 2.启动镜像，映射主机与容器内8888端口\ndocker run -d -it -p 8888:8888 centos:7.2.1511 如果映射多个端口\ndocker run -d -it -p 8888:8888 -p 80:80 centos:7.2.1511 一般我们再映射时候。都会把 8888 80 443 3306 21 等一些常用端口都映射过去。 注：-p 80:80 前面80是宿主机本机端口，后面的80是docker容器的。 3.docker ps查看容器id，并进入容器\ndocker exec -it 容器ID bash 4.执行宝塔面板Centos安装命令\nyum install -y wget \u0026\u0026 wget -O install.sh http://download.bt.cn/install/install.sh \u0026\u0026 sh install.sh ","description":"","tags":["Docker","笔记"],"title":"docker安装宝塔管理面板","uri":"/2019/03/12/docker_install_bt_panel/"},{"categories":["计算机","Linux","Docker"],"content":"在开发的过程中免不了要使用数据库。使用docker构建一些常用的数据库免去安装的繁琐。\n序🤫 使用docker构建mysql、mongo、redis、postgresql、sqlserver数据库，可以直接使用，免去安装的繁琐。\nmysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: '3.1' services: mysql: image: mysql:5.7 container_name: mysql restart: always ports: - \"3306:3306\" environment: MYSQL_ROOT_PASSWORD: willson MYSQL_DATABASE: willson MYSQL_USER: willson MYSQL_PASSWORD: willson volumes: - \"/mnt/data2/database/mysql:/var/lib/mysql\" mongo mongo默认只能本机访问，开启外网访问必须添加command: [\"mongod\",\"--bind_ip\",\"0.0.0.0\"]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: '3.1' services: mongo: image: mongo:4.0.4 container_name: mongo restart: always ports: - 27017:27017 # environment: # MONGO_INITDB_ROOT_USERNAME: root # MONGO_INITDB_ROOT_PASSWORD: root # MONGO_INITDB_DATABASE_NAME: test command: [\"mongod\",\"--bind_ip\",\"0.0.0.0\"] volumes: - \"/mnt/data2/database/mongodb:/data/db\" redis 参数--bind 0.0.0.0开启外部访问 参数--appendonly yes 开启持久化\n1 2 3 4 5 6 7 8 9 10 version: '3.1' services: image: redis:alpine container_name: redis restart: always ports: - \"6379:6379\" command: [\"redis-server\",\"--bind\",\"0.0.0.0\",\"--appendonly\",\"yes\"] volumes: - \"/mnt/data2/database/redis:/data\" postgresql 使用ubuntu系统，其启动postgresql有个小坑。 在postgresql的volumes只能映射在本机系统文件夹下，不能映射到系统外置挂载的磁盘中。不然容器跑不起来。😥\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: '3.1' services: image: postgres container_name: postgresql restart: always ports: - \"5432:5432\" environment: POSTGRES_USER: root POSTGRES_PASSWORD: root POSTGRES_DB: test volumes: - '/opt/docker/database/postgresql/data:/var/lib/postgresql/data:rw' sqlServer 其中参数MSSQL_SA_PASSWORD的密码必须为8位不同的、高强度的，不然容器跑不起来。🤦‍\n1 2 3 4 5 6 7 8 9 10 11 12 version: '3.1' services: sqlServer: image: mcr.microsoft.com/mssql/server:2017-latest container_name: sqlServer restart: always ports: - \"1433:1433\" environment: ACCEPT_EULA: Y MSSQL_SA_PASSWORD: 123qwe!@# # MSSQL_PID: Express ","description":"","tags":["Docker","笔记"],"title":"基于docker-compose构建数据库","uri":"/2019/02/19/build_a_database_based_on_docker-compose/"},{"categories":["笔记"],"content":"我们在升级系统的时候，经常碰到需要更新服务器端数据结构等操作，之前的方式是通过手工编写alter sql脚本处理，经常会发现遗漏，导致程序发布到服务器上后无法正常使用。 现在我们可以使用Flask-Migrate插件来解决之，Flask-Migrate插件是基于Alembic，Alembic是由大名鼎鼎的SQLAlchemy作者开发数据迁移工具。\n使用Flask-Migrate进行管理数据库升级 我们在升级系统的时候，经常碰到需要更新服务器端数据结构等操作，之前的方式是通过手工编写alter sql脚本处理，经常会发现遗漏，导致程序发布到服务器上后无法正常使用。 现在我们可以使用Flask-Migrate插件来解决之，Flask-Migrate插件是基于Alembic，Alembic是由大名鼎鼎的SQLAlchemy作者开发数据迁移工具。\n具体操作如下：\n1.安装Flask-Migrate插件 $ pip install Flask-Migrate 2.修改Flask App部分的代码，以增加Migrate相关的Command 1 2 3 4 5 db = SQLAlchemy(app) migrate = Migrate(app, db) manager = Manager(app) manager.add_command('db', MigrateCommand) 3.初始化 $ python app.py db init 4.数据迁移，自动创建迁移代码 $ python app.py db migrate 5.更新数据库 $ python app.py db upgrade 后面如果有Model变更的话，在开发环境下只需要重复执行第4、5步即可。 而在服务器端只需要执行第5步即可实现数据库的迁移工作。\n参考链接\n","description":"","tags":["笔记","Flask","Python"],"title":"使用Flask-Migrate进行管理数据库升级","uri":"/2019/01/17/upgrade_with_flask-migration_management_database/"},{"categories":["笔记"],"content":"更换电脑后迁移hexo源代码😂\n备份必要文件 进入原来电脑的 hexo 博客目录，只拷如下几个目录：\n1 2 3 4 5 6 7 8 scaffolds 文章模版 必须备份 source 博客文章 必须备份 themes 主题 必须备份 .gitignore 限定在push时那些文件可以忽略 必须备份 _config.yml 站点配置文件 必须备份 package.json 安装包的名称 必须备份 .ssh 密钥文件 必须备份 ps:上面的文件可以存U盘或者打包上传到xx网盘。\n安装配置 Hexo 用之前的套路安装 Node.js 环境 Git 环境\n打开 开始菜单 运行 cmd 新建 blog 文件夹 md d:\\blog 进入 blog 文件夹 cd blog 安装 Hexo npm install -g hexo 初始化 Hexo hexo init 安装依赖包 npm install 上面的命令执行完了，你的博客目录会生成新的 hexo 博客文件，我们把刚才拷贝过来的文件，替换掉新生成的 博客文件，然后在复制 密钥文件 到新的密钥文件夹 在blog文件夹中打开 Git Bash Here\n初始化git本地仓库 git init 安装上传插件 npm install hexo-deployer-git --save RSS插件 npm install hexo-generator-feed 字数统计 阅读时长 插件 npm i --save hexo-wordcount 搜索插件 npm install hexo-generator-searchdb --save 如果你使用了更多的插件，在这里安装就可以了。 配置Git 输入你自己的邮箱地址 1 2 git config --global user.name git config --global user.email 生成新的 public 文件夹 hexo g 开始上传 hexo博客 hexo d date: 2019-05-31 09:41:53\n采用Onedrive备份hexo博客源码\n备份文件\n简单方便，只要把blog文件目录放到Onedrive中，其会自动备份的。新电脑登录Onedrive拉取blog文件。\n安装环境\n安装node.js 安装hexo npm install -g hexo 预览blog hexo s 生成blog hexo g 上传blog hexo d 搞定收工😁 ","description":"","tags":["教程","hexo"],"title":"换电脑hexo源码迁移","uri":"/2019/01/15/change_the_computer_hexo_source_migration/"},{"categories":["计算机","Linux","Docker"],"content":"入坑了，入了Docker的坑，了解了一下docker安装， 照着教程学着部署了一下Flask， Docker使用uwsgi+nginx+python3.6镜像部署Flask\nDocker 安装 占坑，因为我已经装过了\nsudo apt-get install docker 然后查看是否安装成功\nsudo docker -v Docker 镜像制作 编写Dockerfile 文件 因为我是用的flask项目是一个简单的demo没有使用第三方库 也就不用安装第三方库\nFROM tiangolo/uwsgi-nginx-flask:python3.6 COPY ./app /app 第一句表示，该镜像由 tiangolo/uwsgi-nginx-flask:python3.6 继承而来 第二句 拷贝项目文件到镜像中 我的项目结构 uwsgi.ini 文件：\n1 2 3 [uwsgi] module = main callable = app 完成后，在跟目录，即 Dockerfile 所在目录运行以下命令：\nsudo docker build -t myimage . 构建镜像。（注意后面的 点 ）\nDocker 启动 运行以下命令启动 容器：\ndocker container run --name mycon --rm -d -p 9001:80 -it myimage 其中 --name 表示容器名， --rm 表示停止容器后删除容器， -p 9001:80 表示将当前宿主机 9001 端口对应到容器中 80 端口， -it myimage 表示使用 myimage 镜像（即上面生成的镜像）。\n参考文章\n","description":"","tags":["Flask"],"title":"Docker镜像部署Flask","uri":"/2018/06/05/docker_images_deploy_flask/"},{"categories":["计算机","Win10"],"content":"前言 使用hexo搭建静态博客确实方便,页面托管到github pages上 写博客只需编写md文件即可,markdown语法简单,使用方便 原来也用过wordpress建博客,也挺好的,相比较下hexo比wordpress要轻便\n使用hexo优点 熟练git使用方法 掌握markdown语法 GitHub pages托管静态页面 可以加入最大同性交友社区(误) hexo使用 hexo具体安装自己google\n生成页面\nhexo g 创建博文\nhexo n 博文名 发布博文\nhexo d 改进创建博文的不便捷 创建博文需要到blog根目录打开powershell 运行\nhexo n name 然后需要到_posts目录下打开刚才创建的name.md 进行编写博文 个人觉得比较繁琐,就想着改进一下\n一键创建blog文原理 就是把几个命令组合到一起,很简单 比如我的:\ncd D:\\python\\WilsonBlog | hexo n {query} | notepad++.exe D:\\python\\WilsonBlog\\source\\_posts\\{query}.md 先cd到博客目录 运行hexo n name 创建博文 调用notepad++打开刚创建的博文 这样就能在任何地方打开powershell就能创建博文了 但是这个还不够好,因为还需要手敲命令,麻烦! 在改进一下 个人非常喜欢使用listary这个快速搜索工具 其支持自定义命令,每次启动只需双击ctrl就可以 具体如下图所示: 这样在任何地方只需双击ctrl键输入关键字blog 博文名 即可创建博文\n实现效果 ","description":"","tags":["教程","hexo"],"title":"一键创建blog文","uri":"/2018/06/04/touch_blog_post/"},{"categories":["笔记"],"content":"本Blog中所有文章图片都采用阿里云OSS对象存储作为图床 下面简单说一下如何使用oss作为图床\n使用方法 开通阿里云OSS对象储存 使用极简图床 下载谷歌插件极简图床方便采集上传图片 获取图片链接插入博客中即可 date: 2019-01-17 13:41:57\n换成静态资源了，怕图床挂了 🌚\n","description":"","tags":["教程","阿里云"],"title":"使用阿里云OSS图床","uri":"/2018/06/02/use_alibaba_cloud_oss_map_bed/"},{"categories":null,"content":"本博客采用的是Disqus评论系统，国内加载不出来\n说明 评论系统Disqus需使用google账号登陆，并FQ才能评论， 哈哈，并不是没个人都能评论的！！！ (整的好像有人会评论似的😂) 换句话说，留下的评论的都会FQ，开门社区送温暖！！！\n","description":"","tags":["Disqus"],"title":"关于本Blog的评论系统","uri":"/2018/06/02/about_this_blog_review_system/"},{"categories":["计算机","Linux","Docker"],"content":"这是一篇测试文章，用于测试Hexo搭建的github静态网站\n测试 添加分类 添加标签 hexo添加分类and标签的方法 只需要在文章分类中加入以下代码即可：\n--- title: test date: 2018-06-02 20:16:09 categories: - 计算机 - Linux - Docker tags: - Python - Docker - HTML --- 上述代码即是本片文章的分类and标签\n测试插入图片 markdown语法不支持指定宽高 代码 ![Dog](/static/posts/test/63035737.jpg ) 使用img标签指定宽高 \u003cimg src=\"/static/posts/test/63035737.jpg\" alt=\"Dog\" title=\"神烦狗\" style=\"width:100px;height:100px\"\u003e ","description":"","tags":["Python","Docker","HTML"],"title":"test","uri":"/2018/06/02/test/"},{"categories":["笔记","博客园"],"content":"这是👉Django基础01👈的摘要 Web框架本质 我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端。 这样我们就可以自己实现Web框架了。\n1 2 3 4 5 6 7 8 9 10 11 import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 80)) sk.listen(5) while True: conn, addr = sk.accept() data = conn.recv(8096) conn.send(b\"OK\") conn.close() 可以说Web服务本质上都是在这十几行代码基础上扩展出来的。这段代码就是它们的祖宗。\n用户的浏览器一输入网址，会给服务端发送数据，那浏览器会发送什么数据？怎么发？这个谁来定？ 你这个网站是这个规定，他那个网站按照他那个规定，这互联网还能玩么？\n所以，必须有一个统一的规则，让大家发送消息、接收消息的时候有个格式依据，不能随便写。\n这个规则就是HTTP协议，以后浏览器发送请求信息也好，服务器回复响应信息也罢，都要按照这个规则来。\nHTTP协议主要规定了客户端和服务器之间的通信格式，那HTTP协议是怎么规定消息格式的呢？\n让我们首先看下我们在服务端接收到的消息是什么。\n然后再看下我们浏览器收到的响应信息是什么。\n响应头在浏览器的network窗口可以看到，我们看到的HTML页面内容就是响应体。本质上还是字符串，因为浏览器认识HTML，所以才会渲染出页面。\nHTTP协议介绍\n每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。 HTTP响应的Header中有一个 Content-Type表明响应的内容格式。如 text/html表示HTML网页。\nHTTP GET请求的格式：\n​ ​ GET /path HTTP/1.1 ​ header1:v1\\r\\n ​ header2:v2\\r\\n\n使用 \\r\\n分隔多个header\nHTTP POST请求格式：\n​ ​ POST /path HTTP/1.1 ​ header1:v1\\r\\n ​ header2:v2\\r\\n ​ \\r\\n\\r\\n ​ 请求体...\n当遇到连续两个 \\r\\n\\r\\n时，表示Header部分结束了，后面的数据是Body。\nHTTP响应的格式：\n​ ​ 200 OK ​ Header1:v1\\r\\n ​ Header2:v2\\r\\n ​ \\r\\n\\r\\n ​ 响应体...\n让我们的Web框架在给客户端回复响应的时候按照HTTP协议的规则加上响应头，这样我们就实现了一个正经的Web框架了。\n1 2 3 4 5 6 7 8 9 10 11 12 import socket sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind(('127.0.0.1', 8000)) sock.listen(5) while True: conn, addr = sock.accept() data = conn.recv(8096) conn.send(b\"HTTP/1.1 200 OK\\r\\n\\r\\n\") conn.send(b\"OK\") conn.close() 上述通过socket来实现了其本质。\n对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。\n服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。\n应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。\n这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。\n这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。\nWSGI（Web Server Gateway Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。\n常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。\n​ ​ from wsgiref.simple_server import make_server\n​ ​ def run_server(environ, start_response): ​ start_response('200 OK', [('Content-Type', 'text/html;charset=utf8')]) # 设置HTTP响应的状态码和头信息 ​ return [bytes(\"Hello world!\", encoding=\"utf8\"),]\n​ ​ if name == 'main': ​ httpd = make_server('', 8000, run_server) ​ print(\"Serving HTTP on port 8000...\") ​ httpd.serve_forever()\n这样就结束了吗？ 如何让我们的Web服务根据用户请求的URL不同而返回不同的内容呢？\n小事一桩，我们可以从请求相关数据里面拿到请求的URL，然后做一个判断。\n​ ​ from wsgiref.simple_server import make_server\n​ ​ def run_server(environ, start_response): ​ start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ]) # 设置HTTP响应的状态码和头信息 ​ url = environ['PATH_INFO'] # 取到用户输入的url ​ if url == \"/index/\": ​ return [bytes(\"这是index页面\", encoding=\"utf8\"), ] ​ elif url == \"/home/\": ​ return [bytes(\"这是home页面\", encoding=\"utf8\"), ] ​ else: ​ return [bytes(\"404没有该页面\", encoding=\"utf8\"), ]\n​ ​ if name == 'main': ​ httpd = make_server('', 8000, run_server) ​ print(\"Serving HTTP on port 8000...\") ​ httpd.serve_forever()\n解决了不同URL返回不同内容的需求。 但是问题又来了，如果有很多很多页面怎么办？难道要挨个判断？ 当然不用，我们有更聪明的办法。\n​ ​ from wsgiref.simple_server import make_server\n​ ​ def index(): ​ return [bytes(\"这是index页面\", encoding=\"utf8\"), ]\n​ ​ def home(): ​ return [bytes(\"这是home页面\", encoding=\"utf8\"), ]\n​ ​ # 定义一个url和函数的对应关系 ​ URL_LIST = [ ​ (\"/index/\", index), ​ (\"/home/\", home), ​ ]\n​ ​ def run_server(environ, start_response): ​ start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ]) # 设置HTTP响应的状态码和头信息 ​ url = environ['PATH_INFO'] # 取到用户输入的url ​ func = None # 将要执行的函数 ​ for i in URL_LIST: ​ if i[0] == url: ​ func = i[1] # 去之前定义好的url列表里找url应该执行的函数 ​ break ​ if func: # 如果能找到要执行的函数 ​ return func() # 返回函数的执行结果 ​ else: ​ return [bytes(\"404没有该页面\", encoding=\"utf8\"), ]\n​ ​ if name == 'main': ​ httpd = make_server('', 8000, run_server) ​ print(\"Serving HTTP on port 8000...\") ​ httpd.serve_forever()\n完美解决了不同URL返回不同内容的问题。 但是我不想仅仅返回几个字符串，我想给浏览器返回完整的HTML内容，这又该怎么办呢？\n没问题，不管是什么内容，最后都是转换成字节数据发送出去的。 我可以打开HTML文件，读取出它内部的二进制数据，然后发送给浏览器。\n​ ​ from wsgiref.simple_server import make_server\n​ ​ def index(): ​ with open(\"index.html\", \"rb\") as f: ​ data = f.read() ​ return [data, ]\n​ ​ def home(): ​ with open(\"home.html\", \"rb\") as f: ​ data = f.read() ​ return [data, ]\n​ ​ # 定义一个url和函数的对应关系 ​ URL_LIST = [ ​ (\"/index/\", index), ​ (\"/home/\", home), ​ ]\n​ ​ def run_server(environ, start_response): ​ start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ]) # 设置HTTP响应的状态码和头信息 ​ url = environ['PATH_INFO'] # 取到用户输入的url ​ func = None # 将要执行的函数 ​ for i in URL_LIST: ​ if i[0] == url: ​ func = i[1] # 去之前定义好的url列表里找url应该执行的函数 ​ break ​ if func: # 如果能找到要执行的函数 ​ return func() # 返回函数的执行结果 ​ else: ​ return [bytes(\"404没有该页面\", encoding=\"utf8\"), ]\n​ ​ if name == 'main': ​ httpd = make_server('', 8000, run_server) ​ print(\"Serving HTTP on port 8000...\") ​ httpd.serve_forever()\n这网页能够显示出来了，但是都是静态的啊。页面的内容都不会变化的，我想要的是动态网站。\n没问题，我也有办法解决。我选择使用字符串替换来实现这个需求。\n​ ​ from wsgiref.simple_server import make_server\n​ ​ def index(): ​ with open(\"index.html\", \"rb\") as f: ​ data = f.read() ​ import time ​ time_str = str(time.time()) ​ data_str = str(data, encoding=\"utf8\") ​ data_str = data_str.replace(\"@@a@@\", time_str) ​ return [bytes(data_str, encoding=\"utf8\"), ]\n​ ​ def home(): ​ with open(\"home.html\", \"rb\") as f: ​ data = f.read() ​ return [data, ]\n​ ​ # 定义一个url和函数的对应关系 ​ URL_LIST = [ ​ (\"/index/\", index), ​ (\"/home/\", home), ​ ]\n​ ​ def run_server(environ, start_response): ​ start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ]) # 设置HTTP响应的状态码和头信息 ​ url = environ['PATH_INFO'] # 取到用户输入的url ​ func = None # 将要执行的函数 ​ for i in URL_LIST: ​ if i[0] == url: ​ func = i[1] # 去之前定义好的url列表里找url应该执行的函数 ​ break ​ if func: # 如果能找到要执行的函数 ​ return func() # 返回函数的执行结果 ​ else: ​ return [bytes(\"404没有该页面\", encoding=\"utf8\"), ]\n​ ​ if name == 'main': ​ httpd = make_server('', 8000, run_server) ​ print(\"Serving HTTP on port 8000...\") ​ httpd.serve_forever()\n这是一个简单的动态，我完全可以从数据库中查询数据，然后去替换我html中的对应内容，然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。 本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： jinja2\n下载jinja2:\n​ ​ pip install jinja2\n​ ​ \u003c!DOCTYPE html\u003e ​ ​ ​ ​ ​ ​ Title ​ ​ ​ 姓名：{{name}} ​ 爱好： ​ ​ {% for hobby in hobby_list %} ​ {{hobby}} ​ {% endfor %} ​ ​ ​ index2.html文件\n使用jinja2渲染index2.html文件：\n​ ​ from wsgiref.simple_server import make_server ​ from jinja2 import Template\n​ ​ def index(): ​ with open(\"index2.html\", \"r\") as f: ​ data = f.read() ​ template = Template(data) # 生成模板文件 ​ ret = template.render({\"name\": \"Alex\", \"hobby_list\": [\"烫头\", \"泡吧\"]}) # 把数据填充到模板里面 ​ return [bytes(ret, encoding=\"utf8\"), ]\n​ ​ def home(): ​ with open(\"home.html\", \"rb\") as f: ​ data = f.read() ​ return [data, ]\n​ ​ # 定义一个url和函数的对应关系 ​ URL_LIST = [ ​ (\"/index/\", index), ​ (\"/home/\", home), ​ ]\n​ ​ def run_server(environ, start_response): ​ start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ]) # 设置HTTP响应的状态码和头信息 ​ url = environ['PATH_INFO'] # 取到用户输入的url ​ func = None # 将要执行的函数 ​ for i in URL_LIST: ​ if i[0] == url: ​ func = i[1] # 去之前定义好的url列表里找url应该执行的函数 ​ break ​ if func: # 如果能找到要执行的函数 ​ return func() # 返回函数的执行结果 ​ else: ​ return [bytes(\"404没有该页面\", encoding=\"utf8\"), ]\n​ ​ if name == 'main': ​ httpd = make_server('', 8000, run_server) ​ print(\"Serving HTTP on port 8000...\") ​ httpd.serve_forever()\n现在的数据是我们自己手写的，那可不可以从数据库中查询数据，来填充页面呢？\n使用pymysql连接数据库：\n​ ​ conn = pymysql.connect(host=\"127.0.0.1\", port=3306, user=\"root\", passwd=\"xxx\", db=\"xxx\", charset=\"utf8\") ​ cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) ​ cursor.execute(\"select name, age, department_id from userinfo\") ​ user_list = cursor.fetchall() ​ cursor.close() ​ conn.close()\n创建一个测试的user表：\n​ ​ CREATE TABLE user( ​ id int auto_increment PRIMARY KEY, ​ name CHAR(10) NOT NULL, ​ hobby CHAR(20) NOT NULL ​ )engine=innodb DEFAULT charset=UTF8;\n模板的原理就是字符串替换，我们只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容。\nDjango Django官网下载页面\n安装（安装最新LTS版）： ​ ​ pip3 install django==1.11.9\n创建一个django项目： 下面的命令创建了一个名为\"mysite\"的Django 项目：\n​ ​ django-admin startproject mysite\n目录介绍： ​ ​ mysite/ ​ ├── manage.py # 管理文件 ​ └── mysite # 项目目录 ​ ├── init.py ​ ├── settings.py # 配置 ​ ├── urls.py # 路由 --\u003e URL和函数的对应关系 ​ └── wsgi.py # runserver命令就使用wsgiref模块做简单的web server\n运行Django项目： ​ ​ python manage.py runserver 127.0.0.1:8000\n模板文件配置： ​ ​ TEMPLATES = [ ​ { ​ 'BACKEND': 'django.template.backends.django.DjangoTemplates', ​ 'DIRS': [os.path.join(BASE_DIR, \"template\")], # template文件夹位置 ​ 'APP_DIRS': True, ​ 'OPTIONS': { ​ 'context_processors': [ ​ 'django.template.context_processors.debug', ​ 'django.template.context_processors.request', ​ 'django.contrib.auth.context_processors.auth', ​ 'django.contrib.messages.context_processors.messages', ​ ], ​ }, ​ }, ​ ]\n静态文件配置： ​ ​ STATIC_URL = '/static/' # HTML中使用的静态文件夹前缀 ​ STATICFILES_DIRS = [ ​ os.path.join(BASE_DIR, \"static\"), # 静态文件存放位置 ​ ]\n看不明白？有图有真相：\n刚开始学习时可在配置文件中暂时禁用csrf中间件，方便表单提交测试。\n​ ​ MIDDLEWARE = [ ​ 'django.middleware.security.SecurityMiddleware', ​ 'django.contrib.sessions.middleware.SessionMiddleware', ​ 'django.middleware.common.CommonMiddleware', ​ # 'django.middleware.csrf.CsrfViewMiddleware', ​ 'django.contrib.auth.middleware.AuthenticationMiddleware', ​ 'django.contrib.messages.middleware.MessageMiddleware', ​ 'django.middleware.clickjacking.XFrameOptionsMiddleware', ​ ]\nDjango基础必备三件套： ​ ​ from django.shortcuts import HttpResponse, render, redirect\nHttpResponse 内部传入一个字符串参数，返回给浏览器。\n例如：\n​ ​ def index(request): ​ # 业务逻辑代码 ​ return HttpResponse(\"OK\")\nrender 除request参数外还接受一个待渲染的模板文件和一个保存具体数据的字典参数。\n将数据填充进模板文件，最后把结果返回给浏览器。（类似于我们上面用到的jinja2）\n例如：\n​ ​ def index(request): ​ # 业务逻辑代码 ​ return render(request, \"index.html\", {\"name\": \"alex\", \"hobby\": [\"烫头\", \"泡吧\"]})\nredirect 接受一个URL参数，表示跳转到指定的URL。\n例如：\n​ ​ def index(request): ​ # 业务逻辑代码 ​ return redirect(\"/home/\")\n课后练习： Django版登录\n启动Django报错： Django 启动时报错 UnicodeEncodeError ...\n报这个错误通常是因为计算机名为中文，改成英文的计算机名重启下电脑就可以了。\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"Django基础01","uri":"/2018/03/22/cnblog_8621513/"},{"categories":["笔记","博客园"],"content":"这是👉Python连接MySQL数据库之pymysql模块使用👈的摘要 Python3连接MySQL 本文介绍Python3连接MySQL的第三方库--PyMySQL的基本使用。\nPyMySQL介绍 PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。\nDjango中也可以使用PyMySQL连接MySQL数据库。\nPyMySQL安装 pip install pymysql 连接数据库 注意事项 在进行本文以下内容之前需要注意：\n你有一个MySQL数据库，并且已经启动。 你有可以连接该数据库的用户名和密码 你有一个有权限操作的database 基本使用 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 定义要执行的SQL语句 sql = \"\"\" CREATE TABLE USER1 ( id INT auto_increment PRIMARY KEY , name CHAR(10) NOT NULL UNIQUE, age TINYINT NOT NULL )ENGINE=innodb DEFAULT CHARSET=utf8; \"\"\" # 执行SQL语句 cursor.execute(sql) # 关闭光标对象 cursor.close() # 关闭数据库连接 conn.close() 返回字典格式数据：\n# 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句并且将结果作为字典返回的游标 cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) # 定义要执行的SQL语句 sql = \"\"\" CREATE TABLE USER1 ( id INT auto_increment PRIMARY KEY , name CHAR(10) NOT NULL UNIQUE, age TINYINT NOT NULL )ENGINE=innodb DEFAULT CHARSET=utf8; \"\"\" # 执行SQL语句 cursor.execute(sql) # 关闭光标对象 cursor.close() # 关闭数据库连接 conn.close() 注意：\ncharset=\"utf8\"，编码不要写成\"utf-8\"\n增删改查操作 增 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" username = \"Alex\" age = 18 # 执行SQL语句 cursor.execute(sql, [username, age]) # 提交事务 conn.commit() cursor.close() conn.close() 插入数据失败回滚\n# 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" username = \"Alex\" age = 18 try: # 执行SQL语句 cursor.execute(sql, [username, age]) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 获取插入数据的ID(关联操作时会用到)\n# 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" username = \"Alex\" age = 18 try: # 执行SQL语句 cursor.execute(sql, [username, age]) # 提交事务 conn.commit() # 提交之后，获取刚插入的数据的ID last_id = cursor.lastrowid except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 批量执行\n# 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"INSERT INTO USER1(name, age) VALUES (%s, %s);\" data = [(\"Alex\", 18), (\"Egon\", 20), (\"Yuan\", 21)] try: # 批量执行多条插入SQL语句 cursor.executemany(sql, data) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 删 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() sql = \"DELETE FROM USER1 WHERE id=%s;\" try: cursor.execute(sql, [4]) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 改 # 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 修改数据的SQL语句 sql = \"UPDATE USER1 SET age=%s WHERE name=%s;\" username = \"Alex\" age = 80 try: # 执行SQL语句 cursor.execute(sql, [age, username]) # 提交事务 conn.commit() except Exception as e: # 有异常，回滚事务 conn.rollback() cursor.close() conn.close() 查 查询单条数据\n# 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 查询数据的SQL语句 sql = \"SELECT id,name,age from USER1 WHERE id=1;\" # 执行SQL语句 cursor.execute(sql) # 获取单条查询数据 ret = cursor.fetchone() cursor.close() conn.close() # 打印下查询结果 print(ret) 查询多条数据\n# 导入pymysql模块 import pymysql # 连接database conn = pymysql.connect(host=\"你的数据库地址\", user=\"用户名\",password=\"密码\",database=\"数据库名\",charset=\"utf8\") # 得到一个可以执行SQL语句的光标对象 cursor = conn.cursor() # 查询数据的SQL语句 sql = \"SELECT id,name,age from USER1;\" # 执行SQL语句 cursor.execute(sql) # 获取多条查询数据 ret = cursor.fetchall() cursor.close() conn.close() # 打印下查询结果 print(ret) 进阶用法 # 可以获取指定数量的数据 cursor.fetchmany(3) # 光标按绝对位置移动1 cursor.scroll(1, mode=\"absolute\") # 光标按照相对位置(当前位置)移动1 cursor.scroll(1, mode=\"relative\") ","description":"","tags":["博客园","搬家","cnblogs"],"title":"Python连接MySQL数据库之pymysql模块使用","uri":"/2018/03/21/cnblog_8616189/"},{"categories":["笔记","博客园"],"content":"这是👉Markdown 语法👈的摘要 Markdown 语法说明 (简体中文版) 概述 宗旨 Markdown 的目标是实现「易读易写」。\n可读性，无论如何，都是最重要的。一份使用 Markdown格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML格式的影响，包括Setext、atx、Textile、reStructuredText、Grutatext和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。\n总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。\n兼容 HTML Markdown 语法的目标是：成为一种适用于网络的 书写 语言。\nMarkdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种 书写 的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML或是Markdown；只要直接加标签就可以了。\n要制约的只有一些 HTML 区块元素――比如 \u003cdiv\u003e、\u003ctable\u003e、\u003cpre\u003e、\u003cp\u003e等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML区块标签外加上不必要的 \u003cp\u003e 标签。\n例子如下，在 Markdown 文件里加上一段 HTML 表格：\n​ 这是一个普通段落。\n1 2 3 4 5 \u003ctable\u003e \u003ctr\u003e \u003ctd\u003eFoo\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e ​\n这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown样式的*强调*会没有效果。\nHTML 的区段（行内）标签如 \u003cspan\u003e、\u003ccite\u003e、\u003cdel\u003e 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的\u003ca\u003e 或 \u003cimg\u003e 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： \u003c 和 \u0026 。 \u003c 符号用于起始标签，\u0026 符号则用于标记 HTML实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 \u0026lt; 和 \u0026amp;。\u0026 字符尤其让网络文档编写者受折磨，如果你要打「AT\u0026T」 ，你必须要写成「AT\u0026amp;T」。而网址中的 \u0026字符也要转换。比如你要链接到：http://images.google.com/images?num=30\u0026q=larry+bird你必须要把网址转换写为：http://images.google.com/images?num=30\u0026amp;q=larry+bird才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。\nMarkdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 \u0026 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 \u0026amp;。\n所以你如果要在文档中插入一个版权符号 (C)，你可以这样写：\u0026copy;Markdown 会保留它不动。而若你写AT\u0026TMarkdown 就会将它转为：AT\u0026amp;T\n类似的状况也会发生在 \u003c 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 \u003c 符号作为 HTML 标签的定界符使用，那Markdown 也不会对它做任何转换，但是如果你写：4\u003c5Markdown 将会把它转换为：4\u0026lt;5\n不过需要注意的是，code 范围内，不论是行内还是区块， \u003c 和 \u0026 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 \u003c 和 \u0026 都转换为 HTML 实体，才能在HTML 文件里面写出 HTML code。）\n区块元素 段落和换行 一个 Markdown段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 \u003cbr/\u003e 标签。\n如果你确实想要依赖 Markdown 来插入 \u003cbr/\u003e 标签的话，在插入处先按入两个以上的空格然后回车。\n的确，需要多费点事（多加空格）来产生 \u003cbr/\u003e ，但是简单地「每个换行都转换为 \u003cbr/\u003e」的方法在 Markdown 中并不适合，Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。\n标题 Markdown 支持两种标题的语法，类Setext 和类atx 形式。\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\n​ This is an H1 ​ ============= ​ ​ This is an H2 ​ -------------\n任何数量的 = 和 - 都可以有效果。\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\n​ # 这是 H1 ​ ​ ## 这是 H2 ​ ​ ###### 这是 H6\n你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\n​ # 这是 H1 # ​ ​ ## 这是 H2 ## ​ ​ ### 这是 H3 ######\n区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 \u003e 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 \u003e ：\n​ \u003e This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, ​ \u003e consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. ​ \u003e Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. ​ \u003e ​ \u003e Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse ​ \u003e id sem consectetuer libero luctus adipiscing.\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 \u003e ：\n​ \u003e This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, ​ consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. ​ Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. ​ ​ \u003e Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse ​ id sem consectetuer libero luctus adipiscing.\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 \u003e ：\n​ \u003e This is the first level of quoting. ​ \u003e ​ \u003e \u003e This is nested blockquote. ​ \u003e ​ \u003e Back to the first level.\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n​ \u003e ## 这是一个标题。 ​ \u003e ​ \u003e 1. 这是第一行列表项。 ​ \u003e 2. 这是第二行列表项。 ​ \u003e ​ \u003e 给出一些例子代码： ​ \u003e ​ \u003e return shell_exec(\"echo $input | $markdown_script\");\n任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择 增加引用阶层 。\n列表 Markdown 支持有序列表和无序列表。\n无序列表使用星号、加号或是减号作为列表标记：\n​ * Red ​ * Green ​ * Blue\n等同于：\n​ + Red ​ + Green ​ + Blue\n也等同于：\n​ - Red ​ - Green ​ - Blue\n有序列表则使用数字接着一个英文句点：\n​ 1. Bird ​ 2. McHale ​ 3. Parish\n很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\n​ ​ Bird ​ McHale ​ Parish ​ 如果你的列表标记写成：\n​ 1. Bird ​ 1. McHale ​ 1. Parish\n或甚至是：\n​ 3. Bird ​ 1. McHale ​ 8. Parish\n你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\n如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：\n​ * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. ​ Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, ​ viverra nec, fringilla in, laoreet vitae, risus. ​ * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. ​ Suspendisse id sem consectetuer libero luctus adipiscing.\n但是如果你懒，那也行：\n​ * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. ​ Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, ​ viverra nec, fringilla in, laoreet vitae, risus. ​ * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. ​ Suspendisse id sem consectetuer libero luctus adipiscing.\n如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 \u003cp\u003e 标签包起来，举例来说：\n​ * Bird ​ * Magic\n会被转换为：\n​ ​ Bird ​ Magic ​ 但是这个：\n​ * Bird ​ ​ * Magic\n会被转换为：\n​ ​ Bird\n​ Magic\n​ 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n​ 1. This is a list item with two paragraphs. Lorem ipsum dolor ​ sit amet, consectetuer adipiscing elit. Aliquam hendrerit ​ mi posuere lectus. ​ ​ Vestibulum enim wisi, viverra nec, fringilla in, laoreet ​ vitae, risus. Donec sit amet nisl. Aliquam semper ipsum ​ sit amet velit. ​ ​ 2. Suspendisse id sem consectetuer libero luctus adipiscing.\n如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\n​ * This is a list item with two paragraphs. ​ ​ This is the second paragraph in the list item. You're ​ only required to indent the first line. Lorem ipsum dolor ​ sit amet, consectetuer adipiscing elit. ​ ​ * Another item in the same list.\n如果要在列表项目内放进引用，那 \u003e 就需要缩进：\n​ * A list item with a blockquote: ​ ​ \u003e This is a blockquote ​ \u003e inside a list item.\n如果要放代码区块的话，该区块就需要缩进 两次 ，也就是 8 个空格或是 2 个制表符：\n​ * 一列表项包含一个列表区块： ​ ​ \u003c代码写在这\u003e\n当然，项目列表很可能会不小心产生，像是下面这样的写法：\n​ 1986. What a great season.\n换句话说，也就是在行首出现 数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。\n​ 1986. What a great season.\n代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 \u003cpre\u003e 和 \u003ccode\u003e 标签来把代码区块包起来。\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n​ 这是一个普通段落： ​ ​ 这是一个代码区块。\nMarkdown 会转换成：\n​ 这是一个普通段落：\n​ ​ 这是一个代码区块。\n这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：\n​ Here is an example of AppleScript: ​ ​ tell application \"Foo\" ​ beep ​ end tell\n会被转换为：\n​ Here is an example of AppleScript:\n​ ​ tell application \"Foo\"beepend tell\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n在代码区块里面， \u0026 、 \u003c 和 \u003e 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML原始码，只需要复制贴上，再加上缩进就可以了，剩下的Markdown 都会帮你处理，例如：\n​ ​ © 2004 Foo Corporation ​ 会被转换为：\n​ \u003cdiv class=\"footer\"\u003e ​ \u0026copy; 2004 Foo Corporation ​ \u003c/div\u003e ​ 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown语法相关的文件。\n分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n​ * * * ​ ​ *** ​ ​ ***** ​ ​ - - - ​ ​ ---------------------------------------\n区段元素 链接 Markdown 支持两种形式的链接语法：行内式和参考式两种形式。\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把title 文字包起来即可，例如：\n​ This is an example inline link. ​ ​ This link has no title attribute.\n会产生：\n​ This is ​ an example inline link.\n​ ​ This link has no ​ title attribute.\n如果你是要链接到同样主机的资源，你可以使用相对路径：\n​ See my About page for details.\n参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\n​ This is [an example][id] reference-style link.\n你也可以选择性地在两个方括号中间加上一个空格：\n​ This is [an example] [id] reference-style link.\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n​ [id]: http://example.com/ \"Optional Title Here\"\n链接内容定义的形式为：\n方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同：\n​ [foo]: http://example.com/ \"Optional Title Here\" ​ [foo]: http://example.com/ 'Optional Title Here' ​ [foo]: http://example.com/ (Optional Title Here)\n请注意： 有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\n链接网址也可以用尖括号包起来：\n​ [id]: http://example.com/ \"Optional Title Here\"\n你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\n​ [id]: http://example.com/longish/path/to/resource/here ​ \"Optional Title Here\"\n网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：\n​ [link text][a] ​ [link text][A]\n隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \"Google\" 链接到 google.com，你可以简化成：\n​ [Google][]\n然后定义链接内容：\n​ [Google]: http://google.com/\n由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\n​ Visit [Daring Fireball][] for more information.\n然后接着定义链接：\n​ [Daring Fireball]: http://daringfireball.net/\n链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\n下面是一个参考式链接的范例：\n​ I get 10 times more traffic from [Google] [1] than from ​ [Yahoo] [2] or [MSN] [3]. ​ ​ [1]: http://google.com/ \"Google\" ​ [2]: http://search.yahoo.com/ \"Yahoo Search\" ​ [3]: http://search.msn.com/ \"MSN Search\"\n如果改成用链接名称的方式写：\n​ I get 10 times more traffic from [Google][] than from ​ [Yahoo][] or [MSN][]. ​ ​ [google]: http://google.com/ \"Google\" ​ [yahoo]: http://search.yahoo.com/ \"Yahoo Search\" ​ [msn]: http://search.msn.com/ \"MSN Search\"\n上面两种写法都会产生下面的 HTML。\n​ I get 10 times more traffic from \u003ca href=\"http://google.com/\" ​ title=\"Google\"\u003eGoogle than from ​ Yahoo ​ or MSN.\n下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\n​ I get 10 times more traffic from Google ​ than from Yahoo or ​ MSN.\n参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\n使用 Markdown的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\n强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 \u003cem\u003e 标签包围，用两个* 或 _ 包起来的话，则会被转成 \u003cstrong\u003e，例如：\n​ single asterisks ​ ​ single underscores ​ ​ double asterisks ​ ​ double underscores\n会转成：\n​ single asterisks ​ ​ single underscores ​ ​ double asterisks ​ ​ double underscores\n你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。\n强调也可以直接插在文字中间：\n​ unfriggingbelievable\n但是 如果你的* 和 _ 两边都有空白的话，它们就只会被当成普通的符号 。\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n​ *this text is surrounded by literal asterisks*\n代码 如果要标记一小段行内代码，你可以用反引号把它包起来，例如：\n​ Use the printf() function.\n会产生：\n​ Use the printf() function.\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n​ There is a literal backtick (`) here.\n这段语法会产生：\n​ \u003cp\u003e\u003ccode\u003eThere is a literal backtick (`) here.\u003c/code\u003e\u003c/p\u003e\n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：\n​ A single backtick in a code span: ` ​ ​ A backtick-delimited string in a code span: `foo`\n会产生：\n​ A single backtick in a code span: \u003c/code\u003e\u003c/p\u003e ​ ​ \u003cp\u003eA backtick-delimited string in a code span: \u003ccode\u003efoo`\n在代码区段内，\u0026 和尖括号 都 会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：\n​ Please don't use any \u003cblink\u003e tags.\n转为：\n​ Please don't use any \u003cblink\u003e tags.\n你也可以这样写：\n​ \u0026#8212; is the decimal-encoded equivalent of \u0026mdash;.\n以产生：\n​ \u0026#8212; is the decimal-encoded ​ equivalent of \u0026mdash;.\n图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式 和 参考式 。\n行内式的图片语法看起来像是：\n![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg \"Optional title\") 详细叙述如下：\n一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。 参考式的图片语法则长得像这样：\n![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n[id]: url/to/image \"Optional title attribute\" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 \u003cimg\u003e 标签。\n其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n​ http://example.com/\nMarkdown 会转为：\n​ http://example.com/\n邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：\n​ address@example.com\nMarkdown 会转成：\n​ address@exa ​ mple.com\n在浏览器里面，这段字串（其实是 \u003ca href=\"mailto:address@example.com\"\u003eaddress@example.com\u003c/a\u003e）会变成一个可以点击的「address@example.com」链接。\n（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）\n反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 \u003cem\u003e 标签），你可以在星号的前面加上反斜杠：\n​ *literal asterisks*\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n​ \\ 反斜线 ​ ` 反引号 ​ * 星号 ​ _ 底线 ​ {} 花括号 ​ [] 方括号 ​ () 括弧 ​ # 井字号 ​ + 加号 ​ - 减号 ​ . 英文句点 ​ ! 惊叹号\n转载之wowubuntu\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"Markdown 语法","uri":"/2018/03/14/cnblog_8565323/"},{"categories":["笔记","博客园"],"content":"这是👉jQuery👈的摘要 jQuery jQuery介绍 jQuery是一个轻量级的、兼容多浏览器的JavaScript库。 jQuery使用户能够更方便地处理HTML Document、Events、实现动画效果、方便地进行Ajax交互，能够极大地简化JavaScript编程。它的宗旨就是：\"Write less, do more.\" jQuery的优势 一款轻量级的JS框架。jQuery核心js文件才几十kb，不会影响页面加载速度。 丰富的DOM选择器,jQuery的选择器用起来很方便，比如要找到某个DOM对象的相邻元素，JS可能要写好几行代码，而jQuery一行代码就搞定了，再比如要将一个表格的隔行变色，jQuery也是一行代码搞定。 链式表达式。jQuery的链式操作可以把多个操作写在一行代码里，更加简洁。 事件、样式、动画支持。jQuery还简化了js操作css的代码，并且代码的可读性也比js要强。 Ajax操作支持。jQuery简化了AJAX操作，后端只需返回一个JSON格式的字符串就能完成与前端的通信。 跨浏览器兼容。jQuery基本兼容了现在主流的浏览器，不用再为浏览器的兼容问题而伤透脑筋。 插件扩展开发。jQuery有着丰富的第三方的插件，例如：树形菜单、日期控件、图片切换插件、弹出窗口等等基本前端页面上的组件都有对应插件，并且用jQuery插件做出来的效果很炫，并且可以根据自己需要去改写和封装插件，简单实用。 jQuery内容： 选择器 筛选器 样式操作 文本操作 属性操作 文档处理 事件 动画效果 插件 each、data、Ajax 下载链接：jQuery官网\njQuery版本 1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日) 2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日) 3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本。 维护IE678是一件让人头疼的事情，一般我们都会额外加载一个CSS和JS单独处理。值得庆幸的是使用这些浏览器的人也逐步减少，PC端用户已经逐步被移动端用户所取代，如果没有特殊要求的话，一般都会选择放弃对678的支持。\njQuery对象 jQuery对象 就是通过jQuery包装DOM对象后产生的对象。 jQuery对象 是 jQuery独有的。如果一个对象是 jQuery对象 ，那么它就可以使用 jQuery 里的方法：例如$(\"#i1\").html()。\n$(\"#i1\").html()的意思是：获取id值为 i1的元素的html代码。其中 html()是jQuery里的方法。\n相当于： document.getElementById(\"i1\").innerHTML;\n虽然 jQuery对象是包装 DOM对象后产生的，但是 jQuery对象无法使用 DOM对象的任何方法，同理 DOM对象也没不能使用 jQuery里的方法。\n一个约定，我们在声明一个jQuery对象变量的时候在变量名前面加上$：\nvar $variable = jQuery对像 var variable = DOM对象 $variable[0]//jQuery对象转成DOM对象 拿上面那个例子举例，jQuery对象和DOM对象的使用：\n$(\"#i1\").html();//jQuery对象可以使用jQuery的方法 $(\"#i1\")[0].innerHTML;// DOM对象使用DOM的方法 jQuery基础语法 $(selector).action()\n查找标签 选择器 id选择器：\n$(\"#id\") 标签选择器：\n$(\"tagName\") class选择器：\n$(\".className\") 配合使用：\n$(\"div.c1\") // 找到有c1 class类的div标签 所有元素选择器：\n$(\"*\") 组合选择器：\n$(\"#id, .className, tagName\") 层级选择器：\nx和y可以为任意选择器\n$(\"x y\"); // x的所有后代y（子子孙孙） $(\"x \u003e y\");// x的所有儿子y（儿子） $(\"x + y\")// 找到所有紧挨在x后面的y $(\"x ~ y\")// x之后所有的兄弟y 基本筛选器：\n:first // 第一个 :last // 最后一个 :eq(index)// 索引等于index的那个元素 :even // 匹配所有索引值为偶数的元素，从 0 开始计数 :odd // 匹配所有索引值为奇数的元素，从 0 开始计数 :gt(index)// 匹配所有大于给定索引值的元素 :lt(index)// 匹配所有小于给定索引值的元素 :not(元素选择器)// 移除所有满足not条件的标签 :has(元素选择器)// 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找) 例子：\n$(\"div:has(h1)\") // 找到所有后代中有h1标签的div标签 $(\"div:has(.c1)\")// 找到所有后代中有c1样式类的div标签 $(\"li:not(.c1)\")// 找到所有不包含c1样式类的li标签 $(\"li:not(:has(a))\")// 找到所有后代中不含a标签的li标签 练习：\n自定义模态框，使用jQuery实现弹出和隐藏功能。\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e自定义模态框\u003c/title\u003e \u003cstyle\u003e .cover { position: fixed; left: 0; right: 0; top: 0; bottom: 0; background-color: darkgrey; z-index: 999; } .modal { width: 600px; height: 400px; background-color: white; position: fixed; left: 50%; top: 50%; margin-left: -300px; margin-top: -200px; z-index: 1000; } .hide { display: none; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"弹\" id=\"i0\"\u003e \u003cdiv class=\"cover hide\"\u003e\u003c/div\u003e \u003cdiv class=\"modal hide\"\u003e \u003clabel for=\"i1\"\u003e姓名\u003c/label\u003e \u003cinput id=\"i1\" type=\"text\"\u003e \u003clabel for=\"i2\"\u003e爱好\u003c/label\u003e \u003cinput id=\"i2\" type=\"text\"\u003e \u003cinput type=\"button\" id=\"i3\" value=\"关闭\"\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var tButton = $(\"#i0\")[0]; tButton.onclick=function () { var coverEle = $(\".cover\")[0]; var modalEle = $(\".modal\")[0]; $(coverEle).removeClass(\"hide\"); $(modalEle).removeClass(\"hide\"); }; var cButton = $(\"#i3\")[0]; cButton.onclick=function () { var coverEle = $(\".cover\")[0]; var modalEle = $(\".modal\")[0]; $(coverEle).addClass(\"hide\"); $(modalEle).addClass(\"hide\"); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e jQuery版自定义模态框\n属性选择器：\n[attribute] [attribute=value]// 属性等于 [attribute!=value]// 属性不等于 例子：\n// 示例 \u003cinput type=\"text\"\u003e \u003cinput type=\"password\"\u003e \u003cinput type=\"checkbox\"\u003e $(\"input[type='checkbox']\");// 取到checkbox类型的input标签 $(\"input[type!='text']\");// 取到类型不是text的input标签 表单常用筛选 ：\n:text :password :file :radio :checkbox :submit :reset :button 例子：\n$(\":checkbox\") // 找到所有的checkbox 表单对象属性:\n:enabled :disabled :checked :selected 例子：\n\u003cform\u003e \u003cinput name=\"email\" disabled=\"disabled\" /\u003e \u003cinput name=\"id\" /\u003e \u003c/form\u003e $( \"input:enabled\") // 找到可用的input标签 \u003cselect id=\"s1\"\u003e \u003coption value=\"beijing\"\u003e北京市\u003c/option\u003e \u003coption value=\"shanghai\"\u003e上海市\u003c/option\u003e \u003coption selected value=\"guangzhou\"\u003e广州市\u003c/option\u003e \u003coption value=\"shenzhen\"\u003e深圳市\u003c/option\u003e \u003c/select\u003e $(\":selected\") // 找到所有被选中的option 筛选器 下一个元素：\n$(\"#id\").next() $(\"#id\").nextAll() $(\"#id\").nextUntil(\"#i2\") 上一个元素：\n$(\"#id\").prev() $(\"#id\").prevAll() $(\"#id\").prevUntil(\"#i2\") 父亲元素：\n$(\"#id\").parent() $(\"#id\").parents() // 查找当前元素的所有的父辈元素 $(\"#id\").parentsUntil() // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。 儿子和兄弟元素：\n$(\"#id\").children();// 儿子们 $(\"#id\").siblings();// 兄弟们 查找元素：\n$(\"#id\").find()// 搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。 补充：\n.first()// 获取匹配的第一个元素 .last()// 获取匹配的最后一个元素 .not()// 从匹配元素的集合中删除与指定表达式匹配的元素 .has()// 保留包含特定后代的元素，去掉那些不含有指定后代的元素。 示例：左侧菜单\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e左侧菜单示例\u003c/title\u003e \u003cstyle\u003e .left { position: fixed; left: 0; top: 0; width: 20%; height: 100%; background-color: rgb(47, 53, 61); } .right { width: 80%; height: 100%; } .menu { color: white; } .title { text-align: center; padding: 10px 15px; border-bottom: 1px solid #23282e; } .items { background-color: #181c20; } .item { padding: 5px 10px; border-bottom: 1px solid #23282e; } .hide { display: none; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"left\"\u003e \u003cdiv class=\"menu\"\u003e \u003cdiv class=\"title\"\u003e菜单一\u003c/div\u003e \u003cdiv class=\"items\"\u003e \u003cdiv class=\"item\"\u003e111\u003c/div\u003e \u003cdiv class=\"item\"\u003e222\u003c/div\u003e \u003cdiv class=\"item\"\u003e333\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"title\"\u003e菜单二\u003c/div\u003e \u003cdiv class=\"items hide\"\u003e \u003cdiv class=\"item\"\u003e111\u003c/div\u003e \u003cdiv class=\"item\"\u003e222\u003c/div\u003e \u003cdiv class=\"item\"\u003e333\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"title\"\u003e菜单三\u003c/div\u003e \u003cdiv class=\"items hide\"\u003e \u003cdiv class=\"item\"\u003e111\u003c/div\u003e \u003cdiv class=\"item\"\u003e222\u003c/div\u003e \u003cdiv class=\"item\"\u003e333\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"right\"\u003e\u003c/div\u003e \u003cscript src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(\".title\").click(function (){ // jQuery绑定事件 // 隐藏所有class里有.items的标签 $(\".items\").addClass(\"hide\"); //批量操作 $(this).next().removeClass(\"hide\"); }); \u003c/script\u003e 左侧菜单示例\n操作标签 样式操作 样式类\naddClass();// 添加指定的CSS类名。 removeClass();// 移除指定的CSS类名。 hasClass();// 判断样式存不存在 toggleClass();// 切换CSS类名，如果有就移除，如果没有就添加。 示例：开关灯和模态框\nCSS\ncss(\"color\",\"red\")//DOM操作：tag.style.color=\"red\" 示例：\n$(\"p\").css(\"color\", \"red\"); //将所有p标签的字体设置为红色 位置：\noffset()// 获取匹配元素在当前窗口的相对偏移或设置元素位置 position()// 获取匹配元素相对父元素的偏移 scrollTop()// 获取匹配元素相对滚动条顶部的偏移 scrollLeft()// 获取匹配元素相对滚动条左侧的偏移 .offset()方法允许我们检索一个元素相对于文档（document）的当前位置。\n和 .position()的差别在于： .position()是相对于相对于父级元素的位移。\n示例：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e位置相关示例之返回顶部\u003c/title\u003e \u003cstyle\u003e .c1 { width: 100px; height: 200px; background-color: red; } .c2 { height: 50px; width: 50px; position: fixed; bottom: 15px; right: 15px; background-color: #2b669a; } .hide { display: none; } .c3 { height: 100px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"b1\" class=\"btn btn-default\"\u003e点我\u003c/button\u003e \u003cdiv class=\"c1\"\u003e\u003c/div\u003e \u003cdiv class=\"c3\"\u003e1\u003c/div\u003e \u003cdiv class=\"c3\"\u003e2\u003c/div\u003e \u003cdiv class=\"c3\"\u003e3\u003c/div\u003e \u003cdiv class=\"c3\"\u003e4\u003c/div\u003e \u003cdiv class=\"c3\"\u003e5\u003c/div\u003e \u003cdiv class=\"c3\"\u003e6\u003c/div\u003e \u003cdiv class=\"c3\"\u003e7\u003c/div\u003e \u003cdiv class=\"c3\"\u003e8\u003c/div\u003e \u003cdiv class=\"c3\"\u003e9\u003c/div\u003e \u003cdiv class=\"c3\"\u003e10\u003c/div\u003e \u003cdiv class=\"c3\"\u003e11\u003c/div\u003e \u003cdiv class=\"c3\"\u003e12\u003c/div\u003e \u003cdiv class=\"c3\"\u003e13\u003c/div\u003e \u003cdiv class=\"c3\"\u003e14\u003c/div\u003e \u003cdiv class=\"c3\"\u003e15\u003c/div\u003e \u003cdiv class=\"c3\"\u003e16\u003c/div\u003e \u003cdiv class=\"c3\"\u003e17\u003c/div\u003e \u003cdiv class=\"c3\"\u003e18\u003c/div\u003e \u003cdiv class=\"c3\"\u003e19\u003c/div\u003e \u003cdiv class=\"c3\"\u003e20\u003c/div\u003e \u003cdiv class=\"c3\"\u003e21\u003c/div\u003e \u003cdiv class=\"c3\"\u003e22\u003c/div\u003e \u003cdiv class=\"c3\"\u003e23\u003c/div\u003e \u003cdiv class=\"c3\"\u003e24\u003c/div\u003e \u003cdiv class=\"c3\"\u003e25\u003c/div\u003e \u003cdiv class=\"c3\"\u003e26\u003c/div\u003e \u003cdiv class=\"c3\"\u003e27\u003c/div\u003e \u003cdiv class=\"c3\"\u003e28\u003c/div\u003e \u003cdiv class=\"c3\"\u003e29\u003c/div\u003e \u003cdiv class=\"c3\"\u003e30\u003c/div\u003e \u003cdiv class=\"c3\"\u003e31\u003c/div\u003e \u003cdiv class=\"c3\"\u003e32\u003c/div\u003e \u003cdiv class=\"c3\"\u003e33\u003c/div\u003e \u003cdiv class=\"c3\"\u003e34\u003c/div\u003e \u003cdiv class=\"c3\"\u003e35\u003c/div\u003e \u003cdiv class=\"c3\"\u003e36\u003c/div\u003e \u003cdiv class=\"c3\"\u003e37\u003c/div\u003e \u003cdiv class=\"c3\"\u003e38\u003c/div\u003e \u003cdiv class=\"c3\"\u003e39\u003c/div\u003e \u003cdiv class=\"c3\"\u003e40\u003c/div\u003e \u003cdiv class=\"c3\"\u003e41\u003c/div\u003e \u003cdiv class=\"c3\"\u003e42\u003c/div\u003e \u003cdiv class=\"c3\"\u003e43\u003c/div\u003e \u003cdiv class=\"c3\"\u003e44\u003c/div\u003e \u003cdiv class=\"c3\"\u003e45\u003c/div\u003e \u003cdiv class=\"c3\"\u003e46\u003c/div\u003e \u003cdiv class=\"c3\"\u003e47\u003c/div\u003e \u003cdiv class=\"c3\"\u003e48\u003c/div\u003e \u003cdiv class=\"c3\"\u003e49\u003c/div\u003e \u003cdiv class=\"c3\"\u003e50\u003c/div\u003e \u003cdiv class=\"c3\"\u003e51\u003c/div\u003e \u003cdiv class=\"c3\"\u003e52\u003c/div\u003e \u003cdiv class=\"c3\"\u003e53\u003c/div\u003e \u003cdiv class=\"c3\"\u003e54\u003c/div\u003e \u003cdiv class=\"c3\"\u003e55\u003c/div\u003e \u003cdiv class=\"c3\"\u003e56\u003c/div\u003e \u003cdiv class=\"c3\"\u003e57\u003c/div\u003e \u003cdiv class=\"c3\"\u003e58\u003c/div\u003e \u003cdiv class=\"c3\"\u003e59\u003c/div\u003e \u003cdiv class=\"c3\"\u003e60\u003c/div\u003e \u003cdiv class=\"c3\"\u003e61\u003c/div\u003e \u003cdiv class=\"c3\"\u003e62\u003c/div\u003e \u003cdiv class=\"c3\"\u003e63\u003c/div\u003e \u003cdiv class=\"c3\"\u003e64\u003c/div\u003e \u003cdiv class=\"c3\"\u003e65\u003c/div\u003e \u003cdiv class=\"c3\"\u003e66\u003c/div\u003e \u003cdiv class=\"c3\"\u003e67\u003c/div\u003e \u003cdiv class=\"c3\"\u003e68\u003c/div\u003e \u003cdiv class=\"c3\"\u003e69\u003c/div\u003e \u003cdiv class=\"c3\"\u003e70\u003c/div\u003e \u003cdiv class=\"c3\"\u003e71\u003c/div\u003e \u003cdiv class=\"c3\"\u003e72\u003c/div\u003e \u003cdiv class=\"c3\"\u003e73\u003c/div\u003e \u003cdiv class=\"c3\"\u003e74\u003c/div\u003e \u003cdiv class=\"c3\"\u003e75\u003c/div\u003e \u003cdiv class=\"c3\"\u003e76\u003c/div\u003e \u003cdiv class=\"c3\"\u003e77\u003c/div\u003e \u003cdiv class=\"c3\"\u003e78\u003c/div\u003e \u003cdiv class=\"c3\"\u003e79\u003c/div\u003e \u003cdiv class=\"c3\"\u003e80\u003c/div\u003e \u003cdiv class=\"c3\"\u003e81\u003c/div\u003e \u003cdiv class=\"c3\"\u003e82\u003c/div\u003e \u003cdiv class=\"c3\"\u003e83\u003c/div\u003e \u003cdiv class=\"c3\"\u003e84\u003c/div\u003e \u003cdiv class=\"c3\"\u003e85\u003c/div\u003e \u003cdiv class=\"c3\"\u003e86\u003c/div\u003e \u003cdiv class=\"c3\"\u003e87\u003c/div\u003e \u003cdiv class=\"c3\"\u003e88\u003c/div\u003e \u003cdiv class=\"c3\"\u003e89\u003c/div\u003e \u003cdiv class=\"c3\"\u003e90\u003c/div\u003e \u003cdiv class=\"c3\"\u003e91\u003c/div\u003e \u003cdiv class=\"c3\"\u003e92\u003c/div\u003e \u003cdiv class=\"c3\"\u003e93\u003c/div\u003e \u003cdiv class=\"c3\"\u003e94\u003c/div\u003e \u003cdiv class=\"c3\"\u003e95\u003c/div\u003e \u003cdiv class=\"c3\"\u003e96\u003c/div\u003e \u003cdiv class=\"c3\"\u003e97\u003c/div\u003e \u003cdiv class=\"c3\"\u003e98\u003c/div\u003e \u003cdiv class=\"c3\"\u003e99\u003c/div\u003e \u003cdiv class=\"c3\"\u003e100\u003c/div\u003e \u003cbutton id=\"b2\" class=\"btn btn-default c2 hide\"\u003e返回顶部\u003c/button\u003e \u003cscript src=\"jquery-3.2.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(\"#b1\").on(\"click\", function () { $(\".c1\").offset({left: 200, top:200}); }); $(window).scroll(function () { if ($(window).scrollTop() \u003e 100) { $(\"#b2\").removeClass(\"hide\"); }else { $(\"#b2\").addClass(\"hide\"); } }); $(\"#b2\").on(\"click\", function () { $(window).scrollTop(0); }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 返回顶部示例\n尺寸：\nheight() width() innerHeight() innerWidth() outerHeight() outerWidth() 文本操作 HTML代码：\nhtml()// 取得第一个匹配元素的html内容 html(val)// 设置所有匹配元素的html内容 文本值：\ntext()// 取得所有匹配元素的内容 text(val)// 设置所有匹配元素的内容 值：\nval()// 取得第一个匹配元素的当前值 val(val)// 设置所有匹配元素的值 val([val1, val2])// 设置checkbox、select的值 示例：\n获取被选中的checkbox或radio的值：\n\u003clabel for=\"c1\"\u003e女\u003c/label\u003e \u003cinput name=\"gender\" id=\"c1\" type=\"radio\" value=\"0\"\u003e \u003clabel for=\"c2\"\u003e男\u003c/label\u003e \u003cinput name=\"gender\" id=\"c2\" type=\"radio\" value=\"1\"\u003e 可以使用：\n$(\"input[name='gender']:checked\").val() \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003ejQuery val示例\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003clabel for=\"s1\"\u003e城市\u003c/label\u003e \u003cselect id=\"s1\"\u003e \u003coption value=\"beijing\"\u003e北京市\u003c/option\u003e \u003coption value=\"shanghai\"\u003e上海市\u003c/option\u003e \u003coption selected value=\"guangzhou\"\u003e广州市\u003c/option\u003e \u003coption value=\"shenzhen\"\u003e深圳市\u003c/option\u003e \u003c/select\u003e \u003chr\u003e \u003clabel for=\"s2\"\u003e爱好\u003c/label\u003e \u003cselect id=\"s2\" multiple=\"multiple\"\u003e \u003coption value=\"basketball\" selected\u003e篮球\u003c/option\u003e \u003coption value=\"football\"\u003e足球\u003c/option\u003e \u003coption value=\"doublecolorball\" selected\u003e双色球\u003c/option\u003e \u003c/select\u003e \u003cscript src=\"jquery-3.2.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e // 单选下拉框 $(\"#s1\").val(\"shanghai\"); // 多选下拉框 $(\"#s2\").val([\"basketball\", \"football\"]); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e jQuery val赋值示例\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e文本操作之登录验证\u003c/title\u003e \u003cstyle\u003e .error { color: red; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"\"\u003e \u003cdiv\u003e \u003clabel for=\"input-name\"\u003e用户名\u003c/label\u003e \u003cinput type=\"text\" id=\"input-name\" name=\"name\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"input-password\"\u003e密码\u003c/label\u003e \u003cinput type=\"password\" id=\"input-password\" name=\"password\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003cinput type=\"button\" id=\"btn\" value=\"提交\"\u003e \u003c/div\u003e \u003c/form\u003e \u003cscript src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(\"#btn\").click(function () { var username = $(\"#input-name\").val(); var password = $(\"#input-password\").val(); if (username.length === 0) { $(\"#input-name\").siblings(\".error\").text(\"用户名不能为空\"); } if (password.length === 0) { $(\"#input-password\").siblings(\".error\").text(\"密码不能为空\"); } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 自定义登录校验示例\n属性操作 用于ID等或自定义属性：\nattr(attrName)// 返回第一个匹配元素的属性值 attr(attrName, attrValue)// 为所有匹配元素设置一个属性值 attr({k1: v1, k2:v2})// 为所有匹配元素设置多个属性值 removeAttr()// 从每一个匹配的元素中删除一个属性 用于checkbox和radio\nprop() // 获取属性 removeProp() // 移除属性 注意：\n在1.x及2.x版本的jQuery中使用attr对checkbox进行复制操作时会出bug，在3.x版本的jQuery中则没有这个问题。为了兼容性，我们在处理checkbox和radio的时候尽量使用特定的prop()，不要使用attr(\"checked\", \"checked\")。\n\u003cinput type=\"checkbox\" value=\"1\"\u003e \u003cinput type=\"radio\" value=\"2\"\u003e \u003cscript\u003e $(\":checkbox[value='1']\").prop(\"checked\", true); $(\":radio[value='2']\").prop(\"checked\", true); \u003c/script\u003e 示例：全选、反选、取消\n文档处理 添加到指定元素 内部 的后面\n$(A).append(B)// 把B追加到A $(A).appendTo(B)// 把A追加到B 添加到指定元素 内部 的前面\n$(A).prepend(B)// 把B前置到A $(A).prependTo(B)// 把A前置到B 添加到指定元素 外部 的后面\n$(A).after(B)// 把B放到A的后面 $(A).insertAfter(B)// 把A放到B的后面 添加到指定元素 外部 的前面\n$(A).before(B)// 把B放到A的前面 $(A).insertBefore(B)// 把A放到B的前面 移除和清空元素\nremove()// 从DOM中删除所有匹配的元素。 empty()// 删除匹配的元素集合中所有的子节点。 例子：\n点击按钮在表格添加一行数据。\n点击每一行的删除按钮删除当前行数据。\n替换\nreplaceWith() replaceAll() 克隆\nclone()// 参数 克隆示例：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e克隆\u003c/title\u003e \u003cstyle\u003e #b1 { background-color: deeppink; padding: 5px; color: white; margin: 5px; } #b2 { background-color: dodgerblue; padding: 5px; color: white; margin: 5px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"b1\"\u003e屠龙宝刀，点击就送\u003c/button\u003e \u003chr\u003e \u003cbutton id=\"b2\"\u003e屠龙宝刀，点击就送\u003c/button\u003e \u003cscript src=\"jquery-3.2.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e // clone方法不加参数true，克隆标签但不克隆标签带的事件 $(\"#b1\").on(\"click\", function () { $(this).clone().insertAfter(this); }); // clone方法加参数true，克隆标签并且克隆标签带的事件 $(\"#b2\").on(\"click\", function () { $(this).clone(true).insertAfter(this); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 点击复制按钮\n事件 常用事件 click(function(){...}) hover(function(){...}) blur(function(){...}) focus(function(){...}) change(function(){...}) keyup(function(){...}) keydown和keyup事件组合示例：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e键盘事件示例\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ctable border=\"1\"\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e#\u003c/th\u003e \u003cth\u003e姓名\u003c/th\u003e \u003cth\u003e操作\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e\u003cinput type=\"checkbox\"\u003e\u003c/td\u003e \u003ctd\u003eEgon\u003c/td\u003e \u003ctd\u003e \u003cselect\u003e \u003coption value=\"1\"\u003e上线\u003c/option\u003e \u003coption value=\"2\"\u003e下线\u003c/option\u003e \u003coption value=\"3\"\u003e停职\u003c/option\u003e \u003c/select\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cinput type=\"checkbox\"\u003e\u003c/td\u003e \u003ctd\u003eAlex\u003c/td\u003e \u003ctd\u003e \u003cselect\u003e \u003coption value=\"1\"\u003e上线\u003c/option\u003e \u003coption value=\"2\"\u003e下线\u003c/option\u003e \u003coption value=\"3\"\u003e停职\u003c/option\u003e \u003c/select\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cinput type=\"checkbox\"\u003e\u003c/td\u003e \u003ctd\u003eYuan\u003c/td\u003e \u003ctd\u003e \u003cselect\u003e \u003coption value=\"1\"\u003e上线\u003c/option\u003e \u003coption value=\"2\"\u003e下线\u003c/option\u003e \u003coption value=\"3\"\u003e停职\u003c/option\u003e \u003c/select\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cinput type=\"checkbox\"\u003e\u003c/td\u003e \u003ctd\u003eEvaJ\u003c/td\u003e \u003ctd\u003e \u003cselect\u003e \u003coption value=\"1\"\u003e上线\u003c/option\u003e \u003coption value=\"2\"\u003e下线\u003c/option\u003e \u003coption value=\"3\"\u003e停职\u003c/option\u003e \u003c/select\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cinput type=\"checkbox\"\u003e\u003c/td\u003e \u003ctd\u003eGold\u003c/td\u003e \u003ctd\u003e \u003cselect\u003e \u003coption value=\"1\"\u003e上线\u003c/option\u003e \u003coption value=\"2\"\u003e下线\u003c/option\u003e \u003coption value=\"3\"\u003e停职\u003c/option\u003e \u003c/select\u003e \u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003cinput type=\"button\" id=\"b1\" value=\"全选\"\u003e \u003cinput type=\"button\" id=\"b2\" value=\"取消\"\u003e \u003cinput type=\"button\" id=\"b3\" value=\"反选\"\u003e \u003cscript src=\"jquery-3.2.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e // 全选 $(\"#b1\").on(\"click\", function () { $(\":checkbox\").prop(\"checked\", true); }); // 取消 $(\"#b2\").on(\"click\", function () { $(\":checkbox\").prop(\"checked\", false); }); // 反选 $(\"#b3\").on(\"click\", function () { $(\":checkbox\").each(function () { var flag = $(this).prop(\"checked\"); $(this).prop(\"checked\", !flag); }) }); // 按住shift键，批量操作 // 定义全局变量 var flag = false; // 全局事件，监听键盘shift按键是否被按下 $(window).on(\"keydown\", function (e) { // alert(e.keyCode); if (e.keyCode === 16){ flag = true; } }); // 全局事件,shift按键抬起时将全局变量置为false $(window).on(\"keyup\", function (e) { if (e.keyCode === 16){ flag = false; } }); // select绑定change事件 $(\"table select\").on(\"change\", function () { // 是否为批量操作模式 if (flag) { var selectValue = $(this).val(); // 找到所有被选中的那一行的select，选中指定值 $(\"input:checked\").parent().parent().find(\"select\").val(selectValue); } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 按住shift键批量操作\n实时监听input输入值变化示例：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e实时监听input输入值变化\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"text\" id=\"i1\"\u003e \u003cscript src=\"jquery-3.2.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e /* * oninput是HTML5的标准事件 * 能够检测textarea,input:text,input:password和input:search这几个元素的内容变化， * 在内容修改后立即被触发，不像onchange事件需要失去焦点才触发 * oninput事件在IE9以下版本不支持，需要使用IE特有的onpropertychange事件替代 * 使用jQuery库的话直接使用on同时绑定这两个事件即可。 * */ $(\"#i1\").on(\"input propertychange\", function () { alert($(this).val()); }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e input值变化事件\n事件绑定 .on( events [, selector ],function(){}) events： 事件 selector: 选择器（可选的） function: 事件处理函数 移除事件 .off( events [, selector ][,function(){}]) off() 方法移除用 .on()绑定的事件处理程序。\nevents： 事件 selector: 选择器（可选的） function: 事件处理函数 阻止后续事件执行 return false; // 常见阻止表单提交等 注意：\n像click、keydown等DOM中定义的事件，我们都可以使用.on()方法来绑定事件，但是hover这种jQuery中定义的事件就不能用.on()方法来绑定了。\n想使用事件委托的方式绑定hover事件处理函数，可以参照如下代码分两步绑定事件：\n$('ul').on('mouseenter', 'li', function() {//绑定鼠标进入事件 $(this).addClass('hover'); }); $('ul').on('mouseleave', 'li', function() {//绑定鼠标划出事件 $(this).removeClass('hover'); }); 页面载入 当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。\n两种写法：\n$(document).ready(function(){ // 在这里写你的JS代码... }) 简写：\n$(function(){ // 你在这里写你的代码 }) 文档加载完绑定事件，并且阻止默认事件发生：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e登录注册示例\u003c/title\u003e \u003cstyle\u003e .error { color: red; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cform id=\"myForm\"\u003e \u003clabel for=\"name\"\u003e姓名\u003c/label\u003e \u003cinput type=\"text\" id=\"name\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003clabel for=\"passwd\"\u003e密码\u003c/label\u003e \u003cinput type=\"password\" id=\"passwd\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003cinput type=\"submit\" id=\"modal-submit\" value=\"登录\"\u003e \u003c/form\u003e \u003cscript src=\"jquery-3.2.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"s7validate.js\"\u003e\u003c/script\u003e \u003cscript\u003e function myValidation() { // 多次用到的jQuery对象存储到一个变量，避免重复查询文档树 var $myForm = $(\"#myForm\"); $myForm.find(\":submit\").on(\"click\", function () { // 定义一个标志位，记录表单填写是否正常 var flag = true; $myForm.find(\":text, :password\").each(function () { var val = $(this).val(); if (val.length \u003c= 0 ){ var labelName = $(this).prev(\"label\").text(); $(this).next(\"span\").text(labelName + \"不能为空\"); flag = false; } }); // 表单填写有误就会返回false，阻止submit按钮默认的提交表单事件 return flag; }); // input输入框获取焦点后移除之前的错误提示信息 $myForm.find(\"input[type!='submit']\").on(\"focus\", function () { $(this).next(\".error\").text(\"\"); }) } // 文档树就绪后执行 $(document).ready(function () { myValidation(); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 登录校验示例\n事件委托 事件委托是通过事件冒泡的原理，利用父标签去捕获子标签的事件。\n示例：\n表格中每一行的编辑和删除按钮都能触发相应的事件。\n$(\"table\").on(\"click\", \".delete\", function () { // 删除按钮绑定的事件 }) 动画效果 // 基本 show([s,[e],[fn]]) hide([s,[e],[fn]]) toggle([s],[e],[fn]) // 滑动 slideDown([s],[e],[fn]) slideUp([s,[e],[fn]]) slideToggle([s],[e],[fn]) // 淡入淡出 fadeIn([s],[e],[fn]) fadeOut([s],[e],[fn]) fadeTo([[s],o,[e],[fn]]) fadeToggle([s,[e],[fn]]) // 自定义（了解即可） animate(p,[s],[e],[fn]) 自定义动画示例：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e点赞动画示例\u003c/title\u003e \u003cstyle\u003e div { position: relative; display: inline-block; } div\u003ei { display: inline-block; color: red; position: absolute; right: -16px; top: -5px; opacity: 1; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"d1\"\u003e点赞\u003c/div\u003e \u003cscript src=\"jquery-3.2.1.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e $(\"#d1\").on(\"click\", function () { var newI = document.createElement(\"i\"); newI.innerText = \"+1\"; $(this).append(newI); $(this).children(\"i\").animate({ opacity: 0 }, 1000) }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 点赞特效简单示例\n补充 each jQuery.each(collection, callback(indexInArray, valueOfElement))：\n描述：一个通用的迭代函数，它可以用来无缝迭代对象和数组。数组和类似数组的对象通过一个长度属性（如一个函数的参数对象）来迭代数字索引，从0到length - 1。其他对象通过其属性名进行迭代。\nli =[10,20,30,40] $.each(li,function(i, v){ console.log(i, v);//index是索引，ele是每次循环的具体元素。 }) 输出：\n010 120 230 340 .each(function(index, Element))：\n描述：遍历一个jQuery对象，为每个匹配元素执行一个函数。\n.each() 方法用来迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。由于回调函数是在当前DOM元素为上下文的语境中触发的，所以关键字 this 总是指向这个元素。\n// 为每一个li标签添加foo $(\"li\").each(function(){ $(this).addClass(\"c1\"); }); 注意: jQuery的方法返回一个jQuery对象，遍历jQuery集合中的元素 - 被称为隐式 迭代 的过程。当这种情况发生时，它通常不需要显式地循环的 .each()方法：\n也就是说，上面的例子没有必要使用each()方法，直接像下面这样写就可以了：\n$(\"li\").addClass(\"c1\"); // 对所有标签做统一操作 注意：\n在遍历过程中可以使用 return false提前结束each循环。\n终止each循环\nreturn false； 伏笔...\n.data() 在匹配的元素集合中的所有元素上存储任意相关数据或返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。\n.data(key, value):\n描述：在匹配的元素上存储任意相关数据。\n$(\"div\").data(\"k\",100);//给所有div标签都保存一个名为k，值为100 .data(key):\n描述: 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值--通过 .data(name, value)或 HTML5 data-*属性设置。\n$(\"div\").data(\"k\");//返回第一个div标签中保存的\"k\"的值 .removeData(key):\n描述：移除存放在元素上的数据，不加key参数表示移除所有保存的数据。\n$(\"div\").removeData(\"k\"); //移除元素上存放k对应的数据 示例：\n模态框编辑的数据回填表格\n插件(了解即可) jQuery.extend(object)\njQuery的命名空间下添加新的功能。多用于插件开发者向 jQuery 中添加新函数时使用。\n示例：\n\u003cscript\u003e jQuery.extend({ min:function(a, b){return a \u003c b ? a : b;}, max:function(a, b){return a \u003e b ? a : b;} }); jQuery.min(2,3);// =\u003e 2 jQuery.max(4,5);// =\u003e 5 \u003c/script\u003e jQuery.fn.extend(object)\n一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。\n\u003cscript\u003e jQuery.fn.extend({ check:function(){ return this.each(function(){this.checked =true;}); }, uncheck:function(){ return this.each(function(){this.checked =false;}); } }); // jQuery对象可以使用新添加的check()方法了。 $(\"input[type='checkbox']\").check(); \u003c/script\u003e 单独写在文件中的扩展：\n(function(jq){ jq.extend({ funcName:function(){ ... }, }); })(jQuery); 例子：\n自定义的jQuery登录验证插件\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e登录校验示例\u003c/title\u003e \u003cstyle\u003e .login-form { margin: 100px auto 0; max-width: 330px; } .login-form \u003e div { margin: 15px 0; } .error { color: red; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e \u003cform action=\"\" class=\"login-form\" novalidate\u003e \u003cdiv\u003e \u003clabel for=\"username\"\u003e姓名\u003c/label\u003e \u003cinput id=\"username\" type=\"text\" name=\"name\" required autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"passwd\"\u003e密码\u003c/label\u003e \u003cinput id=\"passwd\" type=\"password\" name=\"password\" required autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"mobile\"\u003e手机\u003c/label\u003e \u003cinput id=\"mobile\" type=\"text\" name=\"mobile\" required autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"where\"\u003e来自\u003c/label\u003e \u003cinput id=\"where\" type=\"text\" name=\"where\" autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003cinput type=\"submit\" value=\"登录\"\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"validate.js\"\u003e\u003c/script\u003e \u003cscript\u003e $.validate(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e HTML文件\n\"use strict\"; (function ($) { function check() { // 定义一个标志位，表示验证通过还是验证不通过 var flag = true; var errMsg; // 校验规则 $(\"form input[type!=':submit']\").each(function () { var labelName = $(this).prev().text(); var inputName = $(this).attr(\"name\"); var inputValue = $(this).val(); if ($(this).attr(\"required\")) { // 如果是必填项 if (inputValue.length === 0) { // 值为空 errMsg = labelName + \"不能为空\"; $(this).next().text(errMsg); flag = false; return false; } // 如果是密码类型，我们就要判断密码的长度是否大于6位 if (inputName === \"password\") { // 除了上面判断为不为空还要判断密码长度是否大于6位 if (inputValue.length \u003c 6) { errMsg = labelName + \"必须大于6位\"; $(this).next().text(errMsg); flag = false; return false; } } // 如果是手机类型，我们需要判断手机的格式是否正确 if (inputName === \"mobile\") { // 使用正则表达式校验inputValue是否为正确的手机号码 if (!/^1[345678]\\d{9}$/.test(inputValue)) { // 不是有效的手机号码格式 errMsg = labelName + \"格式不正确\"; $(this).next().text(errMsg); flag = false; return false; } } } }); return flag; } function clearError(arg) { // 清空之前的错误提示 $(arg).next().text(\"\"); } // 上面都是我定义的工具函数 $.extend({ validate: function () { $(\"form :submit\").on(\"click\", function () { return check(); }); $(\"form :input[type!='submit']\").on(\"focus\", function () { clearError(this); }); } }); })(jQuery); JS文件\n传参版插件：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e登录校验示例\u003c/title\u003e \u003cstyle\u003e .login-form { margin: 100px auto 0; max-width: 330px; } .login-form \u003e div { margin: 15px 0; } .error { color: red; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e \u003cform action=\"\" class=\"login-form\" novalidate\u003e \u003cdiv\u003e \u003clabel for=\"username\"\u003e姓名\u003c/label\u003e \u003cinput id=\"username\" type=\"text\" name=\"name\" required autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"passwd\"\u003e密码\u003c/label\u003e \u003cinput id=\"passwd\" type=\"password\" name=\"password\" required autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"mobile\"\u003e手机\u003c/label\u003e \u003cinput id=\"mobile\" type=\"text\" name=\"mobile\" required autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"where\"\u003e来自\u003c/label\u003e \u003cinput id=\"where\" type=\"text\" name=\"where\" autocomplete=\"off\"\u003e \u003cspan class=\"error\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003cinput type=\"submit\" value=\"登录\"\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"validate3.js\"\u003e\u003c/script\u003e \u003cscript\u003e $.validate({\"name\":{\"required\": true}, \"password\": {\"required\": true, \"minLength\": 8}, \"mobile\": {\"required\": true}}); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e HTML文件\n\"use strict\"; (function ($) { function check(arg) { // 定义一个标志位，表示验证通过还是验证不通过 var flag = true; var errMsg; // 校验规则 $(\"form input[type!=':submit']\").each(function () { var labelName = $(this).prev().text(); var inputName = $(this).attr(\"name\"); var inputValue = $(this).val(); if (arg[inputName].required) { // 如果是必填项 if (inputValue.length === 0) { // 值为空 errMsg = labelName + \"不能为空\"; $(this).next().text(errMsg); flag = false; return false; } // 如果是密码类型，我们就要判断密码的长度是否大于6位 if (inputName === \"password\") { // 除了上面判断为不为空还要判断密码长度是否大于6位 if (inputValue.length \u003c arg[inputName].minLength) { errMsg = labelName + \"必须大于\"+arg[inputName].minLength+\"位\"; $(this).next().text(errMsg); flag = false; return false; } } // 如果是手机类型，我们需要判断手机的格式是否正确 if (inputName === \"mobile\") { // 使用正则表达式校验inputValue是否为正确的手机号码 if (!/^1[345678]\\d{9}$/.test(inputValue)) { // 不是有效的手机号码格式 errMsg = labelName + \"格式不正确\"; $(this).next().text(errMsg); flag = false; return false; } } } }); return flag; } function clearError(arg) { // 清空之前的错误提示 $(arg).next().text(\"\"); } // 上面都是我定义的工具函数 $.extend({ validate: function (arg) { $(\"form :submit\").on(\"click\", function () { return check(arg); }); $(\"form :input[type!='submit']\").on(\"focus\", function () { clearError(this); }); } }); })(jQuery); JS文件\n课后习题：\n登录+验证 左侧菜单 表格-增、删、改、查 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"jQuery","uri":"/2018/03/14/cnblog_8565153/"},{"categories":["笔记","博客园"],"content":"这是👉linux screen 常用命令👈的摘要 screen -s yourname # 创建一个名字为yourname的screen\nscreen -ls # 查看所有screen screen -r yourname # 回到yourname这个screen screen -d yourname # 结束yourname这个screen screen -d -r yourname # 结束当前screen回到yourname 在当前这个screen 按ctrl + A + K 杀死当前screen ctrl + A + D 后台当前screen ","description":"","tags":["博客园","搬家","cnblogs"],"title":"linux screen 常用命令","uri":"/2018/03/13/cnblog_8554604/"},{"categories":["笔记","博客园"],"content":"这是👉前端基础之BOM和DOM👈的摘要 前戏 到目前为止，我们已经学过了JavaScript的一些简单的语法。但是这些简单的语法，并没有和浏览器有任何交互。\n也就是我们还不能制作一些我们经常看到的网页的一些交互，我们需要继续学习BOM和DOM相关知识。\nJavaScript分为 ECMAScript，DOM，BOM。\nBOM（Browser Object Model）是指浏览器窗口对象模型，顶级对象是window。\nDOM （Document Object Model）是指文档对象模型，并非一个对象。\nwindow、document都是一个实例对象，他们都属于Object，表示浏览器中打开的窗口。\nWindow对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先，在调用window对象的方法和属性时，可以省略window对象的引用。例如：window.document.write()可以简写成：document.write()。\nwindow对象 window 对象表示一个浏览器窗口。\n在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。例如，可以只写 document，而不必写 window.document\n同样，可以把当前窗口对象的方法当作函数来使用，如只写 alert()，而不必写 Window.alert()。\nalert() 显示带有一段消息和一个确认按钮的警告框。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 scrollTo() 把内容滚动到指定的坐标。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 prompt() 显示可提示用户输入的对话框。 open() 打开一个新的浏览器窗口或查找一个已命名的窗口。 close() 关闭浏览器窗口。 几个例子\n// 每隔一段时间就执行一次相应函数 var timer = setInterval(function(){console.log(123);}, 3000) // 取消setInterval设置 clearInterval(timer); // 在指定时间之后执行一次相应函数 var timer = setTimeout(function(){alert(123);}, 3000) // 取消setTimeout设置 clearTimeout(timer); View Code\nwindow的子对象 navigator对象 浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。\nnavigator.appName　// Web浏览器全称 navigator.appVersion　// Web浏览器厂商和版本的详细字符串 navigator.userAgent　// 客户端绝大部分信息 navigator.platform　// 浏览器运行所在的操作系统 screen对象 屏幕对象，不常用。\nhistory对象 浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，可以用来前进或后退一个页面。\nhistory.forward() // 前进一页 history.back() // 后退一页 history.go(n) // 前进n页 location对象 location.href 获取URL location.href=\"URL\" // 跳转到指定页面 location.reload() 重新加载页面 DOM DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。\n它是一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态地对文档的内容、结构和样式进行访问和修改。简单来讲，DOM是一种API（应用编程接口）。\nJavaScript对DOM进行了实现，对应于JavaScript中的document对象，通过该对象对DOM文档进行程序级别的控制。\nDOM标准规定HTML文档中的每个成分都是一个节点(node)：\n文档节点(document对象)：代表整个文档 元素节点(element 对象)：代表一个元素（标签） 文本节点(text对象)：代表元素（标签）中的文本 属性节点(attribute对象)：代表一个属性，元素（标签）才有属性 注释是注释节点(comment对象) 查找标签 document.getElementById 根据ID获取一个标签 document.getElementsByName 根据name属性获取标签集合 document.getElementsByClassName 根据class属性获取 document.getElementsByTagName 根据标签名获取标签合集 间接查找 parentNode 父节点 childNodes 所有子节点 firstChild 第一个子节点 lastChild 最后一个子节点 nextSibling 下一个兄弟节点 previousSibling 上一个兄弟节点 // 注意节点和标签的区别，主要记下面的 parentElement 父节点标签元素 children 所有子标签 firstElementChild 第一个子标签元素 lastElementChild 最后一个子标签元素 nextElementSibling 下一个兄弟标签元素 previousElementSibling 上一个兄弟标签元素 document对象的属性和操作 属性节点 attributes\n获取所有标签属性 getAttribute() 获取指定标签属性 setAttribute() 设置指定标签属 removeAttribute() 移除指定标签属 var s = document.createAttribute(\"age\")\ns.nodeValue = \"18\"\n|\n创建age属性\n设置属性值为18\n文本节点 innerText 所有的纯文本内容，包括子标签中的文本 outerText 与innerText类似 innerHTML 所有子节点(包括元素、注释和文本节点) outerHTML 返回自身节点与所有子节点 textContent 与innerText类似，返回的内容带样式 data 文本内容 length 文本长度 createTextNode() 创建文本 normalize() 删除文本与文本之间的空白 splitText() 分割 appendData() 追加 deleteData(offset,count) 从offset指定的位置开始删除count个字符 insertData(offset,text) 在offset指定的位置插入text replaceData(offset,count,text) 替换，从offset开始到offscount处的文本被text替换 substringData(offset,count) 提取从ffset开始到offscount处的文本 样式操作 操作class类\nclassName 获取所有样式类名(字符串) classList.remove(cls) 删除指定类 classList.add(cls) 添加类 classList.contains(cls) 存在返回true，否则返回false classList.toggle(cls) 存在就删除，否则添加 指定CSS操作\nobj.style.backgroundColor=\"red\" JS操作CSS属性的规律：\n1.对于没有中横线的CSS属性一般直接使用style.属性名即可。如：\nobj.style.margin obj.style.width obj.style.left obj.style.position 2.对含有中横线的CSS属性，将中横线后面的第一个字母换成大写即可。如：\nobj.style.marginTop obj.style.borderLeftWidth obj.style.zIndex obj.style.fontFamily 事件 HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。\nonclick 当用户点击某个对象时调用的事件句柄。 ondblclick 当用户双击某个对象时调用的事件句柄。 onfocus 元素获得焦点。 // 练习：输入框 onblur 元素失去焦点。 应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证. onchange 域的内容被改变。 应用场景：通常用于表单元素,当元素内容被改变时触发.（select联动） onkeydown 某个键盘按键被按下。 应用场景: 当用户在最后一个输入框按下回车按键时,表单提交. onkeypress 某个键盘按键被按下并松开。 onkeyup 某个键盘按键被松开。 onload 一张页面或一幅图像完成加载。 onmousedown 鼠标按钮被按下。 onmousemove 鼠标被移动。 onmouseout 鼠标从某元素移开。 onmouseover 鼠标移到某元素之上。 onselect 在文本框中的文本被选中时发生。 onsubmit 确认按钮被点击，使用的对象是form。 常用的那些 操作内容 innerText 文本 innerHTML HTML内容 value 值 文档节点的增删改查 增\ncreateElement(name) 创建节点（标签） appendChild() 末尾添加节点，并返回新增节点 insertBefore() 参照节点之前插入节点，两个参数：要插入的节点和参照节点 删\n查找到要删除的元素 获取它的父元素 使用removeChild()方法删除 改\n第一种方式:\n使用上面增和删结合完成修改 第二种方式:\n使用setAttribute();方法修改属性 使用innerHTML属性修改元素的内容 查\n使用之前介绍的方法.\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"前端基础之BOM和DOM","uri":"/2018/03/12/cnblog_8550048/"},{"categories":["笔记","博客园"],"content":"这是👉前端基础之JavaScript👈的摘要 JavaScript概述 JavaScript的历史 1992年Nombas开发出C-minus-minus(C--)的嵌入式脚本语言(最初绑定在CEnvi软件中)，后将其改名ScriptEase(客户端执行的语言)。 Netscape(网景)接收Nombas的理念,(Brendan Eich)在其Netscape Navigator 2.0产品中开发出一套livescript的脚本语言。Sun和Netscape共同完成，后改名叫JavaScript。 微软随后模仿在其IE3.0的产品中搭载了一个JavaScript的克隆版叫Jscript。 为了统一三家,ECMA(欧洲计算机制造协会)定义了ECMA-262规范.国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。 ECMA-262 是 JavaScript 标准的官方名称。 ECMAScript 年份 名称 描述 1997 ECMAScript 1 第一个版本 1998 ECMAScript 2 版本变更 1999 ECMAScript 3 添加正则表达式\n添加tru/catch\n| ECMAScript 4 | 没有发布\n2009 | ECMAScript 5 |\n添加\"strict mode\"严格模式\n添加JSON支持\n2011 | ECMAScript 5.1 | 版本变更\n2015 | ECMAScript 6 | 添加类和模块\n2016 | ECMAScript 7 |\n增加指数运算符（**）\n增加Array.prototype.includes\n注：ES6就是指ECMAScript 6。\n尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：\n核心（ECMAScript） 文档对象模型（DOM） Document object model (整合js，css，html) 浏览器对象模型（BOM） Broswer object model（整合js和浏览器） Javascript在开发中绝大多数情况是基于对象的.也是面向对象的. 简单地说，ECMAScript 描述了以下内容：\n语法 类型 语句 关键字 保留字 运算符 对象 (封装 继承 多态) 基于对象的语言.使用对象. JavaScript引入方式 Script标签内写代码 \u003cscript\u003e // 在这里写你的JS代码 \u003c/script\u003e 引入额外的JS文件 \u003cscript src=\"myscript.js\"\u003e\u003c/script\u003e JavaScript语言规范 注释（注释是代码之母） // 这是单行注释 /* 这是 多行注释 */ 结束符 JavaScript中的语句要以分号（;）为结束符。\nJavaScript语言基础 变量声明 JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。 声明变量使用 var 变量名; 的格式来进行声明 var name = \"Alex\"; var age = 18; 注意：\n变量名是区分大小写的。\n推荐使用驼峰式命名规则。\nJavaScript数据类型 JavaScript拥有动态类型\nvar x; // 此时x是undefined var x = 1; // 此时x是数字 var x = \"Alex\" // 此时x是字符串 数字类型\nJavaScript不区分整型和浮点型，就只有一种数字类型。\nvar a = 12.34; var b = 20; var c = 123e5; // 12300000 var d = 123e-5; // 0.00123 还有一种NaN，表示不是一个数字（Not a Number）。\n常用方法：\nparseInt(\"123\") // 返回123 parseInt(\"ABC\") // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。 parseFloat(\"123.456\") // 返回123.456 字符串\nvar a = \"Hello\" var b = \"world; var c = a + b; console.log(c); // 得到Helloworld 常用方法：\n方法 说明 obj.length 返回长度 obj.trim() 移除空白 obj.trimLeft() 移除左边的空白 obj.trimRight() 移除右边的空白 obj.charAt(n) 返回第n个字符 obj.concat(value, ...) 拼接 obj.indexOf(substring, start) 子序列位置 obj.substring(from, to) 根据索引获取子序列 obj.slice(start, end) 切片 obj.toLowerCase() 小写 obj.toUpperCase() 大写 obj.split(delimiter, limit) 分割 拼接字符串一般使用\"+\"\n布尔类型 区别于Python，true和false都是小写。\nvar a = true; var b = false; 数组 类似于Python中的列表。\nvar a = [123, \"ABC\"]; console.log(a[1]); // 输出\"ABC\" 常用方法：\n方法 说明 obj.length 数组的大小 obj.push(ele) 尾部追加元素 obj.pop() 获取尾部的元素 obj.unshift(ele) 头部插入元素 obj.shift() 头部移除元素 obj.slice() 切片 obj.reverse() 反转 obj.join(seq) 将数组元素连接成字符串 obj.concat(val, ...) 连接数组 obj.sort() 排序 遍历数组中的元素：\nvar a = [10, 20, 30, 40]; for (var i=0;i\u003ca.length;i++) { console.log(i); } null和undefined null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null; undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined。 null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值。\n还不明白，上图吧！\n类型查询 typeof \"abc\" // \"string\" typeof null // \"object\" typeof true // \"boolean\" typeof 123 // \"number\" typeof是一个一元运算符（就像++，--，！，- 等一元运算符），不是一个函数，也不是一个语句。\n运算符 算数运算符 + - * / % ++ -- 比较运算符 \u003e \u003e= \u003c \u003c= != == === !== 注意：\n1 == \"1\" // true 1 === \"1\" // false 逻辑运算符 \u0026\u0026 || ! 赋值运算符 = += -= *= /= 流程控制 if-else var a = 10; if (a \u003e 5){ console.log(\"yes\"); }else { console.log(\"no\"); } if-else if-else var a = 10; if (a \u003e 5){ console.log(\"a \u003e 5\"); }else if (a \u003c 5) { console.log(\"a \u003c 5\"); }else { console.log(\"a = 5\"); } switch var day = new Date().getDay(); switch (day) { case 0: console.log(\"Sunday\"); break; case 1: console.log(\"Monday\"); break; default: console.log(\"...\") } for for (var i=0;i\u003c10;i++) { console.log(i); } while var i = 0; while (i \u003c 10) { console.log(i); i++; } 三元运算 var a = 1; var b = 2; var c = a \u003e b ? a : b 函数 函数定义 JavaScript中的函数和Python中的非常类似，只是定义方式有点区别。\n// 普通函数定义 function f1() { console.log(\"Hello world!\"); } // 带参数的函数 function f2(a, b) { console.log(arguments); // 内置的arguments对象 console.log(arguments.length); console.log(a, b); } // 带返回值的函数 function sum(a, b){ return a + b; } sum(1, 2); // 调用函数 // 匿名函数方式 var sum = function(a, b){ return a + b; } sum(1, 2); // 立即执行函数 (function(a, b){ return a + b; })(1, 2); 函数的全局变量和局部变量 局部变量 ：\n在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。只要函数运行完毕，本地变量就会被删除。\n全局变量：\n在函数外声明的变量是 全局 变量，网页上的所有脚本和函数都能访问它。\n变量生存周期：\nJavaScript变量的生命期从它们被声明的时间开始。\n局部变量会在函数运行以后被删除。\n全局变量会在页面关闭后被删除。\n作用域 首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层。\n几个例子：\nvar city = \"BeiJing\"; function f() { var city = \"ShangHai\"; function inner(){ var city = \"ShenZhen\"; console.log(city); } inner(); } f(); //输出结果是？ var city = \"BeiJing\"; function Bar() { console.log(city); } function f() { var city = \"ShangHai\"; return Bar; } var ret = f(); ret(); // 打印结果是？ 3.闭包\nvar city = \"BeiJing\"; function f(){ var city = \"ShangHai\"; function inner(){ console.log(city); } return inner; } var ret = f(); ret(); 内置对象和方法 JavaScript中的所有事物都是对象：字符串、数字、数组、日期，等等。在JavaScript中，对象是拥有属性和方法的数据。\n我们在学习基本数据类型的时候已经带大家了解了，JavaScript中的Number对象、String对象、Array对象等。\n自定义对象 类似于（某方面类似）Python中的字典数据类型\nvar a = {\"name\": \"Alex\", \"age\": 18}; console.log(a.name); console.log(a[\"age\"]); 遍历对象中的内容：\nvar a = {\"name\": \"Alex\", \"age\": 18}; for (var i in a){ console.log(i, a[i]); } [事情并没有那么简单...](https://stackoverflow.com/questions/684672/how-do-i-loop- through-or-enumerate-a-javascript-object)\n创建对象：\nvar person=new Object(); // 创建一个person对象 person.name=\"Alex\"; // person对象的name属性 person.age=18; // person对象的age属性 ** 扩展：**\n// 父类构造函数 var Car = function (loc) { this.loc = loc; }; // 父类方法 Car.prototype.move = function () { this.loc ++; }; // 子类构造函数 var Van = function (loc) { Car.call(this, loc); }; // 继承父类的方法 Van.prototype = Object.create(Car.prototype); // 修复 constructor Van.prototype.constructor = Van; // 扩展方法 Van.prototype.grab = function () { /* ... */ }; JavaScript面向对象之继承\nDate对象 创建Date对象\n//方法1：不指定参数 var d1 = new Date(); console.log(d1.toLocaleString()); //方法2：参数为日期字符串 var d2 = new Date(\"2004/3/20 11:12\"); console.log(d2.toLocaleString()); var d3 = new Date(\"04/03/20 11:12\"); console.log(d3.toLocaleString()); //方法3：参数为毫秒数 var d3 = new Date(5000); console.log(d3.toLocaleString()); console.log(d3.toUTCString()); //方法4：参数为年月日小时分钟秒毫秒 var d4 = new Date(2004,2,20,11,12,0,300); console.log(d4.toLocaleString()); //毫秒并不直接显示 Date对象的方法：\nvar d = new Date(); //getDate() 获取日 //getDay () 获取星期 //getMonth () 获取月（0-11） //getFullYear () 获取完整年份 //getYear () 获取年 //getHours () 获取小时 //getMinutes () 获取分钟 //getSeconds () 获取秒 //getMilliseconds () 获取毫秒 //getTime () 返回累计毫秒数(从1970/1/1午夜) 练习：\n编写代码，将当前日期按\"2017-12-27 11:11 星期三\"格式输出。\n详细Date对象方法：点我\nJSON对象 var str1 = '{\"name\": \"Alex\", \"age\": 18}'; var obj1 = {\"name\": \"Alex\", \"age\": 18}; // JSON字符串转换成对象 var obj = JSON.parse(str1); // 对象转换成JSON字符串 var str = JSON.stringify(obj1); RegExp对象 //RegExp对象 //创建正则对象方式1 // 参数1 正则表达式(不能有空格) // 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写) // 用户名只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。 // 创建RegExp对象方式（逗号后面不要加空格） var reg1 = new RegExp(\"^[a-zA-Z][a-zA-Z0-9_]{5,11}$\"); // 匹配响应的字符串 var s1 = \"bc123\"; //RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。 reg1.test(s1); // true // 创建方式2 // /填写正则表达式/匹配模式（逗号后面不要加空格） var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/; reg2.test(s1); // true // String对象与正则结合的4个方法 var s2 = \"hello world\"; s2.match(/o/g); // [\"o\", \"o\"] 查找字符串中 符合正则 的内容 s2.search(/h/g); // 0 查找字符串中符合正则表达式的内容位置 s2.split(/o/g); // [\"hell\", \" w\", \"rld\"] 按照正则表达式对字符串进行切割 s2.replace(/o/g, \"s\"); // \"hells wsrld\" 对字符串按照正则进行替换 // 关于匹配模式：g和i的简单示例 var s1 = \"name:Alex age:18\"; s1.replace(/a/, \"哈哈哈\"); // \"n哈哈哈me:Alex age:18\" s1.replace(/a/g, \"哈哈哈\"); // \"n哈哈哈me:Alex 哈哈哈ge:18\" 全局匹配 s1.replace(/a/gi, \"哈哈哈\"); // \"n哈哈哈me:哈哈哈lex 哈哈哈ge:18\" 不区分大小写 // 注意事项1： // 如果regExpObject带有全局标志g，test()函数不是从字符串的开头开始查找，而是从属性regExpObject.lastIndex所指定的索引处开始查找。 // 该属性值默认为0，所以第一次仍然是从字符串的开头查找。 // 当找到一个匹配时，test()函数会将regExpObject.lastIndex的值改为字符串中本次匹配内容的最后一个字符的下一个索引位置。 // 当再次执行test()函数时，将会从该索引位置处开始查找，从而找到下一个匹配。 // 因此，当我们使用test()函数执行了一次匹配之后，如果想要重新使用test()函数从头开始查找，则需要手动将regExpObject.lastIndex的值重置为 0。 // 如果test()函数再也找不到可以匹配的文本时，该函数会自动把regExpObject.lastIndex属性重置为 0。 var reg3 = /foo/g; // 此时 regex.lastIndex=0 reg3.test('foo'); // 返回true // 此时 regex.lastIndex=3 reg3.test('foo'); // 返回false // 所以我们在使用test()方法校验一个字符串是否完全匹配时，不推荐添加全局匹配模式g。 // 注意事项2(说出来你可能不信系列)： // 当我们不加参数调用RegExpObj.test()方法时, 相当于执行RegExpObj.test(\"undefined\"), 并且/undefined/.test()默认返回true。 var reg4 = /^undefined$/; reg4.test(); // 返回true reg4.test(undefined); // 返回true reg4.test(\"undefined\"); // 返回true RegExp\n[扩展阅读](https://developer.mozilla.org/zh- CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\nMath对象 abs(x) 返回数的绝对值。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 Math\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"前端基础之JavaScript","uri":"/2018/03/08/cnblog_8527506/"},{"categories":["笔记","博客园"],"content":"这是👉前端基础之CSS👈的摘要 CSS介绍 CSS（ C ascading S tyle S heet，层叠样式表)定义 如何显示 HTML元素。\n当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。\nCSS语法 CSS实例 每个CSS样式由两个组成部分：选择器和声明。声明又包括属性和属性值。每个声明之后用分号结束。\nCSS注释 /*这是注释*/ 注释是代码之母。--摘自哪吒语录\nCSS的几种引入方式 行内样式 行内式是在标记的style属性中设定CSS样式。不推荐大规模使用。\n\u003cp style=\"color: red\"\u003eHello world.\u003c/p\u003e 内部样式 嵌入式是将CSS样式集中写在网页的标签对的标签对中。格式如下：\n\u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003cstyle\u003e p{ background-color: #2b99ff; } \u003c/style\u003e \u003c/head\u003e 外部样式 外部样式就是将css写在一个单独的文件中，然后在页面进行引入即可。推荐使用此方式。\n\u003clink href=\"mystyle.css\" rel=\"stylesheet\" type=\"text/css\"/\u003e CSS选择器 基本选择器 元素选择器 p {color: \"red\";} ID选择器 #i1 { background-color: red; } 类选择器 .c1 { font-size: 14px; } p.c1 { color: red; } 注意：\n样式类名不要用数字开头（有的浏览器不认）。\n标签中的class属性如果有多个，要用空格分隔。\n通用选择器 * { color: white; } 组合选择器 后代选择器 /*li内部的a标签设置字体颜色*/ li a { color: green; } 儿子选择器 /*选择所有父级是 \u003cdiv\u003e 元素的 \u003cp\u003e 元素*/ div\u003ep { font-family: \"Arial Black\", arial-black, cursive; } 毗邻选择器 /*选择所有紧接着\u003cdiv\u003e元素之后的\u003cp\u003e元素*/ div+p { margin: 5px; } 弟弟选择器 /*i1后面所有的兄弟p标签*/ #i1~p { border: 2px solid royalblue; } 属性选择器 /*用于选取带有指定属性的元素。*/ p[title] { color: red; } /*用于选取带有指定属性和值的元素。*/ p[title=\"213\"] { color: green; } /*找到所有title属性以hello开头的元素*/ [title^=\"hello\"] { color: red; } /*找到所有title属性以hello结尾的元素*/ [title$=\"hello\"] { color: yellow; } /*找到所有title属性中包含（字符串包含）hello的元素*/ [title*=\"hello\"] { color: red; } /*找到所有title属性(有多个值或值以空格分割)中有一个值为hello的元素：*/ [title~=\"hello\"] { color: green; } 不怎么常用的属性选择器\n分组和嵌套 分组 当多个元素的样式相同的时候，我们没有必要重复地为每个元素都设置样式，我们可以通过在多个选择器之间使用逗号分隔的分组选择器来统一设置元素样式。\n例如：\ndiv, p { color: red; } 上面的代码为div标签和p标签统一设置字体为红色。\n通常，我们会分两行来写，更清晰:\ndiv, p { color: red; } 嵌套 多种选择器可以混合起来使用，比如：.c1类内部所有p标签设置字体颜色为红色。\n.c1 p { color: red; } 伪类选择器 /* 未访问的链接 */ a:link { color: #FF0000 } /* 已访问的链接 */ a:visited { color: #00FF00 } /* 鼠标移动到链接上 */ a:hover { color: #FF00FF } /* 选定的链接 */ a:active { color: #0000FF } /*input输入框获取焦点时样式*/ input:focus { outline: none; background-color: #eee; 伪元素选择器 first-letter 常用的给首字母设置特殊样式：\np:first-letter { font-size: 48px; color: red; } before /*在每个\u003cp\u003e元素之前插入内容*/ p:before { content:\"*\"; color:red; } after /*在每个\u003cp\u003e元素之后插入内容*/ p:after { content:\"[?]\"; color:blue; } before和after多用于清除浮动。\n选择器的优先级 CSS继承 继承是CSS的一个主要特征，它是依赖于祖先- 后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个body定义了的字体颜色值也会应用到段落的文本中。\nbody { color: red; } 此时页面上所有标签都会继承body的字体颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。\n我们只要给对应的标签设置字体颜色就可覆盖掉它继承的样式。\np { color: green; } 此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。\n选择器的优先级 我们上面学了很多的选择器，也就是说在一个HTML页面中有很多种方式找到一个元素并且为其设置样式，那浏览器根据什么来决定应该应用哪个样式呢？\n其实是按照不同选择器的权重来决定的，具体的选择器权重计算方式如下图：\n除此之外还可以通过添加 !import方式来强制让样式生效，但并不推荐使用。因为如果过多的使用!import会使样式文件混乱不易维护。\n万不得已可以使用!import\nCSS属性相关 字体属性 文字字体 font-family可以把多个字体名称作为一个\"回退\"系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。浏览器会使用它可识别的第一个值。\n简单实例：\nbody { font-family: \"Microsoft Yahei\", \"微软雅黑\", \"Arial\", sans-serif } 字体大小 p { font-size: 14px; } 如果设置成inherit表示继承父元素的字体大小值。\n字重（粗细） font-weight用来设置字体的字重（粗细）。\n值 描述 normal 默认值，标准粗细 bold 粗体 bolder 更粗 lighter 更细 100~900 设置具体粗细，400等同于normal，而700等同于bold inherit 继承父元素字体的粗细值 文本颜色 颜色属性被用来设置文字的颜色。\n颜色是通过CSS最经常的指定：\n十六进制值 - 如: ＃ FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 还有rgba(255,0,0,0.3)，第四个值为alpha, 指定了色彩的透明度/不透明度，它的范围为0.0到1.0之间。\n文字属性 文字对齐 text-align 属性规定元素中的文本的水平对齐方式。\n值 描述 left 左边对齐 默认值 right 右对齐 center 居中对齐 justify 两端对齐 文字装饰 text-decoration 属性用来给文字添加特殊效果。\n值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 inherit 继承父元素的text-decoration属性的值。 常用的为去掉a标签默认的自划线：\na { text-decoration: none; } 首行缩进 将段落的第一行缩进 32像素：\np { text-indent: 32px; } 背景属性 /*背景颜色*/ background-color: red; /*背景图片*/ background-image: url('1.jpg'); /* 背景重复 repeat(默认):背景图片平铺排满整个网页 repeat-x：背景图片只在水平方向上平铺 repeat-y：背景图片只在垂直方向上平铺 no-repeat：背景图片不平铺 */ background-repeat: no-repeat; /*背景位置*/ background-position: right top（20px 20px）; 支持简写：\nbackground:#ffffff url('1.png') no-repeat right top; 使用背景图片的一个常见案例就是很多网站会把很多小图标放在一张图片上，然后根据位置去显示图片。减少频繁的图片请求。\n参考链接点我\n一个有趣的例子：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003e滚动背景图示例\u003c/title\u003e \u003cstyle\u003e * { margin: 0; } .box { width: 100%; height: 500px; background: url(\"https://www.luffycity.com/static/img/width-bank.1c9d1b0.png\") no-repeat center center; background-attachment: fixed; } .d1 { height: 500px; background-color: tomato; } .d2 { height: 500px; background-color: steelblue; } .d3 { height: 500px; background-color: mediumorchid; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"d1\"\u003e\u003c/div\u003e \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003cdiv class=\"d2\"\u003e\u003c/div\u003e \u003cdiv class=\"d3\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 鼠标滚动背景不动\n边框 边框属性\nborder-width\nborder-style\nborder-color\n#i1 { border-width: 2px; border-style: solid; border-color: red; }\n通常使用简写方式：\n#i1 { border: 2px solid red; } 边框样式\n值 描述 none 无边框。 dotted 点状虚线边框。 dashed 矩形虚线边框。 solid 实线边框。 除了可以统一设置边框外还可以单独为某一个边框设置样式，如下所示：\n#i1 { border-top-style:dotted; border-top-color: red; border-right-style:solid; border-bottom-style:dotted; border-left-style:none; } display属性 用于控制HTML元素的显示效果。\n值 意义 display:\"none\" HTML文档中元素存在，但是在浏览器中不显示。一般用于配合JavaScript代码使用。 display:\"block\" 默认占满整个页面宽度，如果设置了指定宽度，则会用margin填充剩下的部分。 display:\"inline\" 按行内元素显示，此时再设置元素的width、height、margin-top、margin- bottom和float属性都不会有什么影响。 display:\"inline-block\" 使元素同时具有行内元素和块级元素的特点。 display:\"none\"与visibility:hidden的区别：\nvisibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。\ndisplay:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。\nCSS盒子模型 margin : 用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。 padding : 用于控制内容与边框之间的距离； Border (边框): 围绕在内边距和内容外的边框。 Content (内容): 盒子的内容，显示文本和图像。 看图吧：\nmargin外边距 .margin-test { margin-top:5px; margin-right:10px; margin-bottom:15px; margin-left:20px; } 推荐使用简写：\n.margin-test { margin: 5px 10px 15px 20px; } 顺序：上右下左\n常见居中：\n.mycenter { margin: 0 auto; } padding内填充 .padding-test { padding-top: 5px; padding-right: 10px; padding-bottom: 15px; padding-left: 20px; } 推荐使用简写：\n.padding-test { padding: 5px 10px 15px 20px; } 顺序：上右下左\n补充padding的常用简写方式：\n提供一个，用于四边； 提供两个，第一个用于上－下，第二个用于左－右； 如果提供三个，第一个用于上，第二个用于左－右，第三个用于下； 提供四个参数值，将按上－右－下－左的顺序作用于四边； float 在 CSS 中，任何元素都可以浮动。\n浮动元素会生成一个块级框，而不论它本身是何种元素。\n关于浮动的两个特点：\n浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 三种取值 left：向左浮动\nright：向右浮动\nnone：默认值，不浮动\n参考示例\nclear clear属性规定元素的哪一侧不允许其他浮动元素。\n值 描述 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值。 注意：clear属性只会对 自身 起作用，而不会影响其他元素。\n父标签塌陷问题 .clearfix:after { content: \"\"; display: block; clear: both; } overflow溢出属性 值 描述 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 overflow（水平和垂直均设置） overflow-x（设置水平方向） overflow-y（设置垂直方向） 定位（position） static static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。\nrelative（相对定位） 相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z- index属性定义。\n注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。\nabsolute（绝对定位） 定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。\n重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。\n另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。\nfixed（固定） fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z- index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是\"定位流\"。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。\n在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。\n示例代码：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e返回顶部示例\u003c/title\u003e \u003cstyle\u003e * { margin: 0; } .d1 { height: 1000px; background-color: #eeee; } .scrollTop { background-color: darkgrey; padding: 10px; text-align: center; position: fixed; right: 10px; bottom: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"d1\"\u003e111\u003c/div\u003e \u003cdiv class=\"scrollTop\"\u003e返回顶部\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 返回顶部按钮样式示例\nz-index #i2 { z-index: 999; } 设置对象的层叠顺序，数值大的会覆盖在数值小的标签之上。z-index 仅能在定位元素上奏效。\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e自定义模态框\u003c/title\u003e \u003cstyle\u003e .cover { background-color: rgba(0,0,0,0.65); position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 998; } .modal { background-color: white; position: fixed; width: 600px; height: 400px; left: 50%; top: 50%; margin: -200px 0 0 -300px; z-index: 1000; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"cover\"\u003e\u003c/div\u003e \u003cdiv class=\"modal\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 自定义模态框示例\nopacity 用来定义透明效果。取值范围是0~1，0是完全透明，1是完全不透明。\n综合示例 顶部导航菜单 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eli标签的float示例\u003c/title\u003e \u003cstyle\u003e /*清除浏览器默认外边距和内填充*/ * { margin: 0; padding: 0; } a { text-decoration: none; /*去除a标签默认的下划线*/ } .nav { background-color: black; height: 40px; width: 100%; position: fixed; top: 0; } ul { list-style-type: none; /*删除列表默认的圆点样式*/ margin: 0; /*删除列表默认的外边距*/ padding: 0; /*删除列表默认的内填充*/ } /*li元素向左浮动*/ li { float: left; } li \u003e a { display: block; /*让链接显示为块级标签*/ padding: 0 15px; /*设置左右各15像素的填充*/ color: #b0b0b0; /*设置字体颜色*/ line-height: 40px; /*设置行高*/ } /*鼠标移上去颜色变白*/ li \u003e a:hover { color: #fff; } /*清除浮动 解决父级塌陷问题*/ .clearfix:after { content: \"\"; display: block; clear: both; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 顶部导航栏 开始 --\u003e \u003cdiv class=\"nav\"\u003e \u003cul class=\"clearfix\"\u003e \u003cli\u003e\u003ca href=\"\"\u003e玉米商城\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003eMIUI\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003eioT\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003e云服务\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003e水滴\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003e金融\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003e优品\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c!-- 顶部导航栏 结束 --\u003e \u003c/body\u003e \u003c/html\u003e 顶部导航菜单示例\n圆形头像 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e圆形的头像示例\u003c/title\u003e \u003cstyle\u003e * { margin: 0; padding: 0; background-color: #eeeeee; } .header-img { width: 150px; height: 150px; border: 3px solid white; border-radius: 100%; overflow: hidden; } .header-img\u003eimg { max-width: 100%; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"header-img\"\u003e \u003cimg src=\"https://q1mi.github.io/Blog/asset/img/head_img.jpg\" alt=\"\"\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 圆形头像图示例\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"前端基础之CSS","uri":"/2018/03/08/cnblog_8527496/"},{"categories":["笔记","博客园"],"content":"这是👉前端知识之HTML内容👈的摘要 HTML介绍 Web服务本质 import socket sk = socket.socket() sk.bind((\"127.0.0.1\", 8080)) sk.listen(5) while True: conn, addr = sk.accept() data = conn.recv(8096) conn.send(b\"HTTP/1.1 200 OK\\r\\n\\r\\n\") conn.secd(b\"\u003ch1\u003eHello world!\u003c/h1\u003e\") conn.close() 浏览器发请求 --\u003e HTTP协议 --\u003e 服务端接收请求 --\u003e 服务端返回响应 --\u003e 服务端把HTML文件内容发给浏览器 --\u003e 浏览器渲染页面\nHTML是什么？ 超文本标记语言（Hypertext Markup Language, HTML）是一种用于创建网页的标记语言。 本质上是浏览器可识别的规则，我们按照规则写网页，浏览器根据规则渲染我们的网页。对于不同的浏览器，对同一个标签可能会有不同的解释。（兼容性问题） 网页文件的扩展名：.html或.htm HTML不是什么？ HTML是一种标记语言（markup language），它不是一种编程语言。\nHTML使用标签来描述网页。\nHTML文档结构 最基本的HTML文档：\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ecss样式优先级\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e声明为HTML5文档。 、是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。 、定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。 、定义了网页标题，在浏览器标题栏显示。 、之间的文本是可见的网页主体内容。 注意： 对于中文网页需要使用 \u003c meta charset=\"utf-8\"\u003e 声明编码，否则会出现乱码。有些浏览器会设置 GBK 为默认编码，则你需要设置为 \u003c meta charset=\"gbk\"\u003e。\nHTML标签格式 HTML标签是由尖括号包围的关键字，如, 等 HTML标签通常是成对出现的，比如：和，第一个标签是开始，第二个标签是结束。结束标签会有斜线。 也有一部分标签是单独呈现的，比如：、、等。 标签里面可以有若干属性，也可以不带属性。 标签的语法：\n\u003c标签名 属性1=\"属性值1\" 属性2=\"属性值2\"……\u003e内容部分\u003c/标签名\u003e \u003c标签名 属性1=\"属性值1\" 属性2=\"属性值2\"…… /\u003e 几个很重要的属性：\nid：定义标签的唯一ID，HTML文档树中唯一 class：为html元素定义一个或多个类名（classname）(CSS样式类名) style：规定元素的行内样式（CSS样式） HTML注释 \u003c!--注释内容--\u003e 注释是代码之母.\n\u003c!DOCTYPE\u003e 标签 \u003c!DOCTYPE\u003e 声明必须是 HTML 文档的第一行，位于 标签之前。 \u003c!DOCTYPE\u003e 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 HTML常用标签 head内常用标签 标签 意义 | 定义网页标题 | 定义内部样式表 | 定义JS代码或引入外部JS文件 | 引入外部样式表文件 | 定义网页原信息 Meta标签 Meta标签介绍：\n元素可提供有关页面的原信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。 标签位于文档的头部，不包含任何内容。 提供的信息是用户不可见的。 meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。\n1.http- equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。\n\u003c!--2秒后跳转到对应的网址，注意引号--\u003e \u003cmeta http-equiv=\"refresh\" content=\"2;URL=https://www.oldboyedu.com\"\u003e \u003c!--指定文档的编码类型--\u003e \u003cmeta http-equiv=\"content-Type\" charset=UTF8\"\u003e \u003c!--告诉IE以最高级模式渲染文档--\u003e \u003cmeta http-equiv=\"x-ua-compatible\" content=\"IE=edge\"\u003e 2.name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。\n\u003cmeta name=\"keywords\" content=\"meta总结,html meta,meta属性,meta跳转\"\u003e \u003cmeta name=\"description\" content=\"老男孩教育Python学院\"\u003e body内常用标签 基本标签（块级标签和内联标签） \u003cb\u003e加粗\u003c/b\u003e \u003ci\u003e斜体\u003c/i\u003e \u003cu\u003e下划线\u003c/u\u003e \u003cs\u003e删除\u003c/s\u003e \u003cp\u003e段落标签\u003c/p\u003e \u003ch1\u003e标题1\u003c/h1\u003e \u003ch2\u003e标题2\u003c/h2\u003e \u003ch3\u003e标题3\u003c/h3\u003e \u003ch4\u003e标题4\u003c/h4\u003e \u003ch5\u003e标题5\u003c/h5\u003e \u003ch6\u003e标题6\u003c/h6\u003e \u003c!--换行--\u003e \u003cbr\u003e \u003c!--水平线--\u003e\u003chr\u003e 特殊字符 内容 对应代码 空格 | \u003e\n\u003c | \u003c\n\u0026 | \u0026\n¥ | ¥\n版权 | ©\n注册 | ®\ndiv标签和span标签 div标签用来定义一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。\nspan标签用来定义内联(行内)元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。\n块级元素与行内元素的区别：\n所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。\n这两个元素是专门为定义CSS样式而生的。\n注意：\n关于标签嵌套：通常块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。\np标签不能包含块级标签。\nimg标签 \u003cimg src=\"图片的路径\" alt=\"图片未加载成功时的提示\" title=\"鼠标悬浮时提示信息\" width=\"宽\" height=\"高(宽高两个属性只用一个会自动等比缩放)\"\u003e a标签 超链接标签\n所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。\n什么是URL？ URL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。 URL举例 http://www.sohu.com/stu/intro.html http://222.172.123.33/stu/intro.html URL地址由4部分组成 第1部分：为协议：http://、ftp://等 第2部分：为站点地址：可以是域名或IP地址 第3部分：为页面在站点中的目录：stu 第4部分：为页面名称，例如 index.html 各部分之间用\"/\"符号隔开。 URL\n\u003ca href=\"http://www.oldboyedu.com\" target=\"_blank\" \u003e点我\u003c/a\u003e href属性指定目标网页地址。该地址可以有几种类型：\n绝对URL - 指向另一个站点（比如 href=\"http://www.jd.com） 相对URL - 指当前站点中确切的路径（href=\"index.htm\"） 锚URL - 指向页面中的锚（href=\"#top\"） target：\n_blank表示在新标签页中打开目标网页 _self表示在当前标签页中打开目标网页 列表 1.无序列表\n\u003cul type=\"disc\"\u003e \u003cli\u003e第一项\u003c/li\u003e \u003cli\u003e第二项\u003c/li\u003e \u003c/ul\u003e type属性：\ndisc（实心圆点，默认值） circle（空心圆圈） square（实心方块） none（无样式） 2.有序列表\n\u003col type=\"1\" start=\"2\"\u003e \u003cli\u003e第一项\u003c/li\u003e \u003cli\u003e第二项\u003c/li\u003e \u003c/ol\u003e type属性：\n1 数字列表，默认值 A 大写字母 a 小写字母 Ⅰ大写罗马 ⅰ小写罗马 3.标题列表\n\u003cdl\u003e \u003cdt\u003e标题1\u003c/dt\u003e \u003cdd\u003e内容1\u003c/dd\u003e \u003cdt\u003e标题2\u003c/dt\u003e \u003cdd\u003e内容1\u003c/dd\u003e \u003cdd\u003e内容2\u003c/dd\u003e \u003c/dl\u003e 表格 表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。\n表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。\n表格的基本结构：\n\u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003e序号\u003c/th\u003e \u003cth\u003e姓名\u003c/th\u003e \u003cth\u003e爱好\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e1\u003c/td\u003e \u003ctd\u003eEgon\u003c/td\u003e \u003ctd\u003e杠娘\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2\u003c/td\u003e \u003ctd\u003eYuan\u003c/td\u003e \u003ctd\u003e日天\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 属性:\nborder: 表格边框. cellpadding: 内边距 cellspacing: 外边距. width: 像素 百分比.（最好通过css来设置长宽） rowspan: 单元格竖跨多少行 colspan: 单元格横跨多少列（即合并单元格） form 功能：\n表单用于向服务器传输数据，从而实现用户与Web服务器的交互\n表单能够包含input系列标签，比如文本字段、复选框、单选框、提交按钮等等。\n表单还可以包含textarea、select、fieldset和 label标签。\n表单属性\n属性 值 含义 action URL 指定一个表单处理目标URL，表单数据将被提交到该URL地址的处理程序。如果该属性值为空，则提交到文档自身。 method get或post 将表单数据提交到http服务器的方法，默认为get enctype application/x-www-form-urlencoded 指定表单数据的编码类型，此属性只有在method属性设置为post时才有效。默认值为application/x-www-form- urlencode对所有字符进行编码。如果表单包含用于文件上传的控件（input type=\"file\"）,那么这个属性值必须设置为multipart/form-data，不对字符进行编码。 表单元素\n基本概念：\nHTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。\n表单一般用来收集用户的输入信息\n表单工作原理：\n访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交。这些信息通过Internet传送到服务器上。\n服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误。当数据完整无误后，服务器反馈一个输入完成的信息\ninput系列 type属性值 表现形式 对应代码 text 单行输入文本 \u003cinput type=text\" /\u003e password 密码输入框 checkbox 复选框 radio 单选框 submit 提交按钮 reset 重置按钮 button 普通按钮 hidden 隐藏按钮 file 文本选择框 类型（type）说明：\ntext：文本输入框 password：密码输入框 radio：单选框 checkbox：多选框 submit：提交按钮 button：可点击的按钮，没有任何行为，一般配合JS使用 hidden：对用户不可见，通常用于修改某条数据时，记录数据的id值 file：提交文件 form表单需要加上enctype=\"multipart/form-data\"，method=\"post\" 属性说明:\nname：表单提交时的\"键\"，注意和id的区别 value：表单提交时对应项的值 type=\"button\", \"reset\", \"submit\"时，为按钮上显示的文本年内容 type=\"text\",\"password\",\"hidden\"时，为输入框的初始值 type=\"checkbox\", \"radio\", \"file\"，为输入相关联的值 checked：radio和checkbox默认被选中的项 readonly：text和password设置只读 disabled：所有input均适用 select标签 \u003cform action=\"\" method=\"post\"\u003e \u003cselect name=\"city\" id=\"city\"\u003e \u003coption value=\"1\"\u003e北京\u003c/option\u003e \u003coption selected=\"selected\" value=\"2\"\u003e上海\u003c/option\u003e \u003coption value=\"3\"\u003e广州\u003c/option\u003e \u003coption value=\"4\"\u003e深圳\u003c/option\u003e \u003c/select\u003e \u003c/form\u003e 属性说明：\nmultiple：布尔属性，设置后为多选，否则默认单选 disabled：禁用 selected：默认选中该项 value：定义提交时的选项值 label标签 定义： 标签为 input 元素定义标注（标记）。\n说明：\nlabel 元素不会向用户呈现任何特殊效果。 标签的 for 属性值应当与相关元素的 id 属性值相同。 \u003cform action=\"\"\u003e \u003clabel for=\"username\"\u003e用户名\u003c/label\u003e \u003cinput type=\"text\" id=\"username\" name=\"username\"\u003e \u003c/form\u003e textarea多行文本 \u003ctextarea name=\"memo\" id=\"memo\" cols=\"30\" rows=\"10\"\u003e 默认内容 \u003c/textarea\u003e 属性说明：\nname：名称 rows：行数 cols：列数 disabled：禁用 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"前端知识之HTML内容","uri":"/2018/03/05/cnblog_8508917/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 之 索引原理与慢查询优化👈的摘要 浏览目录 一 索引介绍 二 索引类型 三 索引分类 **四 聚合索引和辅助索引 ** 五 测试索引 六 正确使用索引 七 组合索引 八 注意事项 九 查询计划 十 慢日志查询 十一 大数据量分页优化 1. 索引介绍 一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。\n说起加速查询，就不得不提到索引了。\n什么索引:\n简单的说,相当于图书的目录,可以帮助用户快速的找到需要的内容.\n在MySQL中也叫做\"键\"，是存储引擎用于快速找到记录的一种数据结构。能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍.\n2.索引类型 1. BTREE 类型\n就是一种将索引值按一定的算法，存入一个树形的数据结构中.(如下图:)\n系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一磁盘块中的数据会被一次性读取出来，而不是按需读取。InnoDB 存储引擎使用页作为数据读取单位，页是其磁盘管理的最小单位，默认 page 大小是 16kB。\n如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。\nb+树的查找过程\n如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。\n** 注意:1.索引字段要尽量的小,磁盘块可以存储更多的索引.**\n** 2. 索引最左匹配特性**\n** 2. HASH 类型**\n_hash就是一种（key= value）形式的键值对,允许多个key对应相同的value，但不允许一个key对应多个value,为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据. _ hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率.\n假设索引使用hash函数f( )，如下：\nf('Arjen') = 2323 f('Baron') = 7437 f('Peter') = 8784 f('Vadim') = 2458 此时，索引的结构大概如下：\n**3.HASH与BTREE比较:** hash类型的索引：查询单条快，范围查询慢 btree类型的索引：b+树，层数越多，数据量越大,范围查询和随机查询快（innodb默认索引类型） 不同的存储引擎支持的索引类型也不一样 InnoDB 支持事务，支持行级别锁定，支持 Btree、Full-text 等索引，不支持 Hash 索引； MyISAM 不支持事务，支持表级别锁定，支持 Btree、Full-text 等索引，不支持 Hash 索引； Memory 不支持事务，支持表级别锁定，支持 Btree、Hash 等索引，不支持 Full-text 索引； NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 Btree、Full-text 等索引； Archive 不支持事务，支持表级别锁定，不支持 Btree、Hash、Full-text 等索引； 3.索引分类 MySQL中常见索引有：\n普通索引 唯一索引 主键索引 组合索引 全文索引 1.普通索引 普通索引仅有一个功能：加速查询\n#创建表同时添加name字段为普通索引 create table tb1( id int not null auto_increment primary key, name varchar(100) not null, index idx_name(name) ); 创建表+索引\n#单独为表指定普通索引 create index idx_name on tb1(name); 创建索引\ndrop index idx_name on tb1; 删除索引\nshow index from tb1; 查看索引\n2.唯一索引 唯一索引有两个功能：加速查询 和 唯一约束（可含一个null 值）\ncreate table tb2( id int not null auto_increment primary key, name varchar(50) not null, age int not null, unique index idx_age (age) ) 创建表+唯一(unique)索引\ncreate unique index idx_age on tb2(age); 创建unique索引\ndrop unique index idx_age on tb2; 删除unique索引\n3.主键索引 主键有两个功能：加速查询 和 唯一约束（不可含null）\n注意:一个表中最多只能有一个主键索引\n#方式一: create table tb3( id int not null auto_increment primary key, name varchar(50) not null, age int default 0 ); #方式二: create table tb3( id int not null auto_increment, name varchar(50) not null, age int default 0 , primary key(id) ); 创建表 + 创建主键\nalter table tb3 add primary key(id); 创建主键\n#方式一 alter table tb3 drop primary key; #方式二: #如果当前主键为自增主键,则不能直接删除.需要先修改自增属性,再删除 alter table tb3 modify id int ,drop primary key; 删除主键\n4.组合索引 组合索引是将n个列组合成一个索引\n其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = 'alex' and n2 = 666。\ncreate table tb4( id int not null primary key, name varchar(50), age int, sex char(1), index idx_age_sex(age,sex) ); 创建表+组合索引\ncreate index idx_age_sex on tb4(age,sex); 创建组合索引\ndrop index idx_age_sex on tb4; 删除组合索引\n5.全文索引(了解) 全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用 [分词技术] 等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。\n强烈注意 ：MySQL自带的全文索引只能用于数据库引擎为 ** MyISAM** 的数据表，如果是其他数据引擎，则全文索引不会生效。此外，MySQL(5.6版本之前)自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，可以采用一些外部工具来完成.。比如采用Sphinx来做mysql的全文索引工具是一个很好的选择。\n介绍索引创建的原则: 可以创建索引: 1. 字段经常出现在where子句或者连接条件中 2. 字段识别度高 3. 表经常被访问、数据量很大，且通常每次访问的数据量小于记录总量的2%-4% 不用创建索引: 1. 表很小的情况下，没有必要使用索引 2. 不经常在Where后使用的字段 3. 字段的识别度低(比如性别) 4. 如果表数据需要频繁修改，不建议使用索引 5. 如果查询返回记录很多(每次访问的数据量大于记录总数的2%-4%)，不建议使用索引 6. 如果where后含IS NULL /IS NOT NULL/ like '%输入符%'等条件，不建议使用索引。 索引创建的原则\n4.聚合索引和辅助索引 数据库中的B+树索引可以分为聚集索引和辅助索引.\n聚集索引 ：InnoDB表 索引组织表，即表中数据按主键B+树存放，叶子节点直接存放整条数据，每张表只能有一个聚集索引。\n1.当你定义一个主键时，InnnodDB存储引擎则把它当做聚集索引\n2.如果你没有定义一个主键，则InnoDB定位到第一个唯一索引，且该索引的所有列值均飞空的，则将其当做聚集索引。\n3如果表没有主键或合适的唯一索引INNODB会产生一个隐藏的行ID值6字节的行ID聚集索引，\n补充：由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能有一个聚集索引，聚集索引对于主键的排序和范围查找非常有利.\n例子: 比如图书馆新进了一批书。那么这些书需要放到图书馆内。书如何放呢？一般都有一个规则，杂志类的放到101房间，文学类的放到102房间，理工类的放到103房间等等。这些存储的规则决定了每本书应该放到哪里。而这个例子中聚集索引为书的类别。\n辅助索引： （也称非聚集索引）是指叶节点不包含行的全部数据，叶节点除了包含键值之外，还包含一个书签连接，通过该书签再去找相应的行数据。下图显示了InnoDB存储引擎辅助索引和聚集索引的关系：\n从上图中可以看出，辅助索引叶节点存放的是主键值，获得主键值后，再从聚集索引中查找整行数据。举个例子，如果在一颗高度为3的辅助索引中查找数据，首先从辅助索引中获得主键值（3次IO），接着从高度为3的聚集索引中查找以获得整行数据（3次IO），总共需6次IO。一个表上可以存在多个辅助索引。\n例子: 同学如果想去图书馆找一本书，而不知道这本书在哪里？那么这个同学首先应该找的就是 检索室吧。对于要查找一本书来说，在检索室查是一个非常快捷的的途径了吧。但是，在检索室中你查到了该书在XX室XX书架的信息。你的查询结束了吗？没有吧。你仅仅找到了目的书的位置信息，你还要去该位置去取书。\n对于这种方式来说，你需要两个步骤：\n1、查询该记录所在的位置。\n2、通过该位置去取要找的记录。\n总结二者区别:\n相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。\n不同的是：聚集索引叶子结点存放的是一整行的信息,而辅助索引 ** 叶子结点存放的是单个索引列信息.**\n为了阐述非聚集索引写性能问题，我们先来看一个例子： mysql\u003ecreate table t ( id int auto_increment, name varchar(30), primary key (id)); 我们创建了一个表，表的主键是id，id列式自增长的，即当执行插入操作时，id列会自动增长，页中行记录按id顺序存放，不需要随机读取其它页的数据。因此，在这样的情况下（即聚集索引），插入操作效率很高。\n但是，在大部分应用中，很少出现表中只有一个聚集索引的情况，更多情况下，表上会有多个非聚集的（辅助索引）。比如，对于上一张表t，业务上还需要按非唯一的name字段查找，则表定义改为：\nmysql\u003ecreate table t ( id int auto_increment, name varchar(30), primary key (id), key (name)); 这时，除了主键聚合索引外，还产生了一个name列的辅助索引，对于该非聚集索引来说，叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。\n辅助索引写性能问题\n何时使用聚集索引或非聚集索引\n下面的表总结了何时使用聚集索引或非聚集索引（很重要）：\n动作描述\n|\n使用聚集索引\n|\n使用非聚集索引\n---|---|---\n列经常被分组排序\n|\n应\n|\n应\n返回某范围内的数据\n|\n应\n|\n不应\n一个或极少不同值\n|\n不应\n|\n不应\n小数目的不同值\n|\n应\n|\n不应\n大数目的不同值\n|\n不应\n|\n应\n频繁更新的列\n|\n不应\n|\n应\n外键列\n|\n应\n|\n应\n主键列\n|\n应\n|\n应\n频繁修改索引列\n|\n不应\n|\n应\n5.测试索引 1.创建数据\n-- 1.创建表 CREATE TABLE userInfo( id int NOT NULL, name VARCHAR(16) DEFAULT NULL, age int, sex char(1) not null, email varchar(64) default null )ENGINE=MYISAM DEFAULT CHARSET=utf8; 创建表\n注意:MYISAM存储引擎 不产生引擎事务，数据插入速度极快，为方便快速插入测试数据，等我们插完数据，再把存储类型修改为InnoDB\n2.创建存储过程，插入数据\n-- 2.创建存储过程 delimiter$$ CREATE PROCEDURE insert_user_info(IN num INT) BEGIN DECLARE val INT DEFAULT 0; DECLARE n INT DEFAULT 1; -- 循环进行数据插入 WHILE n \u003c= num DO set val = rand()*50; INSERT INTO userInfo(id,name,age,sex,email)values(n,concat('alex',val),rand()*50,if(val%2=0,'女','男'),concat('alex',n,'@qq.com'));\nset n=n+1; end while; END $$ delimiter; 创建存储过程\n3.调用存储过程,插入500万条数据\ncall insert_user_info(5000000); ** 4.此步骤可以忽略。修改引擎为INNODB**\nALTER TABLE userinfo ENGINE=INNODB; 5.测试索引\n在没有索引的前提下测试查询速度 SELECT * FROM userinfo WHERE id = 4567890; 注意:无索引情况,mysql根本就不知道id等于4567890的记录在哪里，只能把数据表从头到尾扫描一遍，此时有多少个磁盘块就需要进行多少IO操作，所以查询速度很慢.\n2.在表中已经存在大量数据的前提下，为某个字段段建立索引，建立速度会很慢\nCREATE INDEX idx_id on userinfo(id); 3.在索引建立完毕后，以该字段为查询条件时，查询速度提升明显\nselect * from userinfo where id = 4567890; 注意:\n** ** mysql先去索引表里根据b+树的搜索原理很快搜索到id为4567890的数据,IO大大降低，因而速度明显提升 我们可以去mysql的data目录下找到该表，可以看到添加索引后该表占用的硬盘空间多了 3.如果使用没有添加索引的字段进行条件查询,速度依旧会很慢(如图:)\n6.正确使用索引 数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。\n即使建立索引，索引也不会生效,例如:\n1. 范围查询(\u003e、\u003e=、\u003c、\u003c=、!= 、between...and) #1. = 等号 select count(*) from userinfo where id = 1000 -- 执行索引,索引效率高 #2. \u003e \u003e= \u003c \u003c= between...and 区间查询 select count(*) from userinfo where id \u003c100; -- 执行索引,区间范围越小,索引效率越高 select count(*) from userinfo where id \u003e100; --执行索引,区间范围越大,索引效率越低 select count(*) from userinfo where id between 10 and 500000 --执行索引,区间范围越大,索引效率越低\n#3. != 不等于 select count(*) from userinfo where id != 1000; -- 索引范围大,索引效率低 2.like '%xx%' 为 name 字段添加索引 create index idx_name on userinfo(name); select count(*) from userinfo where name like '%xxxx%'; -- 全模糊查询,索引效率低\nselect count(*) from userinfo where name like '%xxxx'; -- 以什么结尾模糊查询,索引效率低\n例外: 当like使用以什么开头会索引使用率高 select * from userinfo where name like 'xxxx%'; 3.or select count(*) from userinfo where id = 12334 or email ='xxxx'; -- email不是索引字段,索引此查询全表扫描\n例外：当or条件中有未建立索引的列才失效，以下会走索引 select count(*) from userinfo where id = 12334 or name = 'alex3'; -- id 和 name 都为索引字段时, or条件也会执行索引\n4.使用函数 select count(*) from userinfo where reverse(name) = '5xela'; -- name索引字段,使用函数时,索引失效\n例外:索引字段对应的值可以使用函数,我们可以改为一下形式 select count(*) from userinfo where name = reverse('5xela'); 5.类型不一致 如果列是字符串类型，传入条件是必须用引号引起来，不然... select count(*) from userinfo where name = 454; 6.order by #排序条件为索引，则select字段必须也是索引字段，否则无法命中 select email from userinfo ORDER BY name DESC; -- 无法命中索引 select name from userinfo ORDER BY name DESC; -- 命中索引 特别的:如果对主键排序，则还是速度很快： select * from userinfo order by id desc; 示例\n7.组合索引 组合索引: 是指对表上的多个列组合起来做一个索引.\n组合索引好处:简单的说有两个主要原因：\n\"一个顶三个\"。建了一个(a,b,c)的组合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！\n索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是组合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知 \u003e 组合索引最左匹配原则: 从左往右依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用； select * from mytable where a=3 and b=5 and c=4; abc三个索引都在where条件里面用到了，而且都发挥了作用 select * from mytable where c=4 and b=6 and a=3; 这条语句列出来只想说明 mysql没有那么笨，where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样 select * from mytable where a=3 and c=7; a用到索引，b没有用，所以c是没有用到索引效果的 select * from mytable where a=3 and b\u003e7 and c=3; a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引 select * from mytable where b=3 and c=4; 因为a索引没有使用，所以这里 bc都没有用上索引效果 select * from mytable where a\u003e4 and b=7 and c=9; a用到了 b没有使用，c没有使用 select * from mytable where a=3 order by b; a用到了索引，b在结果排序中也用到了索引的效果 select * from mytable where a=3 order by c; a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了 select * from mytable where b=3 order by a; b没有用到索引，排序中a也没有发挥索引效果 示例\n8.注意事项 1. 避免使用select * 2. count(1)或count(列) 代替 count(*) 3. 创建表时尽量时 char 代替 varchar 4. 表的字段顺序固定长度的字段优先 5. 组合索引代替多个单列索引（经常使用多个条件查询时） 6. 使用连接（JOIN）来代替子查询(Sub-Queries) 7. 不要有超过5个以上的表连接（JOIN） 8. 优先执行那些能够大量减少结果的连接。 9. 连表时注意条件类型需一致 10.索引散列值不适合建索引，例：性别不适合 9.查询计划 explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化\nexplain select count(*) from userinfo where id = 1; 执行计划：让mysql预估执行操作(一般正确) all \u003c index \u003c range \u003c index_merge \u003c ref_or_null \u003c ref \u003c eq_ref \u003c system/const\n慢： explain select * from userinfo where email='alex'; type: ALL(全表扫描) 特别的: select * from userinfo limit 1; 快： explain select * from userinfo where name='alex'; type: ref(走索引) EXPLAIN 参数详解: http://www.cnblogs.com/wangfengming/articles/8275448.html\n10. 慢日志查询 慢查询日志\n将mysql服务器中影响数据库性能的相关SQL语句记录到日志文件，通过对这些特殊的SQL语句分析，改进以达到提高数据库性能的目的。\n慢查询日志参数:\nlong_query_time ： 设定慢查询的阀值，超出设定值的SQL即被记录到慢查询日志，缺省值为10s slow_query_log ： 指定是否开启慢查询日志 log_slow_queries ： 指定是否开启慢查询日志(该参数已经被slow_query_log取代，做兼容性保留) slow_query_log_file ： 指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log log_queries_not_using_indexes: 为使用索引的搜索是否记录 查看 MySQL慢日志信息\n#.查询慢日志配置信息 : show variables like '%query%'; #.修改配置信息 set global slow_query_log = on; 查看不使用索引参数状态:\n# 显示参数　show variables like '%log_queries_not_using_indexes'; # 开启状态 set global log_queries_not_using_indexes = on; 查看慢日志显示的方式\n#查看慢日志记录的方式 show variables like '%log_output%'; #设置慢日志在文件和表中同时记录 set global log_output='FILE,TABLE'; 测试慢查询日志\n#查询时间超过10秒就会记录到慢查询日志中 select sleep(3) FROM user ; #查看表中的日志 select * from mysql.slow_log; 11.大数据量分页优化 执行此段代码:\nselect * from tb1 limit 3000000,10; 优化方案:\n一. 简单粗暴，就是不允许查看这么靠后的数据，比如百度就是这样的\n最多翻到72页就不让你翻了，这种方式就是从业务上解决；\n二.在查询下一页时把上一页的行id作为参数传递给客户端程序，然后sql就改成了\nselect * from tb1 where id\u003e3000000 limit 10; 这条语句执行也是在毫秒级完成的，id\u003e300w其实就是让mysql直接跳到这里了，不用依次在扫描全面所有的行\n如果你的table的主键id是自增的，并且中间没有删除和断点，那么还有一种方式，比如100页的10条数据\nselect * from tb1 where id\u003e100*10 limit 10; 三.最后第三种方法：延迟关联\n我们在来分析一下这条语句为什么慢，慢在哪里。\nselect * from tb1 limit 3000000,10; 玄机就处在这个 * 里面，这个表除了id主键肯定还有其他字段 比如 name age 之类的，因为select * 所以mysql在沿着id主键走的时候要回行拿数据，走一下拿一下数据；\n如果把语句改成\nselect id from tb1 limit 3000000,10; 你会发现时间缩短了一半；然后我们在拿id分别去取10条数据就行了；\n语句就改成这样了：\nselect table.* from tb1 inner join ( select id from tb1 limit 3000000,10 ) as tmp on tmp.id=table.id;\n这三种方法最先考虑第一种 其次第二种，第三种是别无选择\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 之 索引原理与慢查询优化","uri":"/2018/02/28/cnblog_8485214/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】👈的摘要 浏览目录: 1.视图\n2.触发器\n3.存储过程\n4.函数\n5.事物\n6.数据库锁\n7.数据库备份\n1.视图 视图: 是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据\n视图有如下特点;\n1. 视图的列可以来自不同的表，是表的抽象和逻辑意义上建立的新关系。\n2. 视图是由基本表（实表）产生的表（虚表）。\n3. 视图的建立和删除不影响基本表。\n4. 对视图内容的更新（添加、删除和修改）直接影响基本表。\n5. 当视图来自多个基本表时，不允许添加和删除数据,但是能修改数据!\n1.创建视图\ncreate view 视图名称 as sql 查询语句 2.使用视图\nselect * from 视图名称; 3.更新视图\nalter view 视图名称 AS SQL语句 4. 删除视图\ndrop view ren_view; 2.触发器-trigger 触发器 ：监视某种情况，并触发某种操作。\n触发器创建语法四要素：1.监视地点(table)\n2.监视事件(insert/update/delete)\n3.触发时间(after/before)\n4.触发事件(insert/update/delete)\n1.创建触发器语法\ncreate trigger triggerName after/before insert/update/delete on 表名 for each row #这句话是固定的 begin #需要执行的sql语句 end 注意1:after/before: 只能选一个 ,after 表示 后置触发, before 表示前置触发 注意2:insert/update/delete:只能选一个 创建两张表\n#商品表\ncreate table goods(\nid int primary key auto_increment,\nname varchar(20),\nnum int\n);\n|\n#订单表\ncreate table order_table(\noid int primary key auto_increment, gid int, much int );\n---|---\n添加3条商品数据\ninsert into goods(name,num) values('商品1',10),('商品2',10),('商品3',10); 如果我们在没使用触发器之前：假设我们现在卖了3个商品1，我们需要做两件事\n1.往订单表插入一条记录\ninsert into order_table(gid,much) values(1,3); 2.更新商品表商品1的剩余数量\nupdate goods set num=num-3 where id=1; 现在，我们来创建一个触发器：\ncreate trigger tg1 after insert on order_table for each row begin update goods set num = num -3 where id = 1; end 这时候我们只要执行：\ninsert into order_table(gid,much) values(1,3); 会发现商品1的数量变为7了，说明在我们插入一条订单的时候，\n触发器自动帮我们做了更新操作。\n但现在会有一个问题，因为我们触发器里面num和id都是写死的，所以不管我们买哪个商品，最终更新的都是商品1的数量。比如：我们往订单表再插入一条记录：\ninsert into order_table(gid,much) values(2,3); 执行完后会发现商品1的数量变4了，而商品2的数量没变，这样显然不是我们想要的结果。我们需要改改我们之前创建的触发器。\n我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。\n对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。\n所以现在我们可以这样来改我们的触发器:\ncreate trigger tg2 after insert on order_table for each row begin update goods set num = num-new.much where id = new.gid; end 第二个触发器创建完毕，我们先把第一个触发器删掉\ndrop trigger tg1; 再来测试一下，插入一条订单记录：\ninsert into order_table(gid,much) values(2,3) 执行完发现商品2的数量变为7了，现在就对了。\n现在还存在两种情况：\n1.当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？\n对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。\n那我们的触发器就该这样写：\ncreate trigger tg3 afert delete on order_table for each row bigen update goods set num = num + old.much where id = old.gid;-- (注意这边的变化)\nend 2.当用户修改一个订单的数量时，我们触发器修改怎么写?\ncreate trigger tg4 after update on order_table for each row begin update goods set num = num+old.much-new.much where id = old.gid; end 3.存储过程 MySQL数据库在5.0版本后开始支持存储过程，那么什么是存储过程呢？怎么创建、查看和删除存储过程呢？存储过程有什么优点？\n存储过程 ：类似于函数(方法),简单的说存储过程是为了完成某个数据库中的特定功能而编写的语句集合，该语句集包括SQL语句（对数据的增删改查）、条件语句和循环语句等。\n查看现有的存储过程 show procedure status; 2 .删除存储过程\ndrop procedure 存储过程名称; 调用 存储过程 call 存储过程名称(参数入/出类型 参数名 数据类型); 4.创建存储过程\n1.体会封装 #1.体会封装 create procedure p1 () begin select * from account; end 2.SQL 体会参数 create procedure p2(in i int,out n varchar(50)) begin select name into n from account where id = i; end -- 调用 set @name =null; CALL p2(1,@name); select @name; 注意1: mysql中有三种出入参数类型:分别为:1. in 入参类型 2. out 出参类型 3. inout 出入参类型\n注意2: into 关键字 可以 将前面字段的查询结果 执行 给 into 后面的变量.\n3.SQL 体会控制\n#3.SQL 体会控制 create procedure p3(in x int,in c char(1)) begin if c ='d' then select * from account where money \u003ex; else select * from account where money \u003cx; end if; end 4.体会循环:计算1-100累加的和,并且返回计算结果.\n#4.体会循环:计算1-100累加的和,并且返回计算结果. create procedure p4(inout n int) begin DECLARE sum int default 0; -- 设置总和变量,并且指定初始值0 declare i int; -- 声明变量 set i = 0; -- 通过set为变量设置值 while i\u003c=n DO -- 开始循环 set sum = sum +i; set i = i+1; end while; -- 结束循环 select sum; -- 提供结果 set n = sum;--将计算结果提供给 输出变量 n; end; -- 调用: set @n = 100; call p4(@n); select @n; 存储过程优点 ：\n1、存储过程增强了SQL语言灵活性。\n存储过程可以使用控制语句编写，可以完成复杂的判断和较复杂的运算，有很强的灵活性；\n2、减少网络流量，降低了网络负载。\n存储过程在服务器端创建成功后，只需要调用该存储过程即可，而传统的做法是每次都将大量的SQL语句通过网络发送至数据库服务器端然后再执行\n3、存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译。\n一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。\n存储过程缺点 ：\n1、扩展功能不方便\n2、不便于系统后期维护\n4.函数 MySQL提供的内建函数:\n一、数学函数 ROUND(x,y) 返回参数x的四舍五入的有y位小数的值 RAND() 返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。 二、聚合函数(常用于GROUP BY从句的SELECT查询中) AVG(col)返回指定列的平均值 COUNT(col)返回指定列中非NULL值的个数 MIN(col)返回指定列的最小值 MAX(col)返回指定列的最大值 SUM(col)返回指定列的所有值之和 GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果 三、字符串函数 CHAR_LENGTH(str) 返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。 CONCAT(str1,str2,...) 字符串拼接 如有任何一个参数为NULL ，则返回值为 NULL。 CONCAT_WS(separator,str1,str2,...) 字符串拼接（自定义连接符） CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。 CONV(N,from_base,to_base) 进制转换 例如： SELECT CONV('a',16,2); 表示将 a 由16进制转换为2进制字符串表示 FORMAT(X,D) 将数字X 的格式写为'#,###,###.##',以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若 D 为 0, 则返回结果不带有小数点，或不含小数部分。\n例如： SELECT FORMAT(12332.1,4); 结果为： '12,332.1000' INSERT(str,pos,len,newstr) 在str的指定位置插入字符串 pos：要替换位置其实位置 len：替换的长度 newstr：新字符串 特别的： 如果pos超过原字符串长度，则返回原字符串 如果len超过原字符串长度，则由新字符串完全替换 INSTR(str,substr) 返回字符串 str 中子字符串的第一个出现位置。 LEFT(str,len) 返回字符串str 从开始的len位置的子序列字符。 LOWER(str) 变小写 UPPER(str) 变大写 REVERSE(str) 返回字符串 str ，顺序和字符顺序相反。 SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len) , SUBSTRING(str FROM pos FOR len)\n不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。\nmysql\u003e SELECT SUBSTRING('Quadratically',5); -\u003e 'ratically' mysql\u003e SELECT SUBSTRING('foobarbar' FROM 4); -\u003e 'barbar' mysql\u003e SELECT SUBSTRING('Quadratically',5,6); -\u003e 'ratica' mysql\u003e SELECT SUBSTRING('Sakila', -3); -\u003e 'ila' mysql\u003e SELECT SUBSTRING('Sakila', -5, 3); -\u003e 'aki' mysql\u003e SELECT SUBSTRING('Sakila' FROM -4 FOR 2); -\u003e 'ki' 四、日期和时间函数 CURDATE()或CURRENT_DATE() 返回当前的日期 CURTIME()或CURRENT_TIME() 返回当前的时间 DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7) DAYOFMONTH(date) 返回date是一个月的第几天(1~31) DAYOFYEAR(date) 返回date是一年的第几天(1~366) DAYNAME(date) 返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE); FROM_UNIXTIME(ts,fmt) 根据指定的fmt格式，格式化UNIX时间戳ts HOUR(time) 返回time的小时值(0~23) MINUTE(time) 返回time的分钟值(0~59) MONTH(date) 返回date的月份值(1~12) MONTHNAME(date) 返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE); NOW() 返回当前的日期和时间 QUARTER(date) 返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE); WEEK(date) 返回日期date为一年中第几周(0~53) YEAR(date) 返回日期date的年份(1000~9999) 重点: DATE_FORMAT(date,format) 根据format字符串格式化date值 mysql\u003e SELECT DATE_FORMAT('2009-10-04 22:23:00', '%W %M %Y'); -\u003e 'Sunday October 2009' mysql\u003e SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s'); -\u003e '22:23:00' mysql\u003e SELECT DATE_FORMAT('1900-10-04 22:23:00', -\u003e '%D %y %a %d %m %b %j'); -\u003e '4th 00 Thu 04 10 Oct 277' mysql\u003e SELECT DATE_FORMAT('1997-10-04 22:23:00', -\u003e '%H %k %I %r %T %S %w'); -\u003e '22 22 10 10:23:00 PM 22:23:00 00 6' mysql\u003e SELECT DATE_FORMAT('1999-01-01', '%X %V'); -\u003e '1998 52' mysql\u003e SELECT DATE_FORMAT('2006-06-00', '%d'); -\u003e '00' 五、加密函数 MD5() 计算字符串str的MD5校验和 PASSWORD(str) 返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。 六、控制流函数 CASE WHEN[test1] THEN [result1]...ELSE [default] END 如果testN是真，则返回resultN，否则返回default CASE [test] WHEN[val1] THEN [result]...ELSE [default]END 如果test和valN相等，则返回resultN，否则返回default IF(test,t,f) 如果test是真，返回t；否则返回f IFNULL(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2 NULLIF(arg1,arg2) 如果arg1=arg2返回NULL；否则返回arg1 MySQL内建函数\n更多函数: 官方猛击这里\n1、自定义函数\nCREATE FUNCTION fun1(i1 int,i2 int) RETURNS INT //设置返回类型 BEGIN DECLARE sum int default 0; set sum = i1+i2; RETURN(sum); //返回结果 end 2.调用自定义函数\n#直接调用自定义函数 select fun1(1,5); #在sql语句中使用自定义函数 select fun1(参数1,参数2),name from 表名 3.删除自定义函数\nDROP FUNCTION fun_name; 4.函数与存储过程的区别:\n5.事物处理 ** 一、 什么是事务**\n事务就是一段sql 语句的批处理，但是这个批处理是一个原子的，不可分割，要么都执行，要么回滚（rollback）都不执行。\n二、为什么出现这种技术\n为什么要使用事务这个技术呢？ 现在的很多软件都是多用户，多程序，多线程的，对同一个表可能同时有很多人在用，为保持数据的一致性，所以提出了事务的概念。这样很抽象，举个例子：\nA 给B 要划钱，A 的账户-1000元， B 的账户就要+1000元，这两个update 语句必须作为一个整体来执行，不然A 扣钱了，B 没有加钱这种情况很难处理（找出原因）。\n三、事物的特性\n80年代中国人结婚四大件：手表、自行车、缝纫机、收音机（三转一响）。要把事务娶回家同样需要四大件，所以事务很刻薄（ACID），四大件清单：原子性(Atom）、一致性（Consistent）、隔离性（Isolate）、持久性（Durable）。ACID就是数据库事务正确执行的四个特性的缩写。\n原子性 ：要么不谈，要谈就要结婚！ 对于其数据修改，要么全都执行，要么全都不执行。\n一致性 ：恋爱时，什么方式爱我；结婚后还得什么方式爱我； 数据库原来有什么样的约束，事务执行之后还需要存在这样的约束，所有规则都必须应用于事务的修改，以保持所有数据的完整性。\n隔离性 ：闹完洞房后，是俩人的私事。 一个事务不能知道另外一个事务的执行情况（中间状态）\n持久性 ：一旦领了结婚证，无法后悔。 即使出现致命的系统故障也将一直保持。不要告诉我系统说commit成功了，回头电话告诉我，服务器机房断电了，我的事务涉及到的数据修改可能没有进入数据库。\n另外需要注意:\n在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 四、事务控制语句： BEGIN 或 START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT : 保存点,可以把一个事物分割成几部分.在执行ROLLBACK 时 可以指定在什么位置上进行回滚操作. 注意: SET AUTOCOMMIT=0 ;禁止自动提交 和 SET AUTOCOMMIT=1 开启自动提交.\n五、例子: 鲁班转账给后羿\n1.创建表\ncreate table account( id int(50) not null auto_increment primary key, name VARCHAR(50) not null, money DOUBLE(5,2) not NULL ); 2.插入数据\ninsert into account (name,money) values('鲁班',250),('后羿',5000); 3.执行转账\nstart transaction; -- 开启事物 -- 执行sql语句操作 update account set money = money - 500 where id ='1'; update account set money = money+500 where id = '2'; commit; -- 手动提交事物 rollback; -- 回滚事物 -- 查看结果 select * from account; START TRANSACTION ; insert into account (name,money) values('李元芳',1000); SAVEPOINT s1; insert into account (name,money) values('张桂枝',1500); ROLLBACK to s1; 保存点示例\n最后 我们了解几个数据库不得不知的秘密，事务一旦启动，读数据分成两种，被别人读和读别人的数据。被别人读会产生脏数据的问题。读别人的会产生不可重复读和幻读两种情况。\n脏读：读到的数据不是此刻真实的数据。\n脏读就是指,当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。打个比方：\n我的支付宝余额3000元，事务A改为2000，但事务A尚未提交。与此同时，事务B正在读取，并且 \"成功\"读取到余额为2000。随后，事务A由于网络或者IO原因执行失败，回滚成3000元，事务B拿到的值继续运算，就是错误的.\n银行转帐，A给B转1000元，B+1000，这个时候，B就能够读取到。这个时候A还没有减掉1000元，后悔了，没有提交，这个时候B把钱提走了，这不扯吗？ 银行在早年代出现类似情形的bug.\n不可重复读：读了两次，值不一样。\n一个事务对同一行数据重复读取两次，但是却得到了不同的结果。例如，在两次读取的中途，有人对该行数据进行了update操作，并提交，结果就让当前这个事务郁闷了 …\n还是余额3000元，事务A是一个比较长的事务，一开始读取到3000，结果恰好我的水电自动扣款100成功(事务B执行成功)，事务A在最后读取到的余额成了2900元。这就是不可重复读现象。\n幻读：原来没有，现在有了…\n事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。\n事务A正在统计到目前为止的订单数量，一开始读到的是10笔。结果恰好这个时候，家人用此支付宝买了一个家电。等事务A打算提交的时候发现成了11笔。\n事物的 4种 隔离机制:\n读未提交（read uncommitted）：隔离级别是最低，会导致引发脏读，不可重复读，和幻读。 这种隔离级别可以让当前事务读取到其它事物还没有提交的数据。\n2.读已提交（read committed）：可避免脏读情况发生, 但引发 不可重复读，和幻读。\n这种隔离级别可以让当前事务读取到其它事物已经提交的数据。\n3.可重复读取（repeatable read）:MySQL默认的事务隔离级别\n它可以避免脏读、不可重复读的问题，确保同一个事务的多个实例在并发操作数据的时候，会看到相同的数据行。但是理论上，该级别会出现幻读情况，不过MySQL的存储引擎通过多版本并发控制机制解决了该问题，因此该级别是可以避免幻读的。\n4.串行（serializable）：隔离级别最高,可避免以上所有问题, 但会降低可并发性.\n这种隔离级别将事物放在一个队列中，每个事物开始之后，别的事物被挂起。同一个时间点只能有一个事物能操作数据库对象。这种隔离级别对于数据的完整性是最高的，但是同时大大降低了系统的可并发性。\n6.数据锁 **1. ** 锁的基本概念\n当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。\n**2. ** 锁的基本类型\n**** 多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁： 共享锁和排它锁。\n**2.1 ** 共享锁（ Shared Lock ，也叫 S 锁）\n共享锁(S)表示对数据进行读操作。因此多个事务可以同时为一个对象加共享锁。（如果试衣间的门还没被锁上，顾客都能够同时进去参观）\n**2.2 ** 排他锁 (Exclusive Lock ，也叫 X 锁 )\n排他锁(X)表示对数据进行写操作。如果一个事务对 对象加了排他锁，其他事务就不能再给它加任何锁了。(某个顾客把试衣间从里面反锁了，其他顾客想要使用这个试衣间，就只有等待锁从里面给打开了).\n3. 实际开发中常见的两种锁:\n**** 3.1悲观锁 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block(阻塞)直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制.\n注意：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性.因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。关闭自动提交命令为：set autocommit=0;\n设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：\n-- 0.开始事务 set autocommit=0; -- 1.查询出数据信息 select * from ren where p_id='p001' for update; -- 2.修改当前人员信息 update ren set p_name='张1丰' where p_id='p001'; -- 3. 提交事务 -- commit; 在另外的查询页面执行:\nselect * from ren where p_id='p001' for update; 会发现当前查询会进入到等待状态,不会显示出数据,当上面的sql执行完毕提交事物后,当前sql才会显示结果.\n注意1:在使用悲观锁时,如果表中没有指定主键,则会进行锁表操作.\n注意2: 悲观锁的确保了数据的安全性，在数据被操作的时候锁定数据不被访问，但是这样会带来很大的性能问题。因此悲观锁在实际开发中使用是相对比较少的。\n3.2 ** 乐观锁**, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。\n使用乐观锁的两种方式:\n1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现 方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 \"version\" 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数 据。\n代码示例:\nupdate account set name='ygz' , version = version+1 where id = '1' and version = 1;\n2.乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳 （datatime）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。\n两种锁各有优缺点:\n不可认为一种好于另一种，像乐观锁适用于写入比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry(重试)，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适.\n7.数据库备份 mysqldump 命令将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。\nmysqldump命令的工作原理很简单。它先查出需要备份的表的结构，再在文本文件中生成一个CREATE语句。然后，将表中的所有记录转换成一条INSERT语句。然后通过这些语句，就能够创建表并插入数据。\n1. 使用mysqldump实现逻辑备份\n#语法： # mysqldump -h 服务器 -u用户名 -p密码 数据库名 \u003e 备份文件.sql #示例： #单库备份 mysqldump -uroot -p123456 db1 \u003e c:/db1.sql mysqldump -uroot -p123456 db1 table1 table2 \u003e c:/db1-table1-table2.sql #多库备份 mysqldump -uroot -p123456 --databases db1 db2 mysql db3 \u003e c:/db1_db2_mysql_db3.sql\n#备份所有库 mysqldump -uroot -p123456 --all-databases \u003e c:/all.sql --all-databases , - A 导出全部数据库。 mysqldump -uroot -p --all-databases --all-tablespaces , -Y 导出全部表空间。 mysqldump -uroot -p --all-databases --all-tablespaces --no-tablespaces , -y 不导出任何表空间信息。 mysqldump -uroot -p --all-databases --no-tablespaces --add-drop-database 每个数据库创建之前添加drop数据库语句。 mysqldump -uroot -p --all-databases --add-drop-database --add-drop-table 每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用--skip-add-drop-table取消选项) mysqldump -uroot -p --all-databases (默认添加drop语句) mysqldump -uroot -p --all-databases -skip-add-drop-table (取消drop语句) --add-locks 在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。(默认为打开状态，使用--skip-add-locks取消选项) mysqldump -uroot -p --all-databases (默认添加LOCK语句) mysqldump -uroot -p --all-databases -skip-add-locks (取消LOCK语句) --allow-keywords 允许创建是关键词的列名字。这由表名前缀于每个列名做到。 mysqldump -uroot -p --all-databases --allow-keywords --apply-slave-statements 在'CHANGE MASTER'前添加'STOP SLAVE'，并且在导出的最后添加'START SLAVE'。 mysqldump -uroot -p --all-databases --apply-slave-statements --character-sets-dir 字符集文件的目录 mysqldump -uroot -p --all-databases --character-sets- dir=/usr/local/mysql/share/mysql/charsets\n--comments 附加注释信息。默认为打开，可以用--skip-comments取消 mysqldump -uroot -p --all-databases (默认记录注释) mysqldump -uroot -p --all-databases --skip-comments (取消注释) --compatible 导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，\n要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。 mysqldump -uroot -p --all-databases --compatible=ansi --compact 导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：--skip-add-drop-table --skip-add- locks --skip-comments --skip-disable-keys\nmysqldump -uroot -p --all-databases --compact --complete-insert, -c 使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。 mysqldump -uroot -p --all-databases --complete-insert --compress, -C 在客户端和服务器之间启用压缩传递所有信息 mysqldump -uroot -p --all-databases --compress --create-options, -a 在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态) mysqldump -uroot -p --all-databases --databases, -B 导出几个数据库。参数后面所有名字参量都被看作数据库名。 mysqldump -uroot -p --databases test mysql --debug 输出debug信息，用于调试。默认值为：d:t,/tmp/mysqldump.trace mysqldump -uroot -p --all-databases --debug mysqldump -uroot -p --all-databases --debug=\" d:t,/tmp/debug.trace\" --debug-check 检查内存和打开文件使用说明并退出。 mysqldump -uroot -p --all-databases --debug-check --debug-info 输出调试信息并退出 mysqldump -uroot -p --all-databases --debug-info --default-character-set 设置默认字符集，默认值为utf8 mysqldump -uroot -p --all-databases --default-character-set=utf8 --delayed-insert 采用延时插入方式（INSERT DELAYED）导出数据 mysqldump -uroot -p --all-databases --delayed-insert --delete-master-logs master备份后删除日志. 这个参数将自动激活--master-data。 mysqldump -uroot -p --all-databases --delete-master-logs --disable-keys 对于每个表，用/*!40000 ALTER TABLE tbl_name DISABLE KEYS */;和/*!40000 ALTER TABLE tbl_name ENABLE KEYS */;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。\nmysqldump -uroot -p --all-databases --dump-slave 该选项将主的binlog位置和文件名追加到导出数据的文件中(show slave status)。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，会在change前加上注释。该选项将会打开--lock-all-tables，除非--single- transaction被指定。该选项会自动关闭--lock-tables选项。默认值为0。\nmysqldump -uroot -p --all-databases --dump-slave=1 mysqldump -uroot -p --all-databases --dump-slave=2 --master-data 该选项将当前服务器的binlog的位置和文件名追加到输出文件中(show master status)。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE MASTER命令前添加注释信息。该选项将打开--lock-all-tables 选项，除非-- single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的--single- transaction选项）。该选项自动关闭--lock-tables选项。\nmysqldump -uroot -p --host=localhost --all-databases --master-data=1; mysqldump -uroot -p --host=localhost --all-databases --master-data=2; --events, -E 导出事件。 mysqldump -uroot -p --all-databases --events --extended-insert, -e 使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用--skip-extended- insert取消选项。\nmysqldump -uroot -p --all-databases mysqldump -uroot -p --all-databases--skip-extended-insert (取消选项) --fields-terminated-by 导出文件中忽略给定字段。与--tab选项一起使用，不能用于--databases和--all-databases选项 mysqldump -uroot -p test test --tab=\"/home/mysql\" --fields-terminated- by=\"#\"\n--fields-enclosed-by 输出文件中的各个字段用给定字符包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项 mysqldump -uroot -p test test --tab=\"/home/mysql\" --fields-enclosed- by=\"#\"\n--fields-optionally-enclosed-by 输出文件中的各个字段用给定字符选择性包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项 mysqldump -uroot -p test test --tab=\"/home/mysql\" --fields-enclosed- by=\"#\" --fields-optionally-enclosed-by =\"#\"\n--fields-escaped-by 输出文件中的各个字段忽略给定字符。与--tab选项一起使用，不能用于--databases和--all-databases选项 mysqldump -uroot -p mysql user --tab=\"/home/mysql\" --fields-escaped- by=\"#\"\n--flush-logs 开始导出之前刷新日志。 请注意：假如一次导出多个数据库(使用选项--databases或者--all-databases)，将会逐个数据库刷新日志。除使用--lock- all-tables或者--master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用-- lock-all-tables 或者--master-data 和--flush-logs。\nmysqldump -uroot -p --all-databases --flush-logs --flush-privileges 在导出mysql数据库之后，发出一条FLUSH PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。\nmysqldump -uroot -p --all-databases --flush-privileges --force 在导出过程中忽略出现的SQL错误。 mysqldump -uroot -p --all-databases --force --help 显示帮助信息并退出。 mysqldump --help --hex-blob 使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。 mysqldump -uroot -p --all-databases --hex-blob --host, -h 需要导出的主机信息 mysqldump -uroot -p --host=localhost --all-databases --ignore-table 不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：--ignore- table=database.table1 --ignore-table=database.table2 ……\nmysqldump -uroot -p --host=localhost --all-databases --ignore- table=mysql.user\n--include-master-host-port 在--dump-slave产生的'CHANGE MASTER TO..'语句中增加'MASTER_HOST=，MASTER_PORT='\nmysqldump -uroot -p --host=localhost --all-databases --include-master- host-port\n--insert-ignore 在插入行时使用INSERT IGNORE语句. mysqldump -uroot -p --host=localhost --all-databases --insert-ignore --lines-terminated-by 输出文件的每行用给定字符串划分。与--tab选项一起使用，不能用于--databases和--all-databases选项。 mysqldump -uroot -p --host=localhost test test --tab=\"/tmp/mysql\" --lines-terminated-by=\"##\"\n--lock-all-tables, -x 提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭--single-transaction 和--lock- tables 选项。\nmysqldump -uroot -p --host=localhost --all-databases --lock-all-tables --lock-tables, -l 开始导出前，锁定所有表。用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single- transaction是一个更好的选择，因为它根本不需要锁定表。\n请注意当导出多个数据库时，--lock- tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。\nmysqldump -uroot -p --host=localhost --all-databases --lock-tables --log-error 附加警告和错误信息到给定文件 mysqldump -uroot -p --host=localhost --all-databases --log- error=/tmp/mysqldump_error_log.err\n--max_allowed_packet 服务器发送和接受的最大包长度。 mysqldump -uroot -p --host=localhost --all-databases --max_allowed_packet=10240\n--net_buffer_length TCP/IP和socket连接的缓存大小。 mysqldump -uroot -p --host=localhost --all-databases --net_buffer_length=1024\n--no-autocommit 使用autocommit/commit 语句包裹表。 mysqldump -uroot -p --host=localhost --all-databases --no-autocommit --no-create-db, -n 只导出数据，而不添加CREATE DATABASE 语句。 mysqldump -uroot -p --host=localhost --all-databases --no-create-db --no-create-info, -t 只导出数据，而不添加CREATE TABLE 语句。 mysqldump -uroot -p --host=localhost --all-databases --no-create-info --no-data, -d 不导出任何数据，只导出数据库表结构。 mysqldump -uroot -p --host=localhost --all-databases --no-data --no-set-names, -N 等同于--skip-set-charset mysqldump -uroot -p --host=localhost --all-databases --no-set-names --opt 等同于--add-drop-table, --add-locks, --create-options, --quick, --extended-insert, --lock-tables, --set-charset, --disable-keys 该选项默认开启, 可以用 --skip-opt禁用.\nmysqldump -uroot -p --host=localhost --all-databases --opt --order-by-primary 如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。 mysqldump -uroot -p --host=localhost --all-databases --order-by-primary --password, -p 连接数据库密码 --pipe(windows系统可用) 使用命名管道连接mysql mysqldump -uroot -p --host=localhost --all-databases --pipe --port, -P 连接数据库端口号 --protocol 使用的连接协议，包括：tcp, socket, pipe, memory. mysqldump -uroot -p --host=localhost --all-databases --protocol=tcp --quick, -q 不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。 mysqldump -uroot -p --host=localhost --all-databases mysqldump -uroot -p --host=localhost --all-databases --skip-quick --quote-names,-Q 使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。 mysqldump -uroot -p --host=localhost --all-databases mysqldump -uroot -p --host=localhost --all-databases --skip-quote-names --replace 使用REPLACE INTO 取代INSERT INTO. mysqldump -uroot -p --host=localhost --all-databases --replace --result-file, -r 直接输出到指定文件中。该选项应该用在使用回车换行对（\\\\r\\\\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。 mysqldump -uroot -p --host=localhost --all-databases --result- file=/tmp/mysqldump_result_file.txt\n--routines, -R 导出存储过程以及自定义函数。 mysqldump -uroot -p --host=localhost --all-databases --routines --set-charset 添加'SET NAMES default_character_set'到输出文件。默认为打开状态，使用--skip-set- charset关闭选项。\nmysqldump -uroot -p --host=localhost --all-databases mysqldump -uroot -p --host=localhost --all-databases --skip-set-charset --single-transaction 该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和--lock-tables 选项是互斥的，因为LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--quick 选项。\nmysqldump -uroot -p --host=localhost --all-databases --single- transaction\n--dump-date 将导出时间添加到输出文件中。默认为打开状态，使用--skip-dump-date关闭选项。 mysqldump -uroot -p --host=localhost --all-databases mysqldump -uroot -p --host=localhost --all-databases --skip-dump-date --skip-opt 禁用-opt选项. mysqldump -uroot -p --host=localhost --all-databases --skip-opt --socket,-S 指定连接mysql的socket文件位置，默认路径/tmp/mysql.sock mysqldump -uroot -p --host=localhost --all-databases --socket=/tmp/mysqld.sock\n--tab,-T 为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。注意使用--tab不能指定-- databases参数\nmysqldump -uroot -p --host=localhost test test --tab=\"/home/mysql\" --tables 覆盖--databases (-B)参数，指定需要导出的表名，在后面的版本会使用table取代tables。 mysqldump -uroot -p --host=localhost --databases test --tables test --triggers 导出触发器。该选项默认启用，用--skip-triggers禁用它。 mysqldump -uroot -p --host=localhost --all-databases --triggers --tz-utc 在导出顶部设置时区TIME_ZONE='+00:00' ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。 mysqldump -uroot -p --host=localhost --all-databases --tz-utc --user, -u 指定连接的用户名。 --verbose, --v 输出多种平台信息。 --version, -V 输出mysqldump版本信息并退出 --where, -w 只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。 mysqldump -uroot -p --host=localhost --all-databases --where=\" user='root'\"\n--xml, -X 导出XML格式. mysqldump -uroot -p --host=localhost --all-databases --xml --plugin_dir 客户端插件的目录，用于兼容不同的插件版本。 mysqldump -uroot -p --host=localhost --all-databases --plugin_dir=\"/usr/local/lib/plugin\"\n--default_auth 客户端插件默认使用权限。 mysqldump -uroot -p --host=localhost --all-databases --default- auth=\"/usr/local/lib/plugin/\"\n参数说明\n2.恢复逻辑备份\n#在mysql命令下，用source命令导入备份文件： mysql\u003e USE 数据库名; mysql\u003e source 备份文件.sql; 注意：只能在cmd界面下执行source命令，不能在mysql工具里面执行source命令，会报错，因为cmd是直接调用mysql.exe来执行命令的。　可避免脏读情况发生\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】","uri":"/2018/02/28/cnblog_8485209/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 之 数据操作👈的摘要 阅读目录 一 介绍 二 插入数据 INSERT 三 更新操作 UPDATE 四 删除操作 DELETE 五 查询操作 SELECT 一 介绍 在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括\n使用INSERT实现数据的插入 UPDATE实现数据的更新 使用DELETE实现数据的删除 使用SELECT查询数据。 二 插入数据 INSERT #语法一: 按字段进行插入 insert into 表(字段1,字段2 ...) values (值1,值2 ...); #语法二:按字段顺序插入 insert into 表 values (值1,值2 ...); #语法三: 插入多条记录 insert into 表 values (值1,值2 ...) ,(值1,值2 ...) ,(值1,值2 ...); #语法四:插入查询结果 insert into 表(字段1,字段2 ...) select 字段1,字段2 ... from 表; 四种插入数据方式: 一.插入一条数据 insert into student(id,name,age,sex,salary) values(1,'小猪',18,'男',2500); 二.插入多条数据 insert into student(id,name,age,sex,salary) values(1,'小猪',18,'男',2500) ,(2,'小猪2',28,'男',2500),(3,'小猪3',38,'男',2500); 三.直接插入 insert into student values(1,'小猪',18,'男',2500); ps:如果插入的数据个数和位置正好与表的字段个数和位置匹配,则可以省略表名后面的字段定义 四.查询并插入 insert into student(id,name,age) select id,name,age from tb ; ps:从tb表中查询数据并插入到 student表中 代码示例\n三 更新操作 UPDATE #语法一: 更新整表数据 update 表 set 字段1= '值1', 字段2='值2' ... ; #语法二:更新符合条件字段3的数据 update 表 set 字段1= '值1', 字段2='值2' ... where 字段3 = 值3; 方式一: update student set name = '猪猪哥' ; ps: student表中所有的 name 字段 的值 全部被更新为 '猪猪哥' 方式二: update student set name= '猪猪哥' ,age =13 where id = 2; ps: 更新 student 表中 name 和 age 字段的值,并且只更新 id = 2的一条记录 代码示例\n四 删除操作 DELETE #语法一:整表数据删除 delete from 表 ; #语法二:删除符合 where后条件的数据 delete from 表 where 字段1=值1; 方式一: delete from student; ps:删除 student 表中所有的数据,注意:如果有自增主键,主键记录的值不会被删除. 方式二: delete from student where id=1; ps:只删除id 为1的数据. 方式三: truncate student; ps:清空表 代码示例\ntruncate和delete的区别？[面试题]\n1、TRUNCATE 在各种表上无论是大的还是小的都非常快。而DELETE 操作会被表中数据量的大小影响其执行效率. 2、TRUNCATE是一个DDL语言而DELETE是DML语句，向其他所有的DDL语言一样，他将被隐式提交，不能对TRUNCATE使用ROLLBACK命令。 3、TRUNCATE不能触发触发器，DELETE会触发触发器。 4、当表被清空后表和表的索引和自增主键将重新设置成初始大小，而delete则不能。 五 查询操作 SELECT 根据查询功能的不同,我们可以为查询划分为以下几类:\n1.单表查询\n具体操作详见: http://www.cnblogs.com/wangfengming/articles/8064956.html\n2.多表查询\n具体操作详见: http://www.cnblogs.com/wangfengming/articles/8067220.html\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 之 数据操作","uri":"/2018/02/28/cnblog_8485204/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 之 表操作👈的摘要 阅读目录 一 什么是表 二 创建表 三 查询表数据 四 修改表结构 五 删除表 六 复制表 七 数据库存储引擎 八 数据类型 一 什么是表 表(TABLE) 是一种结构化的文件，可用来存储某种特定类型的数据。表中的一条记录有对应的标题，标题 称之为 表的字段。\n二 创建表 CREATE TABLE 表名( 字段名1 类型[(宽度) 约束条件], 字段名2 类型[(宽度) 约束条件], 字段名3 类型[(宽度) 约束条件] )ENGINE=innodb DEFAULT CHARSET utf8; create table student( id int not null auto_increment primary key, name varchar(250) not null, age int not null, sex enum('男','女') not null default '男', salary double(10,2) not null )engine=innodb default charset=utf8; ps: not null :表示此列不能为空 auto_increment :表示自增长,默认每次增长+1 注意:自增长只能添加在主键或者唯一索引字段上 primary key :表示主键(唯一且不为空) engine =innodb :表示指定当前表的存储引擎 default charset utf8 :设置表的默认编码集 创建表\n主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。 create table tb1( nid int not null auto_increment primary key, num int null ) 或 create table tb1( nid int not null, num int not null, primary key(nid,num) ) 主键\n自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列） create table tb1( nid int not null auto_increment primary key, num int null ) 或 create table tb1( nid int not null auto_increment, num int null, index(nid) ) 注意：1、对于自增列，必须是索引（含主键）。 2、对于自增可以设置步长和起始值 show session variables like 'auto_inc%'; set session auto_increment_increment=2; set session auto_increment_offset=10; show global variables like 'auto_inc%'; set global auto_increment_increment=2; set global auto_increment_offset=10; 自增\n三.查询表数据 #查询表数据 select 字段(多个以\",\"间隔) from 表名; 例: select name,sex from student; 或者: select * from student; #查看表结构 desc 表名; 例: desc student; #查看创建表信息 show create table student;　四.修改表结构 #添加表字段 alter table 表名 add 字段名 类型 约束; 例如: alter table student add age int not null default 0 after name; ps: after name 表示在name字段后添加字段 age. #修改表字段 方式一: alter table student modify 字段 varchar(100) null; 方式二: alter table student change 旧字段 新字段 int not null default 0; ps:二者区别: change 可以改变字段名字和属性 modify只能改变字段的属性 #删除表字段 : alter table student drop 字段名; #更新表名称: rename table 旧表名 to 新表名; #添加主键 : alter table student add primary key(字段,\"多个\",\"间隔\"); #移除主键 : alter table student drop primary key; ps:如果主键为自增长,以上方式则不被允许执行,请先去掉主键自增长属性,然后再移除主键 alter table student modify id int not null,drop primary key 更新主键操作\n#添加外键: alter table 从表 add CONSTRAINT fk_test foreign key 从表(字段) REFERENCES 主表(字段); #移除外键: alter table 表 drop foreign key 外键名称; ps:如果外键设置后想修改,那么只能是先删除,再添加 外键更新操作\n#修改默认值 : alter table 表 alter 字段 set default 100; #删除默认值 : alter table 表 alter 字段 drop default; 默认值更新操作\n五.删除表 #删除表 drop table 表名; #清空表 truncate table 表名;　六.复制表 #只复制表结构和表中数据 CREATE TABLE tb2 SELECT * FROM tb1; ps:主键自增/索引/触发器/外键 不会 被复制 #只复制表结构 create table tb2 like tb1; ps: 数据/触发器/外键 不会被复制　七 数据库存储引擎 详情参考: http://www.cnblogs.com/wangfengming/p/7930333.html\n八.数据类型 MySQL支持多种类型，大致可以分为四类：数值、字符串类型、日期/时间和其他类型。\n二进制类型: bit[(M)] 二进制位（101001），m表示二进制位的长度（1-64），默认m＝1 整数类型: tinyint[(m)] [unsigned] [zerofill] 小整数，数据类型用于保存一些范围的整数数值范围： 有符号：-128 ～ 127. 无符号：255 特别的： MySQL中无布尔值，使用tinyint(1)构造。 int[(m)][unsigned][zerofill] 整数，数据类型用于保存一些范围的整数数值范围： 有符号： -2147483648 ～ 2147483647 无符号：4294967295 bigint[(m)][unsigned][zerofill] 大整数，数据类型用于保存一些范围的整数数值范围： 有符号：-9223372036854775808 ～ 9223372036854775807 无符号：18446744073709551615 作用：存储年龄，等级，id，各种号码等 注意：为该类型指定宽度时，仅仅只是指定查询结果的显示宽度，与存储范围无关，所以我们使用默认的就可以了 有符号和无符号的最大数字需要的显示宽度均为10， 而针对有符号的最小值则需要11位才能显示完全，所以int类型默认的显示宽度为11是非常合理的 小数型: decimal[(m[,d])] [unsigned] [zerofill] 准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。 特别的：对于精确数值计算时需要用此类型 decaimal能够存储精确值的原因在于其内部按照字符串存储。 FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] 单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。 有符号：(-3.402823466E+38 to -1.175494351E-38),0,(1.175494351E-38 to 3.402823466E+38) 无符号：0，(1.175 494 351 E-38，3.402 823 466 E+38) **** 数值越大，越不准确 **** DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL] 双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。 有符号：(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0， (2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 无符号：0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) **** 数值越大，越不准确 **** 作用：存储薪资、身高、体重、体质参数等 字符型: char (m) char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。 PS: 即使数据小于m长度，也会占用m长度,但是在查询时，查出的结果会自动删除尾部的空格 特点:定长，简单粗暴，浪费空间，存取速度快 varchar(m) varchar 数据类型用于变长的字符串，可以包含最多达65535个字符(理论上可以,但是实际上在超出21845长度后,mysql会自动帮您转换数据类型为文本类型)。 其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。 PS: varchar类型存储数据的真实内容，例如:如果'ab ',尾部的空格也会被存起来 强调：varchar类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数（1-2Bytes最大表示65535个数字，正好符合mysql对row的最大字节限制，即已经足够使用） 如果真实的数据\u003c255bytes则需要1Bytes的前缀（1Bytes=8bit 2**8最大表示的数字为255） 如果真实的数据\u003e255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535） 特点:变长，精准，节省空间，存取速度慢 sql优化：创建表时，定长的类型往前放，变长的往后放 比如性别 比如地址或描述信息 PS：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。 因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡 text text数据类型用于保存变长的大字符串，可以最多到65535 (2**16 − 1)个字符。 枚举类型(了解): enum An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.) 示例： CREATE TABLE user ( name VARCHAR(40), sex ENUM('男', '女', '未知') ); INSERT INTO user (name, sex) VALUES ('人1','男'), ('人2','女'), ('人3','未知'),('人4','人妖'); PS:人4会插入成功吗?? 集合类型(了解): set A SET column can have a maximum of 64 distinct members. 示例： CREATE TABLE myset (col SET('a', 'b', 'c', 'd')); INSERT INTO myset (col) VALUES ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d'); 日期/时间类型: DATE 日期值 YYYY-MM-DD（1000-01-01/9999-12-31） TIME 时间值或持续时间 HH:MM:SS（'-838:59:59'/'838:59:59'） YEAR 年份值 YYYY（1901/2155） DATETIME 混合日期和时间值 YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59） TIMESTAMP 时间戳 YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时） 作用：存储用户注册时间，文章发布时间，员工入职时间，出生时间，过期时间等 数据类型\n详情参考:\nhttp://www.runoob.com/mysql/mysql-data-types.html http://dev.mysql.com/doc/refman/5.7/en/data-type-overview.html ","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 之 表操作","uri":"/2018/02/28/cnblog_8485190/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 之 库操作👈的摘要 阅读目录: 一 系统数据库 二 数据库操作 三 命名规范 四 用户权限 五.修改密码 六 忘记密码 七 中文乱码问题 一.系统数据库 information_schema ：虚拟库，不占用磁盘空间，存储的是数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等 mysql：核心数据库，里面包含用户、权限、关键字等信息。不可以删除 performance_schema：mysql 5.5版本后添加的新库，主要收集系统性能参数，记录处理查询请求时发生的各种事件、锁等现象 sys : mysql5.7版本新增加的库,通过这个库可以快速的了解系统的元数据信息,可以方便DBA发现数据库的很多信息，解决性能瓶颈都提供了巨大帮助 二.数据库操作 1.创建数据库\n#语法: CREATE DATABASE db_name charset utf8; #创建一个名字为 db_name 的数据库,并指定当前库的编码集为utf8 CREATE DATABASE db_name charset utf8; 示例\n2.查看数据库\n#查询当前用户下所有数据库 show databases; #查看创建数据库的信息 show create database db_name; #查询当前操作所在的数据库名称 select database(); 3.选择数据库\nUSE db_name; 4.删除数据库\nDROP DATABASE db_name; 三.命名规范 可以由字母、数字、下划线、＠、＃、＄ 区分大小写 唯一性 不能使用关键字如: CREATE SELECT 不能单独使用数字 最长128位 四.用户权限 1.用户管理\n创建用户 create user '用户名'@'IP地址' identified by '密码'; 删除用户 drop user '用户名'@'IP地址'; 修改用户 rename user '用户名'@'IP地址'; to '新用户名'@'IP地址'; 2.授权管理\nshow grants for '用户'@'IP地址' -- 查看权限 grant 权限 on 数据库.表 to '用户'@'IP地址' -- 授权 revoke 权限 on 数据库.表 from '用户'@'IP地址' -- 取消权限 #创建新用户 create user 'alex'@'localhost' identified '123456'; #授权方式一:为alex授权 db1数据库下的所有表的 查询.更新.修改权限 grant select,update,delete on db1.* to 'alex'@'localhost'; #授权方式二:为alex 授权 所有库的所有权限(除grant权限外) grant all privileges on *.* to 'alex'@'localhost'; #刷新用户权限 flush privileges; 创建用户及授权例子\nall privileges 除grant外的所有权限 select 仅查权限 select,insert 查和插入权限 ... usage 无访问权限 alter 使用alter table alter routine 使用alter procedure和drop procedure create 使用create table create routine 使用create procedure create temporary tables 使用create temporary tables create user 使用create user、drop user、rename user和revoke all privileges create view 使用create view delete 使用delete drop 使用drop table execute 使用call和存储过程 file 使用select into outfile 和 load data infile grant option 使用grant 和 revoke index 使用index insert 使用insert lock tables 使用lock table process 使用show full processlist select 使用select show databases 使用show databases show view 使用show view update 使用update reload 使用flush shutdown 使用mysqladmin shutdown(关闭MySQL) super 使用change master、kill、logs、purge、master和set global。还允许mysqladmin调试登陆 replication client 服务器位置的访问 replication slave 由复制从属使用 权限列表\n五.修改密码 方式一: mysqladmin 命令\nmysqladmin -u用户名 -p密码 password 新密码 方式二 : 直接设置用户密码\nset password for '用户名'@'IP' = password('新密码'); flush privileges; 方式三: 修改mysql库下的user表\n5.7版本修改密码方式: update mysql.user set authentication_string=password('新密码') where user= '用户名' flush privileges; -- 刷新权限 5.6 版本 update mysql.user set password = password('新密码') where user= '用户名' flush privileges; -- 刷新权限 六.忘记密码 在忘记root密码的时候，可以这样: #1.首先打开cmd 窗口,关闭mysql服务 net stop mysql #2.然后跳过权限检查,启动mysql,输入命令 mysqld --skip-grant-tables #3.重新打开一个新的cmd窗口,启动客户端(已跳过权限检查,可以直接登录) mysql #4.直接进来,修改密码 update mysql.user set authentication_string=password('123456') where user='root'; #5. 刷新权限 flush privileges; 七.中文乱码问题 1.查询字符编码\nSHOW VARIABLES LIKE 'char%'; 2.制服乱码\n#修改方法: #1. 创建my.ini文件,放在mysql根路径下 #2. 在该文件中添加以下内容即可: #3.添加此文件后需要重新启动服务,以保证此文件生效 ------------------------------------------------------------ [client] default-character-set=utf8 [mysql] #设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 #允许最大连接数 max_connections=200 #服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 #创建新表时将使用的默认存储引擎 default-storage-engine=INNODB #解决mysql在执行sql语句后出现1055错误,sql_mode = only_full_group_by不相容 sql_mode='NO_ENGINE_SUBSTITUTION' 乱码已死\n注意:如果使用的是mysql5.7版本,则需要创建my.ini文件,5.7版本以前数据库自带my,ini文件,直接改动编码即可.\n目前最稳定与常用的数据库版本为(5.6版本与5.5版本)\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 之 库操作","uri":"/2018/02/28/cnblog_8485174/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 之 基本概念👈的摘要 ****一. 概述(了解)\n** 二. 数据库特点(了解)**\n** 三. 数据库分类**\n** 四. MySQL介绍**\n** 五. 下载及安装**\n** 六. 啥是SQL?**\n一.概述 数据库(Database，简称DB)\n数据库技术是计算机应用领域中非常重要的技术，它产生于 20世纪60年代末，是数据管理的最新技术，也是软件技术的一个重要分支。\n简单的说， 数据库 就是一个存放数据的仓库，这个仓库是按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织、存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。更简单的形象理解，数据库和我们生活中存放杂物的仓库性质一样，区别只是存放的东西不同。\n数据库表(table)\n数据表是关系数据库中一个非常重要的对象，是其它对象的基础，也是一系列 二维数组的集合，用来存储、操作数据的逻辑结构。根据信息的分类情况。 一个数据库中可能包含若干个数据表，每张表是由行和列组成，记录一条数据,数据表就增加一行，每一列是由字段名和字段数据集合组成，列被称之为字段， 每一列还有自己的多个属性，例如是否允许为空、默认值、长度、类型、存储编码、注释等.例如 ** 数据(data)**\n存储在表中的 信息就叫做数据.\n数据库系统有3个主要的组成部分\n1.数据库（Database System）：用于存储数据的地方。\n2.数据库管理系统（Database Management System，DBMS）：用户管理数据库的软件。\n3.数据库应用程序（Database Application）：为了提高数据库系统的处理能力所使用的管理数据库的软件补充。\n数据库的发展史(五个阶段)\n1.文件系统 数据库系统的萌芽阶段,通过文件来存取数据. 文件系统是数据库系统的萌芽阶段，出现在上世纪五六十年代，可以提供简单的数据存取功能，但无法提供完整、统一的数据管理功能，例如复杂查询等。所以在管理较少、较简单的数据或者只是用来存取简单数据，没有复杂操作的情况下，会使用文件系统 2.层次型数据库 数据库系统真正开始阶段,数据的存储形式类似树形结构,所以也叫树型数据库. 3.网状数据库 数据的存储形式类似网状结构. 从二十世纪六十年代开始，第一代数据库系统（层次模型数据库系统、网状模型数据库系统）相继问世，它们为统一管理和共享数据提供了有力的支撑 在这个阶段，网状模型数据库由于它的复杂、专用性，没有被广泛使用。而在层次模型数据库中，IBM公司的IMS（Information Management System，信息管理系统）层次模型数据库系统则得到了极大的发展，一度成为最大的数据库管理系统，拥有巨大的客户群 4.关系型数据库 二十世纪七十年代初，关系型数据库系统开始走上历史舞台，并一直保持着蓬勃的生命力.关系型数据库系统使用结构化查询语言（Structured Query Language，SQL）作为数据库定义语言DDL和数据库操作语言DML 5.面向对象数据库 把面向对象的方法和数据库技术结合起来，可以使数据库系统的分析、设计最大程度地与人们对客观世界的认识相一致，并且能够有效的为面向对象程序提供更好的数据库支撑 二.数据库的特点 ⑴ 实现数据共享\n数据共享包含所有用户可同时存取数据库中的数据，也包括用户可以用各种方式通过接口使用数据库，并提供数据共享。\n⑵ 减少数据的冗余度\n同文件系统相比，由于数据库实现了数据共享，从而避免了用户各自建立应用文件。减少了大量重复数据，减少了数据冗余，维护了数据的一致性。\n****⑶ **** 数据一致性和可维护性，以确保数据的安全性和可靠性\n主要包括：①安全性控制：以防止数据丢失、错误更新和越权使用；\n②完整性控制：保证数据的正确性、有效性和相容性；\n③并发控制：使在同一时间周期内，允许对数据实现多路存取，又能防止用户之间的不正常交互作用。\n****⑷ **** 故障恢复\n由数据库管理系统提供一套方法，可及时发现故障和修复故障，从而防止数据被破坏。数据库系统能尽快恢复数据库系统运行时出现的故障，可能是物理上或是逻辑上的错误。比如对系统的误操作造成的数据错误等。\n三.数据库分类 在当今的互联网中，最常用的数据库模型主要是两种，即 关系型数据库 和 非关系型数据 库。\n1 关系型数据库介绍\n(1) 关系型数据库 : 是把复杂的数据结构归结为简单的 二元关系（即二维表格形式）。\n(2) 目前主流的关系型数据库:MySQL、Oracle 、 Sql server、DB2 。。。\nOracle 是世界上使用最广泛的数据库,上世纪末随着网络浪潮的到来,Oracle推出9i这个版本,i表示internet，全面支持网络引用。10g,g是grid网格，是Oracle公司为迎接\"网格计算\"时代的来临而提供的数据库解决方案。 MySQL是一个开源的、免费的关系型数据库,。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。 SQL Server 微软公司的关系型数据库,一般.NET平台会将其作为首选. DB2是IBM出品的一系列关系型数据库管理系统，分别在不同的操作系统平台上服务。 主流数据库介绍\n2 非关系型数据库介绍 (1)非关系型数据库诞生背景\n**非关系型数据库** 也被成为NoSQL数据库，NOSQL的本意是\"Not Only SQL\".而不是\"No SQL\"的意思，因此，NoSQL的产生并不是要彻底地否定非关系型数据库，而是作为传统关系型数据库的一个有效补充。NOSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能。 随着互联网Web2.0网站的兴起，传统的关系型数据库在应付web2,0网站，特别是对于规模日益扩大的海量数据，超大规模和高并发的微博、微信、SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题。 _ 例如：传统的关系型数据库IO瓶颈、性能瓶颈都难以有效突破，于是出现了大批针对特定场景，以高性能和使用便利为目的功能特异化的数据库产品。NOSQL（非关系型）类的数据就是在这样的情景下诞生并得到了非常迅速的发展 _\n(2) NOSQL非关系型数据库小结： 1、NOSQL不是否定关系数据库，而是作为关系数据库的一个重要补充\n2、NOSQL为了高性能、高并发而生，但是要求对数据一致性要求不能高\n3、NOSQL典型产品memcached （纯内存,k-v），redis（持久化缓存,k-v），mongodb（文档的数据库,xml-json)\n四.MySQL介绍 MySQL 数据库:是互联网领域里一款最重要的，深受广大用户欢迎的开源关系型数据库软件之一、由瑞典MySQL AB公司开发与维护。2008年。MySQL AB公司被SUN公司收购，2009年，SUN公司又被传统数据数据库领域大佬甲骨文（oracle）公司收购，因此，MySQL数据库软件目前属于Oracle公司，成为传统数据库领域老大的又一个数据库产品，甲骨文公司收购MySQL后，使得自身在商业数据库与开源软件领域市场占有份额都跃居第一的位置，这样的格局，引起了很多人的担忧，这种担忧直接导致后来的Mysql分支数据库MariaDB的诞生于发展。\nMySQL 发展历史\n1985 年，瑞典的几位志同道合小伙子(David Axmark、Allan Larsson 和Monty Widenius) 成立了一家公司，这就是MySQL AB 的前身。 1990年，TcX公司的客户中开始有人要求为他的API提供SQL支持。当时有人提议直接使用商用数据库，但是Monty觉得商用数据库的速度难以令人满意。于是，他直接借助于mSQL的代码，将它集成到自己的存储引擎中。令人失望的是，效果并不太令人满意，于是，Monty雄心大起，决心自己重写一个SQL支持。 1996年，MySQL 1.0发布，它只面向一小拨人，相当于内部发布。 1996年10月，MySQL 3.11.1发布(MySQL没有2.x版本)，最开始只提供Solaris下的二进制版本。一个月后，Linux版本出现了。 1999～2000年，MySQL AB公司在瑞典成立。Monty雇了几个人与Sleepycat合作，开发出了Berkeley DB引擎, 因为BDB支持事务处理，所以MySQL从此开始支持事务处理了。 2003年12月，MySQL 5.0版本发布，提供了视图、存储过程等功能。 2008年1月16日，Sun（太阳微系统）正式收购MySQL。 2009年4月20日，甲骨文公司宣布以每股9.50美元，74亿美元的总额收购Sun电脑公司。 2010年12月，MySQL 5.5发布，其主要新特性包括半同步的复制及对SIGNAL/RESIGNAL的异常处理功能的支持，最重要的是InnoDB存储引擎终于变为当前MySQL的默认存储引擎。 2013年6月18日，甲骨文公司修改MySQL授权协议，移除了GPL。但随后有消息称这是一个bug。 为什么选择MySQL数据库?\n（1） MySQL性能卓越、服务稳定，很少出现异常宕机\n（2） MySQL开放源代码且无版权制约，自主性及使用成本低\n（3） MySQL历史悠久，社区及用户活跃，遇到问题可以解决\n（4） MySQL软件体积小，安装使用简单，并且易于维护，安装及维护成本低\n（5） MySQL品牌口碑效应，使得企业无需考虑就直接用\n（6） MySQL支持多用操作系统，提供多种API接口，支持多用开发语言，特别对流行的语言有很好的支持\nMariaDB 介绍 :\n出现在2009年. MAriaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用GPL授权许可。开发这个MariaDB的原因之一是：甲骨文公司收购了MySQL后，MySQL有闭源的潜在风险，因此MySQL开源社区采用分支的方式来避开这个风险。点击查看详情 MariaDB默认的存储引擎是Maria，不是MyISAM。Maria可以支持事务，但是默认情况下没有打开事务支持，因为事务支持对性能会有影响。可以通过以下语句，转换为支持事务的Maria引擎。ALTER TABLE tablename ENGINE=MARIA TRANSACTIONAL=1;\n五.下载及安装 a：官网下载mysql安装程序 b：安装mysql服务端 c：安装mysql客户端 d：客户端连接服务端 e：通过客户端向服务器发送命令，执行对数据库文件的增删改差操作。　Windows版安装\n# 1.下载：MySQL Community Server 5.7.20 https://dev.mysql.com/downloads/mysql/ #2.解压 将官网下载的解压包 解压到指定目录（例如 D：//mysql-5.7.20-winx64） #3.添加环境变量 【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --\u003e 【将MySQL的bin目录路径追加到变值值中，用 ； 分割】 C:\\Program Files (x86)\\Parallels\\Parallels Tools\\Applications;d:\\mysql-5.7.16-winx64\\bin #4.初始化 mysqld --initialize-insecure #5.启动mysql服务 mysqld #6.连接mysql服务 mysql -uroot -p 回车,有密码输入密码,没有继续回车 解压方式安装 解压方式安装\nps:制作服务必须使用全路径方式 # 制作MySQL的Windows服务，在终端执行此命令： \"c:\\mysql-5.7.16-winx64\\bin\\mysqld\" --install # 移除MySQL的Windows服务，在终端执行此命令： \"c:\\mysql-5.7.16-winx64\\bin\\mysqld\" --remove' # 启动MySQL服务 net start mysql(后面不加分号) # 关闭MySQL服务 net stop mysql(后面不加分号) 制作服务\n在启动mysql服务后，打开windows任务管理器，会有一个名为mysqld.exe的进程运行，所以mysqld.exe是MySQL服务器程序。\n退出登录：quit 或 exit 或 \\q ;\nnext next next .... ps:mis方式安装,会安装的东西比较全,使用起来比较方便 推荐:mis方式安装\nLinux版本\n1、下载地址：http://dev.mysql.com/downloads/mysql/5.6.html#downloads 也可以直接复制64位的下载地址，通过命令下载：wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz 2、解压 #解压 tar -zxvf mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz #复制解压后的mysql目录 cp -r mysql-5.6.33-linux-glibc2.5-x86_64 /usr/local/mysql 3、添加用户组和用户 #添加用户组 groupadd mysql #添加用户mysql 到用户组mysql useradd -g mysql mysql 4、安装 cd /usr/local/mysql/\u003cbr\u003emkdir ./data/mysql chown -R mysql:mysql ./ ./scripts/mysql_install_db --user=mysql --datadir=/usr/local/mysql/data/mysql cp support-files/mysql.server /etc/init.d/mysqld chmod 755 /etc/init.d/mysqld cp support-files/my-default.cnf /etc/my.cnf #修改启动脚本 vi /etc/init.d/mysqld #修改项： basedir=/usr/local/mysql/ datadir=/usr/local/mysql/data/mysql #启动服务 service mysqld start #测试连接 ./mysql/bin/mysql -uroot #加入环境变量，编辑 /etc/profile，这样可以在任何地方用mysql命令了 export PATH=$PATH:/usr/local/mysql//bin\u003cbr\u003esource /etc/profile #启动mysql service mysqld start #关闭mysql service mysqld stop #查看运行状态 service mysqld status 5、错误 5.1 sqlyog连接时，报1130错误，是由于没有给远程连接的用户权限问题 解决1:更改 'mysql'数据库'user'表'host'项，从'localhost'改成'%'。 use mysql; select 'host' from user where user='root'; update user set host = '%' where user ='root'; flush privileges; 解决2：直接授权 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'youpassword' WITH GRANT OPTION; 5.2 安装时的一些错误 -bash: ./scripts/mysql_install_db: /usr/bin/perl: bad interpreter: 没有那个文件或目录 解决： yum -y install perl perl-devel Installing MySQL system tables..../bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory 解决：yum -y install libaio-devel linux版本安装\n参考博客:http://www.cnblogs.com/wangfengming/articles/7880595.html\n六.啥是SQL? 上面咱们介绍过数据库的组成部分,其中数据库管理系统可以接收一些命令，对数据文件进行添加、删除、修改、查询等操作。那么这些命令就是 SQL .\nSQL：(Structured Query Language)是 结构化查询语 言缩写。是一门专门与数据库管理系统打交道的语言。\nSQL语言:是关系型数据库的标准语言, 其主要用于存取数据，查询数据，更新数据和管理数据库系统等操作。\n具体可以把SQL分为4个部分:\n数据控制语言 ( DCL) ： 主要用于控制用户的访问权限。其中GRANT语句用于给用户增加权限，REVOKE语句用于收回用户的权限\n数据定义语言（DDL） ：DROP、CREATE、ALTER等语句；数据库定义语言。主要用于定义数据库，表，视图，索引和触发器等。CREATE语句主要用于创建数据库，创建表，创建视图。ALTER语句主要用于修改表的定义，修改视图的定义。DROP语句主要用于删除数据库，删除表和删除视图等。\n数据操作语言（DML） ：INSERT、UPDATE、DELETE语句；数据库操作语言。主要用于插入数据，更新数据，删除数据。INSERT语句用于插入数据，UPDATE语句用于更新数据，DELETE语句用于删除数据.\n数据查询语言（DQL） ：SELECT语句。主要用于查询数据。\n#1. 操作文件夹 增：create database db1 charset utf8; 查：show databases; 改：alter database db1 charset latin1; 删除: drop database db1; #2. 操作文件 先切换到文件夹下：use db1 增：create table t1(id int,name char); 查：show tables 改：alter table t1 modify name char(3); alter table t1 change name name1 char(2); 删：drop table t1; #3. 操作文件中的内容/记录 增：insert into t1 values(1,'egon1'),(2,'egon2'),(3,'egon3'); 查：select * from t1; 改：update t1 set name='sb' where id=2; 删：delete from t1 where id=1; 清空表： delete from t1; #如果有自增id，新增的数据，仍然是以删除前的最后一样作为起始。 truncate table t1;数据量大，删除速度比上一条快，且直接从零开始， auto_increment 表示：自增 primary key 表示：约束（不能重复且不能为空）；加速查找 ....\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 之 基本概念","uri":"/2018/02/28/cnblog_8485161/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 练习2👈的摘要 1. 表关系 ** **\n注意:创建表时,根据合理性设置字段的长度和类型.\nCREATE TABLE `person` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) NOT NULL, `age` int(10) DEFAULT NULL, `salary` int(10) DEFAULT NULL, `leader` char(1) NOT NULL DEFAULT '0', `menpai` varchar(32) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; 创建部门表:\nCREATE TABLE `dept` ( `did` int(11) NOT NULL AUTO_INCREMENT, `dname` varchar(32) NOT NULL, `address` varchar(32) NOT NULL, PRIMARY KEY (`did`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; INSERT INTO dept VALUES(1,'武当','湖北'); INSERT INTO dept VALUES(2,'华山','陕西'); INSERT INTO dept VALUES(3,'嵩山','河南'); INSERT INTO dept VALUES(4,'日月神教','黑木崖'); 2.下面:开始你的表演 1.查询所有人员信息\nSELECT * FROM person; 2.只查询人员的姓名和年龄\nSELECT `name`,age FROM person; 3.查询年龄为20岁的有哪些人员\nSELECT `name`,age FROM person WHERE age=20; 4.查询60岁以下的人员有哪些人员\nSELECT `name`,age FROM person WHERE age\u003c60; 5.查询50岁以上并且工资大于8000的人员有哪些\nSELECT `name` FROM person WHERE age\u003e50 AND salary\u003e8000; 6.查询姓[张]的人员有哪些\nSELECT `name` FROM person WHERE `name` LIKE '张%'; 7.查询哪些人员属于 武当/华山/嵩山\nSELECT `name` FROM person WHERE menpai='武当' or menpai='华山' or menpai='嵩山'; 8.查询工资在 5000-8900 的人员有哪些\nSELECT `name` FROM person WHERE salary\u003e5000 and salary\u003c8900; 9.查询所有人员,要求按工资倒序排列\nSELECT * FROM person ORDER BY salary DESC; 10.查询令狐冲的领导人是谁\nSELECT * FROM person WHERE menpai='华山' AND leader=0; 11.查询人员表中最高工资是多少\nSELECT `name`,MAX(salary) FROM person; 12.查询人员表中最低工资是多少\nSELECT `name`,MIN(salary) FROM person; 13.查询所有人员的平均工资是多少\nSELECT ROUND(AVG(salary),2) FROM person; 14.查询所有人员的工资总和是多少\nSELECT sum(salary) FROM person; 15.查询目前有多少个人员\nSELECT COUNT(id) FROM person; 16.查询当前武林中有哪些门派\nSELECT menpai FROM person GROUP BY menpai; 17.查询 武当派 最高工资是谁\nSELECT `name`,MAX(salary) FROM person WHERE menpai='武当'; 18.查询各门派的平均工资是多少\n19.查询当前武林中有哪些门派的平均工资大于8000 并按工资倒序排列\n20.查询当前人员表的中的第3条数据到第7条数据\n21.查询哪些门派下没有弟子\n22.查询武当派下有哪些弟子\n23.查询各门派的工资总和按倒序/正序排列\n24.删除工资重复的人员,请保留年龄最大的一个人\n25.将武当派 张三丰 修改为 张丰\n26.将所有门派大哥工资上调10%,但不包括Alex.\n27.查看哪些人员的门派已登记地理位置.\n28.查询所有人员门派的位置信息,不存在位置信息则不显示\n29.在湖北省内的门派中的人员有哪些.\n30.在陕西省内门派中的工资小于5000,年龄大于20岁的人员有哪些,按主键倒序排列\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 练习2","uri":"/2018/02/27/cnblog_8480101/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 练习👈的摘要 1.创建留言数据库: messagedb;\nmysql\u003e create database messagedb charset = utf8; 2.在 messagedb 数据库中创建留言表message，结构如下:\n表名\n|\nmessage\n|\n留言信息表\n---|---|---\n序号\n|\n字段名称\n|\n字段说明\n|\n类型\n|\n属性\n|\n备注\n1\n|\nid\n|\n编号\n|\nint\n|\n非空\n|\n主键,自增1\n2\n|\ntitle\n|\n标题\n|\nvarchar(32)\n|\n非空\n|\n3\n|\nauthor\n|\n作者\n|\nvarchar(16)\n|\n可以空\n|\n4\n|\naddtime\n|\n留言时间\n|\ndatetime\n|\n非空\n|\n5\n|\ncontent\n|\n留言内容\n|\ntext\n|\n非空\n|\n6\n|\nisdelete\n|\n是否删除\n|\nchar(1)\n|\n非空\n|\n默认值 0\nCREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(32) NOT NULL, `author` varchar(16) DEFAULT NULL, `addtime` datetime DEFAULT NULL, `content` text, `status` char(1) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; 3.在留言表最后添加一列状态（status char(1) 默认值为0）\n4.修改留言表author的默认值为 'youku',设为非空\n5.删除message表中的isdelete字段\n6.为留言表添加 \u003e5条测试数据\nINSERT INTO `message` VALUES ('1', '介绍', '大雄', '2017-02-14 09:59:37', '哥不是一匹好马，但也不是一头普通的毛驴', '0'); INSERT INTO `message` VALUES ('2', '叮当猫', '熊熊', '2016-02-16 09:59:44', '你牙缝里有韭菜，扣出来贼哥吃', '0'); INSERT INTO `message` VALUES ('3', '花花', '苗苗', '2017-05-28 09:59:52', '苗苗问花花:卖萌是褒义词还是贬义词？', '0'); INSERT INTO `message` VALUES ('4', '霞哥', '大雄', '2017-08-29 09:59:57', '斗战色佛', '0'); INSERT INTO `message` VALUES ('5', '晨晨', '逗比', '2010-06-22 10:00:03', '你笑起来像一朵菊花,菊花残，man腚伤', '0'); **** 7. 要求将id值大于3的信息中author字段值改为admin\nupdate message set author= 'admin' where id\u003e3; 8. 删除id号为4的数据。\ndelete from message where id=4; 为留言表添加 \u003e15条测试数据，要求分三个用户添加\nINSERT INTO `message` VALUES ('6', '晨晨', '逗比', '2010-06-22 10:00:03', '你笑起来像一朵菊花,菊花残，man腚伤', '1'); 查询所有留言信息\nselect * from message; 查询某一用户的留言信息。\nselect * from message where author='用户名'; 查询所有数据，按时间降序排序。\nselect * from message order by addtime desc; 获取id在2到6之间的留言信息，并按时间降序排序\nselect * from message where id\u003e2 and id\u003c6 order by addtime desc; 统计每个用户留了多少条留言，并对数量按从小到大排序。\nselect author,COUNT(id) as '留言条数' FROM message GROUP BY author ORDER BY COUNT(id) ASC; 将id为8、9的两条数据的作者改为 'doudou'.\nupdate message set author='doudou' where id=8 or id=9; 取出最新的三条留言。\nselect * from message order by addtime desc limit 3; 查询留言者中包含 \"a\"字母的留言信息，并按留言时间从小到大排序\nselect * from message where author like '%a%' order by 'addtime' desc; 删除 \"作者\"重复的数据,并保留id最大的一个作者\ndelete from message where author in( select author from (select author from message group by author having count(1)\u003e1) a ) and id not in( select id from (select max(id) id from message group by author having count(1)\u003e1) b )\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 练习","uri":"/2018/02/27/cnblog_8479171/"},{"categories":["笔记","博客园"],"content":"这是👉MySQL 环境搭建之解压方式安装👈的摘要 一 .MySQL服务 安装 1.下载： http://dev.mysql.com/downloads/mysql 2.安装：\n将下载的mysql-5.7.21-winx64压缩包解压后的整个目录放在自己喜欢的位置，我的放在C:\\Users\\wilson\\Software\\目录下\n3. 初始化操作\n解压后进入当前文件夹的bin目录下,可以看到很多执行文件,在该目录下执行初始化操作：\nmysqld --initialize -insecure ps:进行初始化操作,当前操作会在mysql-5.7.20-winx64目录下创建一个data文件夹 添加环境变量\n【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --\u003e 【将MySQL的bin目录路径追加到变值值中，用 ； 分割】\n如此一来，以后再启动服务并连接时，仅需：\n# 启动MySQL服务，在终端输入 mysqld # 连接MySQL服务，在终端输入： mysql -u root -p 效果如下:\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"MySQL 环境搭建之解压方式安装","uri":"/2018/02/26/cnblog_8474477/"},{"categories":["笔记","博客园"],"content":"这是👉python3 下载必应每日壁纸（三）👈的摘要 在第二篇文章时,python3 下载必应每日壁纸（二）已经设置过自动任务,但是有一点不友好,\n就是在自动计划任务在执行的过程中会有命令行窗口,so在写个把它隐藏起来\n写个vbs脚本,隐藏命令行窗口\n'down bing wallpaper '下载每日必应壁纸,隐藏命令行,参数为1显示命令行 DIM objShell set objShell=wscript.createObject(\"wscript.shell\") iReturn=objShell.Run(\"cmd.exe /C C:\\Python\\Python36\\python3.exe D:\\wilson\\Pictures\\DesktopBackGround\\BingWallpaper.py\", 0, TRUE) 然后,在计划任务中,直接执行vbs脚本即可!\n完美隐藏命令行\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python3 下载必应每日壁纸（三）","uri":"/2018/02/26/cnblog_8474376/"},{"categories":["笔记","博客园"],"content":"这是👉python 生产者与消费者模式👈的摘要 生产者与消费者模式 1. 队列 先进先出\n2. 栈 先进后出\nPython的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么就做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。\n用FIFO队列实现上述生产者与消费者问题的代码如下：\n​\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import threading import time from queue import Queue class Producer(threading.Thread): def run(self): global queue count = 0 while True: if queue.qsize() \u003c 1000: for i in range(100): count = count +1 msg = '生成产品'+str(count) queue.put(msg) print(msg) time.sleep(0.5) class Consumer(threading.Thread): def run(self): global queue while True: if queue.qsize() \u003e 100: for i in range(3): msg = self.name + '消费了 '+queue.get() print(msg) time.sleep(1) if __name__ == '__main__': queue = Queue() for i in range(500): queue.put('初始产品'+str(i)) for i in range(2): p = Producer() p.start() for i in range(5): c = Consumer() c.start() 3. Queue的说明 对于Queue，在多线程通信之间扮演重要的角色 添加数据到队列中，使用put()方法 从队列中取数据，使用get()方法 判断队列中是否还有数据，使用qsize()方法 4. 生产者消费者模式的说明 为什么要使用生产者和消费者模式 在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。\n什么是生产者消费者模式 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。\n这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一个第三者出来进行解耦，\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 生产者与消费者模式","uri":"/2018/02/05/cnblog_8418906/"},{"categories":["笔记","博客园"],"content":"这是👉python3 下载必应每日壁纸（二）👈的摘要 python3 下载必应每日壁纸（一） 脚本写好了，执行就会获取当天必应图片，使用win10的计划任务，设置每天执行，就能获取每天的壁纸了\n打开win10任务计划\n在右边点击创建任务\n设置触发器\n最重要的，设置执行脚本\n我的脚本路径\n程序填python解释器路径\n添加参数，填需要执行的脚本路径，比如我的， G:\\Pictures\\DesktoBackGround\\BingWallpaper.py\n然后点完成就ok了\n是不是很简单啊\n哈哈哈\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python3 下载必应每日壁纸（二）","uri":"/2018/01/30/cnblog_8386624/"},{"categories":["笔记","博客园"],"content":"这是👉python3 下载必应每日壁纸（一）👈的摘要 环境： win10，python3 前言: 想换壁纸了，so，搜搜github,发现有有人用python写的获取必应每日壁纸，看了看，也不难，就自己也写了一个\n首先：找到了一个必应的API\njson_url = \"http://cn.bing.com/HPImageArchive.aspx?format=js\u0026n=1\u0026idx=0\" 改api返回json数据，\n参数n代表返回几条\n参数idx代表返回那一天的，0是今天的，-1是明天的，1是昨天的\n流程： 获取json数据解析出时间，文件名，图片url\n然后下载\ncode\nimport json from urllib import request import os class BingWallpaper(): \"\"\"下载必应壁纸\"\"\" def __init__(self): self.filePath = \"G:\\Pictures\\DesktoBackGround\" self.hosts = \"http://cn.bing.com\" self.imgDate = \"\" self.imgUrl = \"\" self.imgFileName = \"\" def __get_json_data(self, idx = 0): # idx = 0是今天的，-1明天，1昨天 json_url = self.hosts+\"/HPImageArchive.aspx?format=js\u0026n=1\u0026idx={}\".format(idx) try: data = request.urlopen(json_url).read().decode(\"utf-8\") json_data = json.loads(data) self.imgDate = json_data[\"images\"][0][\"enddate\"] self.imgUrl = self.hosts + json_data[\"images\"][0][\"url\"] self.imgFileName = self.imgDate+\"_\"+json_data[\"images\"][0][\"url\"].split(\"/\")[4] except Exception as f: print(\"get_json_data:\",f) def __down_img(self): with request.urlopen(self.imgUrl) as f: data = f.read() # 图片存的路径为 G:\\Pictures\\DesktoBackGround目录 with open(str(self.filePath+os.sep+self.imgFileName), mode=\"wb\") as f: f.write(data) def save_img(self, idx = 0): self.__get_json_data(idx) self.__down_img() print(\"{}download!\".format(self.imgFileName)) if __name__ == '__main__': print(\"path:\",__file__) print(\"run...\") wall = BingWallpaper() wall.save_img() print(\"end!\") exit = input(\"please enter any key to exit...\") ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python3 下载必应每日壁纸（一）","uri":"/2018/01/30/cnblog_8386598/"},{"categories":["笔记","博客园"],"content":"这是👉Python struct模块👈的摘要 转载(http://blog.csdn.net/lis_12/article/details/52777983). 用处 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送; 按照指定格式将字节流转换为Python指定的数据类型; 处理二进制数据,如果用struct来处理文件的话,需要用'wb','rb'以二进制(字节流)写,读的方式来处理文件; 处理c语言中的结构体; struct模块中的函数 函数 return explain pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回. pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块) unpack(fmt,v1,v2…..) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果 pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果 calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式 格式化字符串 当打包或者解包的时,需要按照特定的方式来打包或者解包.该方式就是格式化字符串,它指定了数据类型,除此之外,还有用于控制字节顺序、大小和对齐方式的特殊字符.\n对齐方式 为了同c中的结构体交换数据，还要考虑c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下\nCharacter Byte order Size Alignment @(默认) 本机 本机 本机,凑够4字节 = 本机 标准 none,按原字节数 \u003c 小端 标准 none,按原字节数 | 大端 | 标准 | none,按原字节数\n! | network(大端) | 标准 | none,按原字节数\n如果不懂大小端,见大小端参考网址.\n格式符 格式符 C语言类型 Python类型 Standard size x pad byte(填充字节) no value c char string of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I(大写的i) unsigned int integer 4 l(小写的L) long integer 4 L unsigned long long 4 q long long long 8 Q unsigned long long long 8 f float float 4 d double float 8 s char[] string p char[] string P void * long 注- -!\n_Bool在C99中定义,如果没有这个类型,则将这个类型视为char,一个字节; q和Q只适用于64位机器; 每个格式前可以有一个数字,表示这个类型的个数,如s格式表示一定长度的字符串,4s表示长度为4的字符串;4i表示四个int; P用来转换一个指针,其长度和计算机相关; f和d的长度和计算机相关; ","description":"","tags":["博客园","搬家","cnblogs"],"title":"Python struct模块","uri":"/2018/01/29/cnblog_8377304/"},{"categories":["笔记","博客园"],"content":"这是👉python Tkinter基础 Button bg 设置按钮的背景颜色👈的摘要 code:\n# Tkinter基础 Button bg 设置按钮的背景颜色 import tkinter as tk class App(): def __init__(self, master): frame = tk.Frame(master) frame.pack() self.testButton = tk.Button(frame, text = \"hello\", fg = \"red\", bg = \"blue\", command = self.testPrint) self.testButton.pack() def testPrint(self): print(\"test\") root = tk.Tk() app = App(root) root.mainloop() 结果：\n注：\nfg:前景色 参数：颜色\nbg:背景色 参数：颜色\ntkinter 颜色\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python Tkinter基础 Button bg 设置按钮的背景颜色","uri":"/2018/01/24/cnblog_8343470/"},{"categories":["笔记","博客园"],"content":"这是👉python Tkinter基础 Button command在窗体中添加一个按钮，单击按钮 在IDLE中打印一行字👈的摘要 code\n# Tkinter基础 Button command在窗体中添加一个按钮，单击按钮 在IDLE中打印一行字 import tkinter as tk class App(): def __init__(self, master): frame = tk.Frame(master) frame.pack() self.testButton = tk.Button(frame, text = \"hello\", fg = \"blue\", command = self.testPrint) self.testButton.pack() def testPrint(self): print(\"测试消息！！！！\") root = tk.Tk() app = App(root) root.mainloop() 结果：\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python Tkinter基础 Button command在窗体中添加一个按钮，单击按钮 在IDLE中打印一行字","uri":"/2018/01/24/cnblog_8343298/"},{"categories":["笔记","博客园"],"content":"这是👉python Tkinter 基础添加一个按钮，在按钮上显示文字，并设置文字颜色👈的摘要 code;\n# Tkinter 基础添加一个按钮，在按钮上显示文字，并设置文字颜色 import tkinter as tk # 面向对象编程 class App(): def __init__(self, master): frame = tk.Frame(master) # 框架？？不是很理解 frame.pack() # 创建一个按钮，fg前景色：蓝色 self.testButton = tk.Button(frame, text = \"hello\", fg = \"blue\") self.testButton.pack() root = tk.Tk() app = App(root) root.mainloop() 结果：\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python Tkinter 基础添加一个按钮，在按钮上显示文字，并设置文字颜色","uri":"/2018/01/24/cnblog_8343266/"},{"categories":["笔记","博客园"],"content":"这是👉python Tkinter 基础 创建一行文字的窗体并设置窗体的标题 Label,title👈的摘要 Tkinter 基础 创建一行文字的窗体并设置窗体的标题 Label,title import tkinter as tk app = tk.Tk() # 实例化一个TK 用于容纳整个GUI程序 app.title(\"test01\") # 设置窗体的标题栏 # 设置label主键 ， 显示文本，图标与图片 theLabel = tk.Label(app, text = \"这是一个窗口\") theLabel.pack() # 自动调节 主键的尺寸与位置 # 窗口的主时间循环，有tkiner接管 app.mainloop() 结果：\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python Tkinter 基础 创建一行文字的窗体并设置窗体的标题 Label,title","uri":"/2018/01/24/cnblog_8343168/"},{"categories":["笔记","博客园"],"content":"这是👉python logging模块👈的摘要 函数式简单配置 import logging logging.debug('debug message') logging.info('info message') logging.warning('warning message') logging.error('error message') logging.critical('critical message') 默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL\nERROR \u003e WARNING \u003e INFO \u003e DEBUG），默认的日志格式为日志级别：Logger名称：用户输出消息。\n灵活配置日志级别，日志格式，输出位置:\nimport logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', datefmt='%a, %d %b %Y %H:%M:%S', filename='/tmp/test.log', filemode='w') logging.debug('debug message') logging.info('info message') logging.warning('warning message') logging.error('error message') logging.critical('critical message') 配置参数：\nlogging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有： filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。 filemode：文件打开方式，在指定了filename时使用这个参数，默认值为\"a\"还可指定为\"w\"。 format：指定handler使用的日志显示格式。 datefmt：指定日期时间格式。 level：设置rootlogger（后边会讲解具体概念）的日志级别 stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open('test.log','w'))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。 format参数中可能用到的格式化串： %(name)s Logger的名字 %(levelno)s 数字形式的日志级别 %(levelname)s 文本形式的日志级别 %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有 %(filename)s 调用日志输出函数的模块的文件名 %(module)s 调用日志输出函数的模块名 %(funcName)s 调用日志输出函数的函数名 %(lineno)d 调用日志输出函数的语句所在的代码行 %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数 %(asctime)s 字符串形式的当前时间。默认格式是 \"2003-07-08 16:49:45,896\"。逗号后面的是毫秒 %(thread)d 线程ID。可能没有 %(threadName)s 线程名。可能没有 %(process)d 进程ID。可能没有 %(message)s用户输出的消息 logger对象配置 import logging logger = logging.getLogger() # 创建一个handler，用于写入日志文件 fh = logging.FileHandler('test.log',encoding='utf-8') # 再创建一个handler，用于输出到控制台 ch = logging.StreamHandler() formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') fh.setLevel(logging.DEBUG) fh.setFormatter(formatter) ch.setFormatter(formatter) logger.addHandler(fh) #logger对象可以添加多个fh和ch对象 logger.addHandler(ch) logger.debug('logger debug message') logger.info('logger info message') logger.warning('logger warning message') logger.error('logger error message') logger.critical('logger critical message') logging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。另外，可以通过：logger.setLevel(logging.Debug)设置级别,当然，也可以通过\nfh.setLevel(logging.Debug)单对文件流设置某个级别。\n字典配置法： import os import logging.config # 记录文件日志输出的格式 standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \\ '[%(levelname)s][%(message)s]' #其中name为getlogger指定的名字 # 终端日志输出的格式 simple_format = '%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s:%(message)s' logfile_dir = r'%s\\log' %os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # log文件的目录 logfile_name = 'log.log' # log文件名 # 如果不存在定义的日志目录就创建一个 if not os.path.isdir(logfile_dir): os.mkdir(logfile_dir) # log文件的全路径 logfile_path = os.path.join(logfile_dir, logfile_name) # log配置字典 LOGGING_DIC = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'standard': { 'format': standard_format }, 'simple': { 'format': simple_format }, }, 'filters': {}, 'handlers': { #打印到终端的日志 'console': { 'level': 'DEBUG', 'class': 'logging.StreamHandler', # 打印到屏幕 'formatter': 'simple' }, #打印到文件的日志,收集info及以上的日志 'default': { 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件 'formatter': 'standard', 'filename': logfile_path, # 日志文件 'maxBytes': 1024*1024*5, # 日志大小 5M 'backupCount': 5, 'encoding': 'utf-8', # 日志文件的编码，再也不用担心中文log乱码了 }, }, 'loggers': { #logging.getLogger(__name__)拿到的logger配置 '': { 'handlers': ['default', 'console'], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', 'propagate': True, # 向上（更高level的logger）传递 }, }, } def load_my_logging_cfg(): logging.config.dictConfig(LOGGING_DIC) # 导入上面定义的logging配置 if __name__ == '__main__': load_my_logging_cfg() logger = logging.getLogger(__name__) # 生成一个log实例 logger.info('info message') logger.debug('debug message') logger.warning('warning message') logger.error('error message') logger.critical('critical message') ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python logging模块","uri":"/2018/01/24/cnblog_8342302/"},{"categories":["笔记","博客园"],"content":"这是👉python 面向对象进阶之对象内置方法👈的摘要 反射相关 常用的就是hasattr,getattr\nclass A(): def __init__(self): pass def func(self): print(\"func\") a = A() a.name = \"123\" a.age = 123 print(getattr(a,\"name\")) getattr(a, \"func\")() print(hasattr(a, \"ame\")) setattr,delattr，用于设置变量和删除变量，不常用\n用于对象的一些内置方法：\nstr 调用对象，自动输出\nclass B: def __str__(self): return 'str : class B' def __repr__(self): return 'repr : class B' b = B() print('%s' % b) print('%r' % b) getitem, setitem, delitem 用于索引操作，如字典。以上分别表示获取、设置、删除数据\nclass C(object): def __init__(self): self.value = {} self.name = 'test' def __getitem__(self, item): print '__getitem__', item return self.value[item] def __setitem__(self, key, value): print '__setitem__', key, value self.value[key] = value def __delitem__(self, key): print '__delitem__', key del self.value[key] def __len__(self): return len(self.value) print C.__doc__ c = C() #print c #result = c['k1'] c['k2'] = 5 c['k1'] = \"Hello\" print c['k2'] print len(c) call 对象后面加括号，触发执行。\n注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 call 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()\nclass Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__') obj = Foo() # 执行 __init__ obj() # 执行 __call__ hash 外部哈希，依赖与内置__hash__方法\nclass A(): def __init__(self): self.a = 1 self.b = 2 def __hash__(self): return hash(str(self.a)+str(self.b)) a = A() print(hash(a)) __eq__方法 用与判断两个对象是否相等，因为 == 默认是比较内存地址\nclass A(): def __init__(self, name): self.name = name def __eq__(self, other): if (self.__dict__ == other.__dict__): return True a = A(\"test\") b = A(\"test\") print(a == b) set（）对象去重，依赖于hash，eq方法 class Person: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def __hash__(self): return hash(self.name+self.sex) def __eq__(self, other): if self.name == other.name and self.sex == other.sex:return True p_lst = [] for i in range(84): p_lst.append(Person('egon',i,'male')) print(p_lst) print(set(p_lst)) __del__()方法 创建对象后，python解释器默认调用__init__()方法；\n当删除一个对象时，python解释器也会默认调用一个方法，这个方法为__del__()方法\nimport time class Animal(object): # 初始化方法 # 创建完对象后会自动被调用 def __init__(self, name): print('__init__方法被调用') self.__name = name # 析构方法 # 当对象被删除时，会自动被调用 def __del__(self): print(\"__del__方法被调用\") print(\"%s对象马上被干掉了...\"%self.__name) # 创建对象 dog = Animal(\"哈皮狗\") # 删除对象 del dog cat = Animal(\"波斯猫\") cat2 = cat cat3 = cat print(\"---马上 删除cat对象\") del cat print(\"---马上 删除cat2对象\") del cat2 print(\"---马上 删除cat3对象\") del cat3 print(\"程序2秒钟后结束\") time.sleep(2) 结果： 总结 当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 slots 现在我们终于明白了，动态语言与静态语言的不同\n动态语言：可以在运行的过程中，修改代码\n静态语言：编译时已经确定好代码，运行过程中不能修改\n如果我们想要限制实例的属性怎么办？比如，只允许对Person实例添加name和age属性。\n为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：\n\u003e\u003e\u003e class Person(object): __slots__ = (\"name\", \"age\") \u003e\u003e\u003e P = Person() \u003e\u003e\u003e P.name = \"老王\" \u003e\u003e\u003e P.age = 20 \u003e\u003e\u003e P.score = 100 Traceback (most recent call last): File \"\u003cpyshell#3\u003e\", line 1, in \u003cmodule\u003e AttributeError: Person instance has no attribute 'score' \u003e\u003e\u003e 注意: 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的\nIn [67]: class Test(Person): ...: pass ...:\nIn [68]: t = Test()\nIn [69]: t.score = 100\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 面向对象进阶之对象内置方法","uri":"/2018/01/22/cnblog_8329568/"},{"categories":["笔记","博客园"],"content":"这是👉XMind 8 pro安装破解👈的摘要 XMind 8 pro安装破解 资源下载：\n链接: https://pan.baidu.com/s/1bqQSnAv 密码: 94rb\nStep 1：下载上述资源，解压，安装XMind 默认安装路径为 C:\\Program Files (x86)\\XMind\nStep 2：安装完毕后，将破解工具XMindCrack.zip 内的文件解压到 Xmind 的安装目录，默认安装路径为 C:\\Program Files (x86)\\XMind\nStep 3：将XMindCrack.jar 复制到 D 盘根目录\nStep 4：将 Xmind 安装目录下的 XMind.ini使用记事本打开增加一行\"-javaagent:D:/XMindCrack.jar\"（引号内的内容，引号无需复制，作用就是去执行Step 3，把激活文件的路径加进去，让其离线激活），保存\nStep 5：断开网络, 或者使用防火墙阻止 XMind 联网, 或者在 hosts 中添加\n0.0.0.0 www.xmind.net （建议采用断网或者增加hosts记录法，优选修改hosts法，推荐一个小工具-使用SwitchHosts小工具随心所欲地更改hosts文件）。\nStep 6：打开 XMind, \"帮助-序列号\"，随便输入邮箱地址和下面的序列号激活软件。序列号：\nXAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"XMind 8 pro安装破解","uri":"/2018/01/20/cnblog_8321674/"},{"categories":["笔记","博客园"],"content":"这是👉python 面向对象之继承👈的摘要 继承介绍以及单继承 1. 继承的概念 在现实生活中，继承一般指的是子女继承父辈的财产，如下图\n搞不好,结果如下..\n在程序中，继承描述的是事物之间的所属关系，例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物；同理，波斯猫和巴厘猫都继承自猫，而沙皮狗和斑点狗都继承足够，如下如所示：\n2. 继承示例 # 定义一个父类，如下: class Cat(object): def __init__(self, name, color=\"白色\"): self.name = name self.color = color def run(self): print(\"%s--在跑\"%self.name) # 定义一个子类，继承Cat类如下: class Bosi(Cat): def setNewName(self, newName): self.name = newName def eat(self): print(\"%s--在吃\"%self.name) bs = Bosi(\"印度猫\") print('bs的名字为:%s'%bs.name) print('bs的颜色为:%s'%bs.color) bs.eat() bs.setNewName('波斯') bs.run() View Code\n运行结果:\n说明：\n虽然子类没有定义__init__方法，但是父类有，所以在子类继承父类的时候这个方法就被继承了，所以只要创建Bosi的对象，就默认执行了那个继承过来的__init__方法 总结 子类在继承的时候，在定义类时，小括号()中为父类的名字 父类的属性、方法，会被继承给子类 3. 注意点 class Animal(object): def __init__(self, name='动物', color='白色'): self.__name = name self.color = color def __test(self): print(self.__name) print(self.color) def test(self): print(self.__name) print(self.color) class Dog(Animal): def dogTest1(self): #print(self.__name) #不能访问到父类的私有属性 print(self.color) def dogTest2(self): #self.__test() #不能访问父类中的私有方法 self.test() A = Animal() #print(A.__name) #程序出现异常，不能访问私有属性 print(A.color) #A.__test() #程序出现异常，不能访问私有方法 A.test() print(\"------分割线-----\") D = Dog(name = \"小花狗\", color = \"黄色\") D.dogTest1() D.dogTest2() View Code\n私有的属性，不能通过对象直接访问，但是可以通过方法访问 私有的方法，不能通过对象直接访问 私有的属性、方法，不会被子类继承，也不能被访问 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用 多继承 1. 多继承 从图中能够看出，所谓多继承，即子类有多个父类，并且具有它们的特征\nPython中多继承的格式如下:\n# 定义一个父类 class A: def printA(self): print('----A----') # 定义一个父类 class B: def printB(self): print('----B----') # 定义一个子类，继承自A、B class C(A,B): def printC(self): print('----C----') obj_C = C() obj_C.printA() obj_C.printB() View Code\n运行结果:\n----A---- ----B---- 说明 python中是可以多继承的 父类中的方法、属性，子类会继承 注意点 如果在上面的多继承例子中，如果父类A和父类B中，有一个同名的方法，那么通过子类去调用的时候，调用哪个？\n#coding=utf-8 class base(object): def test(self): print('----base test----') class A(base): def test(self): print('----A test----') # 定义一个父类 class B(base): def test(self): print('----B test----') # 定义一个子类，继承自A、B class C(A,B): pass obj_C = C() obj_C.test() print(C.__mro__) #可以查看C类的对象搜索方法时的先后顺序 View Code\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 面向对象之继承","uri":"/2018/01/18/cnblog_8310762/"},{"categories":["笔记","博客园"],"content":"这是👉python 面向对象之老王开枪👈的摘要 老王开枪 1. 人类 属性 姓名 血量 持有的枪 方法 安子弹 安弹夹 拿枪（持有抢） 开枪 2. 子弹类 属性 杀伤力 方法 伤害敌人(让敌人掉血) 3. 弹夹类 属性 容量（子弹存储的最大值） 当前保存的子弹 方法 保存子弹（安装子弹的时候） 弹出子弹（开枪的时候） 4. 枪类 属性 弹夹（默认没有弹夹，需要安装） 方法 连接弹夹（保存弹夹） 射子弹 参考代码 #人类 class Ren: def __init__(self,name): self.name = name self.xue = 100 self.qiang = None def __str__(self): return self.name + \"剩余血量为:\" + str(self.xue) def anzidan(self,danjia,zidan): danjia.baocunzidan(zidan) def andanjia(self,qiang,danjia): qiang.lianjiedanjia(danjia) def naqiang(self,qiang): self.qiang = qiang def kaiqiang(self,diren): self.qiang.she(diren) def diaoxue(self,shashangli): self.xue -= shashangli #弹夹类 class Danjia: def __init__(self, rongliang): self.rongliang = rongliang self.rongnaList = [] def __str__(self): return \"弹夹当前的子弹数量为:\" + str(len(self.rongnaList)) + \"/\" + str(self.rongliang) def baocunzidan(self,zidan): if len(self.rongnaList) \u003c self.rongliang: self.rongnaList.append(zidan) def chuzidan(self): #判断当前弹夹中是否还有子弹 if len(self.rongnaList) \u003e 0: #获取最后压入到单间中的子弹 zidan = self.rongnaList[-1] self.rongnaList.pop() return zidan else: return None #子弹类 class Zidan: def __init__(self,shashangli): self.shashangli = shashangli def shanghai(self,diren): diren.diaoxue(self.shashangli) #枪类 class Qiang: def __init__(self): self.danjia = None def __str__(self): if self.danjia: return \"枪当前有弹夹\" else: return \"枪没有弹夹\" def lianjiedanjia(self,danjia): if not self.danjia: self.danjia = danjia def she(self,diren): zidan = self.danjia.chuzidan() if zidan: zidan.shanghai(diren) else: print(\"没有子弹了，放了空枪....\") #创建一个人对象 laowang = Ren(\"老王\") #创建一个弹夹 danjia = Danjia(20) print(danjia) #循环的方式创建一颗子弹，然后让老王把这颗子弹压入到弹夹中 i=0 while i\u003c5: zidan = Zidan(5) laowang.anzidan(danjia,zidan) i+=1 #测试一下，安装完子弹后，弹夹中的信息 print(danjia) #创建一个枪对象 qiang = Qiang() print(qiang) #让老王，把弹夹连接到枪中 laowang.andanjia(qiang,danjia) print(qiang) #创建一个敌人 diren = Ren(\"敌人\") print(diren) #让老王拿起枪 laowang.naqiang(qiang) #老王开枪射敌人 laowang.kaiqiang(diren) print(diren) print(danjia) laowang.kaiqiang(diren) print(diren) print(danjia) View Code\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 面向对象之老王开枪","uri":"/2018/01/18/cnblog_8310708/"},{"categories":["笔记","博客园"],"content":"这是👉python 面向对象👈的摘要 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程 用面向对象的思维解决问题的重点 当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程\n应该找一个专门做这个事的人来做\n面向对象是基于面向过程的\n类和对象 面向对象编程的2个非常重要的概念：类和对象\n对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念----类\n类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象\n类 ​ 人以类聚 物以群分。 ​ 具有相似内部状态和运动规律的实体的集合(或统称、抽象)。 ​ 具有相同属性和行为事物的统称\n类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象\n对象 某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。可以是直接使用的\n类和对象之间的关系 类就是创建对象的模板\n区分类和对象 奔驰汽车 类 奔驰smart 类 张三的那辆奔驰smart 对象 狗 类 大黄狗 类 李四家那只大黄狗 对象 水果 类 苹果 类 红苹果 类 红富士苹果 类 我嘴里吃了一半的苹果 对象 类的构成 类(Class) 由3个部分构成\n类的名称:类名 类的属性:一组数据 类的方法:允许对进行操作的方法 (行为) 举个栗子： 1）人的类设计,只关心3样东西:\n事物名称(类名):人(Person) 属性:身高(height)、年龄(age) 方法(行为/功能):跑(run)、打架(fight) 2）狗类的设计\n类名:狗(Dog) 属性:品种 、毛色、性别、名字、 腿儿的数量 方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 类的抽象 如何把日常生活中的事物抽象成程序中的类? 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 一般名词都是类(名词提炼法)\n\u003c1\u003e 坦克发射3颗炮弹轰掉了2架飞机 坦克--》可以抽象成 类 炮弹--》可以抽象成类 飞机-》可以抽象成类 \u003c2\u003e 小明在公车上牵着一条叼着热狗的狗 小明--》 人类 公车--》 交通工具类 热狗--》 食物类 狗--》 狗类 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 面向对象","uri":"/2018/01/15/cnblog_8286595/"},{"categories":["笔记","博客园"],"content":"这是👉python os模块👈的摘要 os模块 os os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 os.chdir(\"dirname\") 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: ('.') os.pardir 获取当前目录的父目录字符串名：('..') os.makedirs('dirname1/dirname2') 可生成多层递归目录 os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirname os.rmdir('dirname') 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(\"oldname\",\"newname\") 重命名文件/目录 os.stat('path/filename') 获取文件/目录信息 os.sep 输出操作系统特定的路径分隔符，win下为\"\\\\\",Linux下为\"/\" os.linesep 输出当前平台使用的行终止符，win下为\"\\t\\n\",Linux下为\"\\n\" os.pathsep 输出用于分割文件路径的字符串 win下为;,Linux下为: os.name 输出字符串指示当前使用平台。win-\u003e'nt'; Linux-\u003e'posix' os.system(\"bash command\") 运行shell命令，直接显示 os.popen(\"bash command).read() 运行shell命令，获取执行结果 os.environ 获取系统环境变量 os.path os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path) 如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回False os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回path所指向的文件或者目录的最后访问时间 os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回path的大小 注意：os.stat('path/filename') 获取文件/目录信息 的结构说明\nst_mode: inode 保护模式 st_ino: inode 节点号。 st_dev: inode 驻留的设备。 st_nlink: inode 的链接数。 st_uid: 所有者的用户ID。 st_gid: 所有者的组ID。 st_size: 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。 st_atime: 上次访问的时间。 st_mtime: 最后一次修改的时间。 st_ctime: 由操作系统报告的\"ctime\"。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python os模块","uri":"/2018/01/12/cnblog_8277029/"},{"categories":["笔记","博客园"],"content":"这是👉python 时间模块time👈的摘要 time模块 时间模块 1 思维导图 ![python 模块](http://on- img.com/chart_image/5a5441d4e4b0abe85d46b5f4.png)\n和时间有关系的我们就要用到时间模块。在使用模块之前，应该首先导入这个模块。\n#常用方法 1.time.sleep(secs) (线程)推迟指定的时间运行。单位为秒。 2.time.time() 获取当前时间戳 表示时间的三种方式\n在Python中，通常有这三种方式来表示时间：时间戳、元组(struct_time)、格式化的时间字符串：\n(1)时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行\"type(time.time())\"，返回的是float类型。\n(2)格式化的时间字符串(Format String)： '1999-12-06'\n%y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 View Code\n(3)元组(struct_time) ：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等）\n索引（Index） 属性（Attribute） 值（Values） 0 tm_year（年） 比如2011 1 tm_mon（月） 1 - 12 2 tm_mday（日） 1 - 31 3 tm_hour（时） 0 - 23 4 tm_min（分） 0 - 59 5 tm_sec（秒） 0 - 60 6 tm_wday（weekday） 0 - 6（0表示周一） 7 tm_yday（一年中的第几天） 1 - 366 8 tm_isdst（是否是夏令时） 默认为0 首先，我们先导入time模块，来认识一下python中表示时间的几种格式：\n#导入时间模块 \u003e\u003e\u003eimport time #时间戳 \u003e\u003e\u003etime.time() 1500875844.800804 #时间字符串 \u003e\u003e\u003etime.strftime(\"%Y-%m-%d %X\") '2017-07-24 13:54:37' \u003e\u003e\u003etime.strftime(\"%Y-%m-%d %H-%M-%S\") '2017-07-24 13-55-04' #时间元组:localtime将一个时间戳转换为当前时区的struct_time time.localtime() time.struct_time(tm_year=2017, tm_mon=7, tm_mday=24, tm_hour=13, tm_min=59, tm_sec=37, tm_wday=0, tm_yday=205, tm_isdst=0) 小结：时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的\n几种格式之间的转换\n#时间戳--\u003e结构化时间 #time.gmtime(时间戳) #UTC时间，与英国伦敦当地时间一致 #time.localtime(时间戳) #当地时间。例如我们现在在北京执行这个方法：与UTC时间相差8小时，UTC时间+8小时 = 北京时间 \u003e\u003e\u003etime.gmtime(1500000000) time.struct_time(tm_year=2017, tm_mon=7, tm_mday=14, tm_hour=2, tm_min=40, tm_sec=0, tm_wday=4, tm_yday=195, tm_isdst=0) \u003e\u003e\u003etime.localtime(1500000000) time.struct_time(tm_year=2017, tm_mon=7, tm_mday=14, tm_hour=10, tm_min=40, tm_sec=0, tm_wday=4, tm_yday=195, tm_isdst=0) #结构化时间--\u003e时间戳　#time.mktime(结构化时间) \u003e\u003e\u003etime_tuple = time.localtime(1500000000) \u003e\u003e\u003etime.mktime(time_tuple) 1500000000.0 #结构化时间--\u003e字符串时间 #time.strftime(\"格式定义\",\"结构化时间\") 结构化时间参数若不传，则现实当前时间 \u003e\u003e\u003etime.strftime(\"%Y-%m-%d %X\") '2017-07-24 14:55:36' \u003e\u003e\u003etime.strftime(\"%Y-%m-%d\",time.localtime(1500000000)) '2017-07-14' #字符串时间--\u003e结构化时间 #time.strptime(时间字符串,字符串对应格式) \u003e\u003e\u003etime.strptime(\"2017-03-16\",\"%Y-%m-%d\") time.struct_time(tm_year=2017, tm_mon=3, tm_mday=16, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=75, tm_isdst=-1) \u003e\u003e\u003etime.strptime(\"07/24/2017\",\"%m/%d/%Y\") time.struct_time(tm_year=2017, tm_mon=7, tm_mday=24, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=205, tm_isdst=-1) #结构化时间 --\u003e %a %b %d %H:%M:%S %Y串 #time.asctime(结构化时间) 如果不传参数，直接返回当前时间的格式化串 \u003e\u003e\u003etime.asctime(time.localtime(1500000000)) 'Fri Jul 14 10:40:00 2017' \u003e\u003e\u003etime.asctime() 'Mon Jul 24 15:18:33 2017' #%a %d %d %H:%M:%S %Y串 --\u003e 结构化时间 #time.ctime(时间戳) 如果不传参数，直接返回当前时间的格式化串 \u003e\u003e\u003etime.ctime() 'Mon Jul 24 15:19:07 2017' \u003e\u003e\u003etime.ctime(1500000000) 'Fri Jul 14 10:40:00 2017' import time true_time=time.mktime(time.strptime('2017-09-11 08:30:00','%Y-%m-%d %H:%M:%S')) time_now=time.mktime(time.strptime('2017-09-12 11:00:00','%Y-%m-%d %H:%M:%S')) dif_time=time_now-true_time struct_time=time.gmtime(dif_time) print('过去了%d年%d月%d天%d小时%d分钟%d秒'%(struct_time.tm_year-1970,struct_time.tm_mon-1, struct_time.tm_mday-1,struct_time.tm_hour, struct_time.tm_min,struct_time.tm_sec)) View Code\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 时间模块time","uri":"/2018/01/10/cnblog_8258730/"},{"categories":["笔记","博客园"],"content":"这是👉python re模块👈的摘要 re模块 1.正则表达式概述 正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。\nRegular Expression的\"Regular\"一般被译为\"正则\"、\"正规\"、\"常规\"。此处的\"Regular\"即是\"规则\"、\"规律\"的意思，Regular Expression即\"描述某种规则的表达式\"之意。\n2 思维导图 ![python 模块](http://on- img.com/chart_image/5a5441d4e4b0abe85d46b5f4.png)\n3表示方法 re模块的使用过程 # 导入re模块 import re # 使用match方法进行匹配操作 result = re.match(正则表达式,要匹配的字符串) # 如果上一步匹配到数据的话，可以使用group方法来提取数据 result.group() re.match是用来进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match Object），否则返回None（注意不是空字符串\"\"）。\n匹配对象Macth Object具有group方法，用来返回字符串的匹配部分 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python re模块","uri":"/2018/01/09/cnblog_8249990/"},{"categories":["笔记","博客园"],"content":"这是👉python urllib https抓取网页的问题👈的摘要 from urllib import request import ssl\n# ssl._create_default_https_context = ssl._create_unverified_context def getHtml(): # url = \"https://m.80s.tw\" url = \"https://www.80s.tw\" data = request.urlopen(url).read().decode(\"utf-8\") return data print(getHtml()) 获取HTTPS的网页源码，是返回错误，\nurllib.error.URLError: \u003curlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:777)\u003e\n然后加上下面代码就可以了🙃\nimport ssl ssl._create_default_https_context=ssl._create_unverified_context ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python urllib https抓取网页的问题","uri":"/2018/01/08/cnblog_8244143/"},{"categories":["笔记","博客园"],"content":"这是👉python 匿名函数👈的摘要 匿名函数 用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。\nlambda函数的语法只包含一个语句，如下：\nlambda [arg1 [,arg2,.....argn]]:expression 如下实例：\nsum = lambda arg1, arg2: arg1 + arg2 #调用sum函数 print \"Value of total : \", sum( 10, 20 ) print \"Value of total : \", sum( 20, 20 ) 以上实例输出结果：\nValue of total : 30 Value of total : 40 Lambda函数能接收任何数量的参数但只能返回一个表达式的值\n匿名函数不能直接调用print，因为lambda需要一个表达式\n应用场合 函数作为参数传递 自己定义函数\ndef fun(a, b, opt): ... print \"a =\", a ... print \"b =\", b ... print \"result =\", opt(a, b) ... \u003e\u003e\u003e fun(1, 2, lambda x,y:x+y) a = 1 b = 2 result = 3\n作为内置函数的参数\n想一想，下面的数据如何指定按age或name排序？ stus = [ {\"name\":\"zhangsan\", \"age\":18}, {\"name\":\"lisi\", \"age\":19}, {\"name\":\"wangwu\", \"age\":17} ] 按name排序： \u003e\u003e\u003e stus.sort(key = lambda x:x['name']) \u003e\u003e\u003e stus [{'age': 19, 'name': 'lisi'}, {'age': 17, 'name': 'wangwu'}, {'age': 18, 'name': 'zhangsan'}] 按age排序： \u003e\u003e\u003e stus.sort(key = lambda x:x['age']) \u003e\u003e\u003e stus [{'age': 17, 'name': 'wangwu'}, {'age': 18, 'name': 'zhangsan'}, {'age': 19, 'name': 'lisi'}] ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 匿名函数","uri":"/2018/01/08/cnblog_8241193/"},{"categories":["笔记","博客园"],"content":"这是👉python 递归函数👈的摘要 递归函数 举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * ... * n\n看阶乘的规律 1! = 1 2! = 2 × 1 = 2 × 1! 3! = 3 × 2 × 1 = 3 × 2! 4! = 4 × 3 × 2 × 1 = 4 × 3! ... n! = n × (n-1)! 说白了，递归函数，就是自己调用自己！\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 递归函数","uri":"/2018/01/08/cnblog_8241349/"},{"categories":["笔记","博客园"],"content":"这是👉python 内置函数👈的摘要 内置函数 接下来，我们就一起来看看python里的内置函数。截止到python版本3.6.2，现在python一共为我们提供了 68个内置函数 。它们就是python提供给你直接可以拿来使用的所有函数。这些函数有些我们已经用过了，有些我们还没用到过，还有一些是被封印了，必须等我们学了新知识才能解开封印的。那今天我们就一起来认识一下python的内置函数。这么多函数，我们该从何学起呢？\nBuilt-in Functions abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() import() complex() hasattr() max() round() delattr() hash() memoryview() set() 总结下图\n![思维导图](http://on- img.com/chart_image/5a4d90b8e4b0ee0fb8cc8b23.png)\n点一下图片，有惊喜😂\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 内置函数","uri":"/2018/01/04/cnblog_8191328/"},{"categories":["笔记","博客园"],"content":"这是👉使用pyInstaller打包py文件为exe文件👈的摘要 安装 pip install pyinstaller\n①， 打包成一个文件：\n_ python pyinstaller.py --onefile yourprogram.py\n②，修改exe的图标（D:\\BabyWandH\\src\\faviconw.ico为图标的存放路径）：\npython pyinstaller.py --onefile --icon=D:\\BabyWandH\\src\\faviconw.ico yourprogram.py _\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"使用pyInstaller打包py文件为exe文件","uri":"/2018/01/03/cnblog_8185308/"},{"categories":["笔记","博客园"],"content":"这是👉python 生成器👈的摘要 生成器 1. 什么是生成器 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n2. 创建生成器方法1 要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的 [ ] 改成 ( )\nIn [15]: L = [ x*2 for x in range(5)] In [16]: L Out[16]: [0, 2, 4, 6, 8] In [17]: G = ( x*2 for x in range(5)) In [18]: G Out[18]: \u003cgenerator object \u003cgenexpr\u003e at 0x7f626c132db0\u003e In [19]: 创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) ， L 是一个列表，而 G 是一个生成器。我们可以直接打印出L的每一个元素，但我们怎么打印出G的每一个元素呢？如果要一个一个打印出来，可以通过 next() 函数获得生成器的下一个返回值：\nIn [19]: next(G) Out[19]: 0 In [20]: next(G) Out[20]: 2 In [21]: next(G) Out[21]: 4 In [22]: next(G) Out[22]: 6 In [23]: next(G) Out[23]: 8 In [24]: next(G) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-24-380e167d6934\u003e in \u003cmodule\u003e() ----\u003e 1 next(G) StopIteration: In [25]: In [26]: G = ( x*2 for x in range(5)) In [27]: for x in G: ....: print(x) ....: 0 2 4 6 8 In [28]: 生成器保存的是算法，每次调用 next(G) ，就计算出 G 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的异常。当然，这种不断调用 next() 实在是太变态了，正确的方法是使用 for 循环，因为生成器也是可迭代对象。所以，我们创建了一个生成器后，基本上永远不会调用 next() ，而是通过 for 循环来迭代它，并且不需要关心 StopIteration 异常。\n3. 创建生成器方法2 generator非常强大。如果推算的算法比较复杂，用类似列表生成式的 for 循环无法实现的时候，还可以用函数来实现。\n比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：\n1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：\nIn [28]: def fib(times): ....: n = 0 ....: a,b = 0,1 ....: while n\u003ctimes: ....: print(b) ....: a,b = b,a+b ....: n+=1 ....: return 'wilson' ....: In [29]: fib(5) 1 1 2 3 5 Out[29]: 'wilson' 仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了：\nIn [30]: def fib(times): ....: n = 0 ....: a,b = 0,1 ....: while n\u003ctimes: ....: yield b ....: a,b = b,a+b ....: n+=1 ....: return 'done' ....: In [31]: F = fib(5) In [32]: next(F) Out[32]: 1 In [33]: next(F) Out[33]: 1 In [34]: next(F) Out[34]: 2 In [35]: next(F) Out[35]: 3 In [36]: next(F) Out[36]: 5 In [37]: next(F) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-37-8c2b02b4361a\u003e in \u003cmodule\u003e() ----\u003e 1 next(F) StopIteration: done 在上面fib 的例子，我们在循环过程中不断调用 yield ，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用 next() 来获取下一个返回值，而是直接使用 for 循环来迭代：\nIn [38]: for n in fib(5): ....: print(n) ....: 1 1 2 3 5 In [39]: 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\nIn [39]: g = fib(5) In [40]: while True: ....: try: ....: x = next(g) ....: print(\"value:%d\"%x) ....: except StopIteration as e: ....: print(\"生成器返回值:%s\"%e.value) ....: break ....: value:1 value:1 value:2 value:3 value:5 生成器返回值:done In [41]: 4. send 例子：执行到yield时，gen函数作用暂时保存，返回i的值;temp接收下次c.send(\"python\")，send发送过来的值，c.next()等价c.send(None)\nIn [10]: def gen(): ....: i = 0 ....: while i\u003c5: ....: temp = yield i ....: print(temp) ....: i+=1 ....: 使用next函数 In [11]: f = gen() In [12]: next(f) Out[12]: 0 In [13]: next(f) None Out[13]: 1 In [14]: next(f) None Out[14]: 2 In [15]: next(f) None Out[15]: 3 In [16]: next(f) None Out[16]: 4 In [17]: next(f) None --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-17-468f0afdf1b9\u003e in \u003cmodule\u003e() ----\u003e 1 next(f) StopIteration: 使用__next__()方法 In [18]: f = gen() In [19]: f.__next__() Out[19]: 0 In [20]: f.__next__() None Out[20]: 1 In [21]: f.__next__() None Out[21]: 2 In [22]: f.__next__() None Out[22]: 3 In [23]: f.__next__() None Out[23]: 4 In [24]: f.__next__() None --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) \u003cipython-input-24-39ec527346a9\u003e in \u003cmodule\u003e() ----\u003e 1 f.__next__() StopIteration: 使用send In [43]: f = gen() In [44]: f.__next__() Out[44]: 0 In [45]: f.send('haha') haha Out[45]: 1 In [46]: f.__next__() None Out[46]: 2 In [47]: f.send('haha') haha Out[47]: 3 In [48]: 总结 生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。\n生成器不仅\"记住\"了它数据状态；生成器还\"记住\"了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。\n生成器的特点：\n节约内存 迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 生成器","uri":"/2018/01/03/cnblog_8183674/"},{"categories":["笔记","博客园"],"content":"这是👉python 迭代器👈的摘要 迭代器 迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n1. 可迭代对象 以直接作用于 for 循环的数据类型有以下几种：\n一类是集合数据类型，如 list 、 tuple 、 dict 、 set 、 str 等；\n一类是 generator ，包括生成器和带 yield 的generator function。\n这些可以直接作用于 for 循环的对象统称为可迭代对象： Iterable 。\n2. 判断是否可以迭代 可以使用 isinstance() 判断一个对象是否是 Iterable 对象：\nIn [50]: from collections import Iterable In [51]: isinstance([], Iterable) Out[51]: True In [52]: isinstance({}, Iterable) Out[52]: True In [53]: isinstance('abc', Iterable) Out[53]: True In [54]: isinstance((x for x in range(10)), Iterable) Out[54]: True In [55]: isinstance(100, Iterable) Out[55]: False 而生成器不但可以作用于 for 循环，还可以被 next() 函数不断调用并返回下一个值，直到最后抛出 StopIteration 错误表示无法继续返回下一个值了。\n3.迭代器 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。\n可以使用 isinstance() 判断一个对象是否是 Iterator 对象：\nIn [56]: from collections import Iterator In [57]: isinstance((x for x in range(10)), Iterator) Out[57]: True In [58]: isinstance([], Iterator) Out[58]: False In [59]: isinstance({}, Iterator) Out[59]: False In [60]: isinstance('abc', Iterator) Out[60]: False In [61]: isinstance(100, Iterator) Out[61]: False 4.iter()函数 生成器都是 Iterator 对象，但 list 、 dict 、 str 虽然是 Iterable ，却不是 Iterator 。\n把 list 、 dict 、 str 等 Iterable 变成 Iterator 可以使用 iter() 函数：\nIn [62]: isinstance(iter([]), Iterator) Out[62]: True In [63]: isinstance(iter('abc'), Iterator) Out[63]: True 总结 凡是可作用于 for 循环的对象都是 Iterable 类型； 凡是可作用于 next() 函数的对象都是 Iterator 类型 集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象。 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 迭代器","uri":"/2018/01/03/cnblog_8183568/"},{"categories":["笔记","博客园"],"content":"这是👉python 装饰器👈的摘要 装饰器 装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，所以这也是Python面试中必问的问题，但对于好多初次接触这个知识的人来讲，这个功能有点绕，自学时直接绕过去了，然后面试问到了就挂了，因为装饰器是程序开发的基础知识，这个都不会，别跟人家说你会Python, 看了下面的文章，保证你学会装饰器。\n1、先明白这段代码 #### 第一波 #### def foo(): print('foo') foo #表示是函数 foo() #表示执行foo函数 #### 第二波 #### def foo(): print('foo') foo = lambda x: x + 1 foo() # 执行下面的lambda表达式，而不再是原来的foo函数，因为foo这个名字被重新指向了另外一个匿名函数 2、需求来了 初创公司有N个业务部门，1个基础平台部门，基础平台负责提供底层的功能，如：数据库操作、redis调用、监控API等功能。业务部门使用基础功能时，只需调用基础平台提供的功能即可。如下：\n############### 基础平台提供的功能如下 ############### def f1(): print('f1') def f2(): print('f2') def f3(): print('f3') def f4(): print('f4') ############### 业务部门A 调用基础平台提供的功能 ############### f1() f2() f3() f4() ############### 业务部门B 调用基础平台提供的功能 ############### f1() f2() f3() f4() 目前公司有条不紊的进行着，但是，以前基础平台的开发人员在写代码时候没有关注验证相关的问题，即：基础平台的提供的功能可以被任何人使用。现在需要对基础平台的所有功能进行重构，为平台提供的所有功能添加验证机制，即：执行功能前，先进行验证。\n老大把工作交给 Low B，他是这么做的： 跟每个业务部门交涉，每个业务部门自己写代码，调用基础平台的功能之前先验证。诶，这样一来基础平台就不需要做任何修改了。太棒了，有充足的时间泡妹子...\n当天Low B 被开除了…\n老大把工作交给 Low BB，他是这么做的： ############### 基础平台提供的功能如下 ############### def f1(): # 验证1 # 验证2 # 验证3 print('f1') def f2(): # 验证1 # 验证2 # 验证3 print('f2') def f3(): # 验证1 # 验证2 # 验证3 print('f3') def f4(): # 验证1 # 验证2 # 验证3 print('f4') ############### 业务部门不变 ############### ### 业务部门A 调用基础平台提供的功能### f1() f2() f3() f4() ### 业务部门B 调用基础平台提供的功能 ### f1() f2() f3() f4() 过了一周 Low BB 被开除了…\n老大把工作交给 Low BBB，他是这么做的： 只对基础平台的代码进行重构，其他业务部门无需做任何修改\n############### 基础平台提供的功能如下 ############### def check_login(): # 验证1 # 验证2 # 验证3 pass def f1(): check_login() print('f1') def f2(): check_login() print('f2') def f3(): check_login() print('f3') def f4(): check_login() print('f4') 老大看了下Low BBB 的实现，嘴角漏出了一丝的欣慰的笑，语重心长的跟Low BBB聊了个天：\n老大说： 写代码要遵循开放封闭原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：\n封闭：已实现的功能代码块 开放：对扩展开发 如果将开放封闭原则应用在上述需求中，那么就不允许在函数 f1 、f2、f3、f4的内部进行修改代码，老板就给了Low BBB一个实现方案：\ndef w1(func): def inner(): # 验证1 # 验证2 # 验证3 func() return inner @w1 def f1(): print('f1') @w1 def f2(): print('f2') @w1 def f3(): print('f3') @w1 def f4(): print('f4') 对于上述代码，也是仅仅对基础平台的代码进行修改，就可以实现在其他人调用函数 f1 f2 f3 f4 之前都进行【验证】操作，并且其他业务部门无需做任何操作。\nLow BBB心惊胆战的问了下，这段代码的内部执行原理是什么呢？\n老大正要生气，突然Low BBB的手机掉到地上，恰巧屏保就是Low BBB的女友照片，老大一看一紧一抖，喜笑颜开，决定和Low BBB交个好朋友。\n详细的开始讲解了：\n单独以f1为例：\ndef w1(func): def inner(): # 验证1 # 验证2 # 验证3 func() return inner @w1 def f1(): print('f1') python解释器就会从上到下解释代码，步骤如下：\ndef w1(func): ==\u003e将w1函数加载到内存 @w1 没错， 从表面上看解释器仅仅会解释这两句代码，因为函数在 没有被调用之前其内部代码不会被执行。\n从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章， @函数名 是python的一种语法糖。\n上例@w1内部会执行一下操作： 执行w1函数 执行w1函数 ，并将 @w1 下面的函数作为w1函数的参数，即：@w1 等价于 w1(f1) 所以，内部就会去执行：\ndef inner(): #验证 1 #验证 2 #验证 3 f1() # func是参数，此时 func 等于 f1 return inner# 返回的 inner，inner代表的是函数，非执行函数 ,其实就是将原来的 f1 函数塞进另外一个函数中 w1的返回值 将执行完的w1函数返回值 赋值 给@w1下面的函数的函数名f1 即将w1的返回值再重新赋值给 f1，即：\n新f1 = def inner(): #验证 1 #验证 2 #验证 3 原来f1() return inner 所以，以后业务部门想要执行 f1 函数时，就会执行 新f1 函数，在新f1 函数内部先执行验证，再执行原来的f1函数，然后将原来f1 函数的返回值返回给了业务调用者。\n如此一来， 即执行了验证的功能，又执行了原来f1函数的内容，并将原f1函数返回值 返回给业务调用着\nLow BBB 你明白了吗？要是没明白的话，我晚上去你家帮你解决吧！！！\n3. 再议装饰器 #定义函数：完成包裹数据 def makeBold(fn): def wrapped(): return \"\u003cb\u003e\" + fn() + \"\u003c/b\u003e\" return wrapped #定义函数：完成包裹数据 def makeItalic(fn): def wrapped(): return \"\u003ci\u003e\" + fn() + \"\u003c/i\u003e\" return wrapped @makeBold def test1(): return \"hello world-1\" @makeItalic def test2(): return \"hello world-2\" @makeBold @makeItalic def test3(): return \"hello world-3\" print(test1())) print(test2())) print(test3())) 运行结果: \u003cb\u003ehello world-1\u003c/b\u003e \u003ci\u003ehello world-2\u003c/i\u003e \u003cb\u003e\u003ci\u003ehello world-3\u003c/i\u003e\u003c/b\u003e 4. 装饰器(decorator)功能 引入日志 函数执行时间统计 执行函数前预备处理 执行函数后清理功能 权限校验等场景 缓存 5. 装饰器示例 例1:无参数的函数 from time import ctime, sleep def timefun(func): def wrappedfunc(): print(\"%s called at %s\"%(func.__name__, ctime())) func() return wrappedfunc @timefun def foo(): print(\"I am foo\") foo() sleep(2) foo() 上面代码理解装饰器执行行为可理解成\nfoo = timefun(foo) #foo先作为参数赋值给func后,foo接收指向timefun返回的wrappedfunc foo() #调用foo(),即等价调用wrappedfunc() #内部函数wrappedfunc被引用，所以外部函数的func变量(自由变量)并没有释放 #func里保存的是原foo函数对象 例2:被装饰的函数有参数 from time import ctime, sleep def timefun(func): def wrappedfunc(a, b): print(\"%s called at %s\"%(func.__name__, ctime())) print(a, b) func(a, b) return wrappedfunc @timefun def foo(a, b): print(a+b) foo(3,5) sleep(2) foo(2,4) 例3:被装饰的函数有不定长参数 from time import ctime, sleep def timefun(func): def wrappedfunc(*args, **kwargs): print(\"%s called at %s\"%(func.__name__, ctime())) func(*args, **kwargs) return wrappedfunc @timefun def foo(a, b, c): print(a+b+c) foo(3,5,7) sleep(2) foo(2,4,9) 例4:装饰器中的return from time import ctime, sleep def timefun(func): def wrappedfunc(): print(\"%s called at %s\"%(func.__name__, ctime())) func() return wrappedfunc @timefun def foo(): print(\"I am foo\") @timefun def getInfo(): return '----hahah---' foo() sleep(2) foo() print(getInfo()) 执行结果:\nfoo called at Fri Nov 4 21:55:35 2016 I am foo foo called at Fri Nov 4 21:55:37 2016 I am foo getInfo called at Fri Nov 4 21:55:37 2016 None 如果修改装饰器为return func()，则运行结果：\nfoo called at Fri Nov 4 21:55:57 2016 I am foo foo called at Fri Nov 4 21:55:59 2016 I am foo getInfo called at Fri Nov 4 21:55:59 2016 ----hahah--- 总结： 一般情况下为了让装饰器更通用，可以有return 例5:装饰器带参数,在原有装饰器的基础上，设置外部变量 #decorator2.py from time import ctime, sleep def timefun_arg(pre=\"hello\"): def timefun(func): def wrappedfunc(): print(\"%s called at %s %s\"%(func.__name__, ctime(), pre)) return func() return wrappedfunc return timefun @timefun_arg(\"itcast\") def foo(): print(\"I am foo\") @timefun_arg(\"python\") def too(): print(\"I am too\") foo() sleep(2) foo() too() sleep(2) too() 可以理解为\nfoo()==timefun_arg(\"itcast\")(foo)() 例6：类装饰器（扩展，非重点） 装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 __call__() 方法，那么这个对象就是callable的。\nclass Test(): def __call__(self): print('call me!') t = Test() t() # call me 类装饰器demo\nclass Test(object): def __init__(self, func): print(\"---初始化---\") print(\"func name is %s\"%func.__name__) self.__func = func def __call__(self): print(\"---装饰器中的功能---\") self.__func() #说明： #1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象 # 并且会把test这个函数名当做参数传递到__init__方法中 # 即在__init__方法中的func变量指向了test函数体 # #2. test函数相当于指向了用Test创建出来的实例对象 # #3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法 # #4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用 # 所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体 @Test def test(): print(\"----test---\") test() showpy()#如果把这句话注释，重新运行程序，依然会看到\"--初始化--\" 运行结果如下：\n---初始化--- func name is test ---装饰器中的功能--- ----test--- ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 装饰器","uri":"/2017/12/28/cnblog_8134274/"},{"categories":["笔记","博客园"],"content":"这是👉python 三元运算符👈的摘要 三元运算符 接收结果的变量 = 条件为真的结果 if 条件 else 条件为假的结果 怎么样是不是很简单！😝 **\n**\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 三元运算符","uri":"/2017/12/28/cnblog_8134268/"},{"categories":["笔记","博客园"],"content":"这是👉python 函数进阶👈的摘要 试着画了一个思维导图发现还真不错 ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 函数进阶","uri":"/2017/12/27/cnblog_8125951/"},{"categories":["笔记","博客园"],"content":"这是👉python 函数👈的摘要 函数 总结一：\n定义： def 关键词开头，空格之后接函数名称和圆括号()，最后还有一个\":\"。\ndef 是固定的，不能变，必须是连续的def三个字母，不能分开。。。它们要相亲相爱的在一起。\n空格 为了将def关键字和函数名分开，必须空(四声)，当然你可以空2格、3格或者你想空多少都行，但正常人还是空1格。\n函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并能表达函数功能\n括号：是必须加的，先别问为啥要有括号，总之加上括号就对了！\n注释： 每一个函数都应该对功能和参数进行相应的说明，应该写在函数下面第一行。以增强代码的可读性。\n调用： 就是 函数名() 要记得加上括号，好么好么好么\n函数的返回值 只需要在函数的最后加上一个return，return后面写上返回的值就可以了。\nreturn关键字的作用\nreturn 是一个关键字，在pycharm里，你会看到它变成蓝色了。你必须一字不差的把这个单词给背下来。\n这个词翻译过来就是 \"返回\"，所以我们管写在return后面的值叫\"返回值\"\n要研究返回值，我们还要知道返回值有几种情况：分别是没有返回值、返回一个值、返回多个值\n没有返回值\n不写return的情况下，会默认返回一个None：我们写的第一个函数，就没有写return，这就是没有返回值的一种情况。\n函数的参数 实参与形参\n参数还有分别：\n我们调用函数时传递的这个\"hello world\"被称为 实际参数， 因为这个是实际的要交给函数的内容，简称 实参。\n定义函数时的s1，只是一个变量的名字，被称为 形式参数 ，因为在定义函数的时候它只是一个形式，表示这里有一个参数，简称 形参 。\n1.定义：def 关键词开头，空格之后接函数名称和圆括号()。 2.参数：圆括号用来接收参数。若传入多个参数，参数之间用逗号分割。 参数可以定义多个，也可以不定义。 参数有很多种，如果涉及到多种参数的定义，应始终遵循位置参数、*args、默认参数、**kwargs顺序定义。 如上述定义过程中某参数类型缺省，其他参数依旧遵循上述排序 3.注释：函数的第一行语句应该添加注释。 4.函数体：函数内容以冒号起始，并且缩进。 5.返回值：return [表达式] 结束函数。不带表达式的return相当于返回 None def 函数名(参数1,参数2,*args,默认参数,**kwargs): \"\"\"注释：函数功能和参数说明\"\"\" 函数体 …… return 返回值 1.函数名() 函数名后面+圆括号就是函数的调用。 2.参数： 圆括号用来接收参数。 若传入多个参数： 应按先位置传值，再按关键字传值 具体的传入顺序应按照函数定义的参数情况而定 3.返回值 如果函数有返回值，还应该定义\"变量\"接收返回值 如果返回值有多个，也可以用多个变量来接收，变量数应和返回值数目一致 无返回值的情况： 函数名() 有返回值的情况： 变量 = 函数名() 多个变量接收多返回值： 变量1，变量2，... = 函数名() ","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 函数","uri":"/2017/12/27/cnblog_8124173/"},{"categories":["笔记","博客园"],"content":"这是👉Win10(PowerShell)下Python命令行tab自动补全👈的摘要 **用Python，直接通过命令行的方式进行调试简单的程序。 **\nwin10（PowerShell）奈何没有Tab补全，操作实在麻烦。\n网上搜一下学会了，记录一下，复习用，哈哈哈\n环境：win10 64位 python2,python3 一：安装pyreadline模块 pip install pyreadline # python2 pip3 install pyreadline # python3 二、编写tab.py 文件保存在..\\Python2\\Lib\\tab.py\n例如：D:\\Program Files\\Python2\\Lib\\tab.py python2 python3要使用TAb自动补全都要在对应的lib中建立tab.py文件 #python Tab import sys import readline import rlcompleter import atexit import os readline.parse_and_bind('tab: complete') # windows histfile = os.path.join(os.environ['HOMEPATH'], '.pythonhistory') # linux # histfile = os.path.join(os.environ['HOME'], '.pythonhistory') try: readline.read_history_file(histfile) except IOError: pass atexit.register(readline.write_history_file, histfile) del os, histfile, readline, rlcompleter 三、效果测试 使用import tab引入tab补全\n# python2\n# python3\n经测试发现，python2 需要import tab 才支持自动补全，然后python3不需要导入tab就可以支持自动补全，不知道是不是我的比较特殊😂","description":"","tags":["博客园","搬家","cnblogs"],"title":"Win10(PowerShell)下Python命令行tab自动补全","uri":"/2017/12/26/cnblog_8116853/"},{"categories":["笔记","博客园"],"content":"这是👉python文件操作👈的摘要 python/文件操作:\n1.打开文件 1\n2\n3\n|\n使用``open``()\n文件句柄 ``= open``(``'文件路径'``, ``'模式'``)\n---|---\n2.文件操作 1\n|\n打开文件时，需要指定文件路径和以何等方式打开文件，\n打开后，即可获取该文件句柄，日后通过此文件句柄对该文件操作。\n---|---\n打开文件的模式有： r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】 w，只写模式【不可读；不存在则创建；存在则清空内容】 x， 只写模式【不可读；不存在则创建，存在则报错】 a， 追加模式【可读； 不存在则创建；存在则只追加内容】 \"+\" 表示可以同时读写某个文件 r+， 读写【可读，可写】 w+，写读【可读，可写】 x+ ，写读【可读，可写】 a+， 写读【可读，可写】 \"b\"表示以字节的方式操作 rb 或 r+b wb 或 w+b xb 或 w+b ab 或 a+b 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码 3.关闭文件 使用close() 补充：with语句自带使用close()方法, 这也是为了防止打开文件忘记关闭 比如： with open() as f_read:#打开文件 是不需要添加close()的。 二.文件操作\n1.read 文件名.read(n)：读取指定个数的字符，文件从光标位置开始 注意：python3版本读取的是字符 python2版本读取的是字节 在读取完第一次字符时，第二次读取从上次读取完的字符开始 比如： f.readline 读取一行，光标到下一行行首 f.readlines 显示列表结果，每一个元素是一行内容 行与字符串的拼接 使用join用法 文件名.join([文件名，\"需要添加的字符串\"]) 循环整个文件，并在一行中拼接使用for循环 2.write f =open(name,mode=w) 修改文件可读权限 文件名.write(\"\") 覆盖文件信息 文件名.write(\"\\n\") 换行 f =open(name,mode=\"a\")追加信息，原来文件信息不变 f =open(name,mode=\"x\")原有的文件不覆盖，会报错；没有的文件重新创建 f=write(\"\")把内容添加到内存，在一定时间内显示出来 f.writelines([\"11\\n\",\"22\\n\"])写多行 f.truncate() 截断 只能在写权限操作 **3.可读可写模式： ** f = open(\"test\",mode=\"r\",encoding=\"utf8\") data = f.read(5) data2 = f.read(6) print(data) print(data2) 得到的答案是 globa l r+ 追加写 默认光标在开始位置 w+ 首先会覆盖,清空，然后再写，seek调整 a+ 总是在最后位置添加。光标在文件最后位置 无论光标在什么位置，一定是追加写： 想读取内容：seek调增 4.flush操作 f=flush(\"\") 直接显示,内容直接存储在硬盘上 比如： 进度条操作 sys.stdout.write(\"\")相当于print sys.stdout 文件 循环打印# import sys for i in range(10): sys.stdout.write(\"#\") sys.stdout.flush() import time time.sleep(0.5) 显示百分比 import sys for i in range(6): s = \"\\r%s%% %s\"%(i,\"?\"*i) sys.stdout.write(s) sys.stdout.flush() import time time.sleep(0.5) 二.其他操作\n**1.tell和seek：** 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n|\n``tell：查询文件中光标位置\n``seek：光标定位\nf = open(``'file'``,``'r'``)\nprint(f.tell()) #光标默认在起始位置\nf.seek(10) #把光标定位到第10个字符之后\nprint(f.tell()) #输出10\nf.close()\n----------------------\nf = open(``'file'``,``'w'``)\nprint(f.tell()) #先清空内容，光标回到0位置\nf.seek(10) print(f.tell())\nf.close()\n----------------------\nf = open(``'file'``,``'a'``)\nprint(f.tell()) #光标默认在最后位置\nf.write（``'你好 世界'``）\nprint(f.tell()) #光标向后9个字符，仍在最后位置\nf.close()\n---|---\n**2.flush 同步将数据从缓冲转移到磁盘：** 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n|\n示例，实现进度条功能\nimport sys,time #导入sys和time模块\nfor i ``in range(40):\n``sys.stdout.write(``'*'``)\n``sys.stdout.flush() #flush的作用相当于照相，拍一张冲洗一张\n``time.sleep(0.2)\n下面代码也能够实现相同的功能\nimport time\nfor i ``in range(40):\n``print(``'*'``,end=``''``,flush=True) #print中的flush参数\n``time.sleep(0.2)\n---|---\n**2.truncate 截断：** 1\n2\n3\n4\n5\n6\n7\n8\n|\n不能是r模式下执行，\nw模式下，已经清空所有数据，使用truncate没有任何意义，\na模式下，截断指定位置后的内容。\n``f = open(``'file'``,``'a'``)\n``f.truncate(6) #只显示6个字节的内容（6个英文字符或三个汉字），后面的内容被清空。\n---|---\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python文件操作","uri":"/2017/12/25/cnblog_8110891/"},{"categories":["笔记","博客园"],"content":"这是👉python 集合 深浅拷贝👈的摘要 一，集合。 集合是无序的，不重复的数据集合，它里面的元素是可哈希的(不可变类型)，但是集合本身是不可哈希（所以集合做不了字典的键）的。以下是集合最重要的两点：\n去重，把一个列表变成集合，就自动去重了。\n关系测试，测试两组数据之前的交集、差集、并集等关系。\n1，集合的创建。\nset1 = set({1, 2, 3, 4, 5, \"hh\"}) set2 = {1, 2, 3, 4, 5, \"hh\"} print(set1,set2) # {1, 2, 3, 4, 5, 'hh'} {1, 2, 3, 4, 5, 'hh'} 2，集合的增。\nset1 = {'alex','wusir','ritian','egon','barry'} set1.add('景女神') print(set1) #update：迭代着增加 set1.update('A') print(set1) set1.update('老师') print(set1) set1.update([1,2,3]) print(set1) 3，集合的删。\nset1 = {'alex','wusir','ritian','egon','barry'} set1.remove('alex') # 删除一个元素 print(set1) set1.pop() # 随机删除一个元素 print(set1) set1.clear() # 清空集合 print(set1) del set1 # 删除集合 print(set1) 4，集合的其他操作：\n4.1 交集。（\u0026 或者 intersection）\nset1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1 \u0026 set2) # {4, 5} print(set1.intersection(set2)) # {4, 5} 4.2 并集。（| 或者 union）\nset1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1 | set2) # {1, 2, 3, 4, 5, 6, 7} print(set2.union(set1)) # {1, 2, 3, 4, 5, 6, 7} 4.3 差集。（- 或者 difference）\nset1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1 - set2) # {1, 2, 3} print(set1.difference(set2)) # {1, 2, 3} 4.4反交集。 （^ 或者 symmetric_difference）\nset1 = {1,2,3,4,5} set2 = {4,5,6,7,8} print(set1 ^ set2) # {1, 2, 3, 6, 7, 8} print(set1.symmetric_difference(set2)) # {1, 2, 3, 6, 7, 8} 4.5子集与超集\nset1 = {1,2,3} set2 = {1,2,3,4,5,6} print(set1 \u003c set2) print(set1.issubset(set2)) # 这两个相同，都是说明set1是set2子集。 print(set2 \u003e set1) print(set2.issuperset(set1)) # 这两个相同，都是说明set2是set1超集。 5，frozenset不可变集合，让集合变成不可变类型。\ns = frozenset('barry') print(s,type(s)) # frozenset({'a', 'y', 'b', 'r'}) \u003cclass 'frozenset'\u003e 二，深浅copy 1，先看赋值运算。\nl1 = [1,2,3,['barry','alex']] l2 = l1 l1[0] = 111 print(l1) # [111, 2, 3, ['barry', 'alex']] print(l2) # [111, 2, 3, ['barry', 'alex']] l1[3][0] = 'wusir' print(l1) # [111, 2, 3, ['wusir', 'alex']] print(l2) # [111, 2, 3, ['wusir', 'alex']] 对于赋值运算来说，l1与l2指向的是同一个内存地址，所以他们是完全一样的。\n2，浅拷贝copy。\nl1 = [1,2,3,['barry','alex']] l2 = l1.copy() print(l1,id(l1)) # [1, 2, 3, ['barry', 'alex']] 2380296895816 print(l2,id(l2)) # [1, 2, 3, ['barry', 'alex']] 2380296895048 l1[1] = 222 print(l1,id(l1)) # [1, 222, 3, ['barry', 'alex']] 2593038941128 print(l2,id(l2)) # [1, 2, 3, ['barry', 'alex']] 2593038941896 l1[3][0] = 'wusir' print(l1,id(l1[3])) # [1, 2, 3, ['wusir', 'alex']] 1732315659016 print(l2,id(l2[3])) # [1, 2, 3, ['wusir', 'alex']] 1732315659016 对于浅copy来说，第一层创建的是新的内存地址，而从第二层开始，指向的都是同一个内存地址，所以，对于第二层以及更深的层数来说，保持一致性。\n3，深拷贝deepcopy。\nimport copy l1 = [1,2,3,['barry','alex']] l2 = copy.deepcopy(l1) print(l1,id(l1)) # [1, 2, 3, ['barry', 'alex']] 2915377167816 print(l2,id(l2)) # [1, 2, 3, ['barry', 'alex']] 2915377167048 l1[1] = 222 print(l1,id(l1)) # [1, 222, 3, ['barry', 'alex']] 2915377167816 print(l2,id(l2)) # [1, 2, 3, ['barry', 'alex']] 2915377167048 l1[3][0] = 'wusir' print(l1,id(l1[3])) # [1, 222, 3, ['wusir', 'alex']] 2915377167240 print(l2,id(l2[3])) # [1, 2, 3, ['barry', 'alex']] 2915377167304 对于深copy来说，两个是完全独立的，改变任意一个的任何元素（无论多少层），另一个绝对不改变。\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 集合 深浅拷贝","uri":"/2017/12/22/cnblog_8085041/"},{"categories":["笔记","博客园"],"content":"这是👉python小整数与str数据池，编码关系👈的摘要 1、小数据池：数字，字符串\n数字的范围-5 ---256\n字符串：1，不能有特殊字符\n2，s20 还是一个地址，s21以后都是两个地址\n2、编码关系：ascii\nA : 00000010 8位 一个字节 unicode A : 00000000 00000001 00000010 00000100 32位 四个字节 中：00000000 00000001 00000010 00000110 32位 四个字节 utf-8 A : 00100000 8位 一个字节 中 : 00000001 00000010 00000110 24位 三个字节 gbk A : 00000110 8位 一个字节 中 : 00000010 00000110 16位 两个字节 1，各个编码之间的二进制，是不能互相识别的，会产生乱码。 2，文件的储存，传输，不能是unicode（只能是utf-8 utf-16 gbk,gb2312,ascii等） ** py3: ** str 在内存中是用unicode编码。 bytes类型 对于英文： str ：表现形式：s = 'alex' 编码方式： 010101010 unicode bytes ：表现形式：s = b'alex' 编码方式： 000101010 utf-8 gbk。。。。 对于中文： str ：表现形式：s = '中国' 编码方式： 010101010 unicode bytes ：表现形式：s = b'x\\e91\\e91\\e01\\e21\\e31\\e32' 编码方式： 000101010 utf-8 gbk.... ** 3、is 与== 区别** is判断的是a对象是否就是b对象，是通过id来判断的\n==判断的是a对象的值是否和b对象的值相等，是通过value来判断的\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python小整数与str数据池，编码关系","uri":"/2017/12/22/cnblog_8084380/"},{"categories":["笔记","博客园"],"content":"这是👉python 字典的操作👈的摘要 可变类型与不可变类型 （字典的键必须是不可变类型的即时可哈希的） 不可变类型，值不可以改变：（可哈希）\n数值类型 int, long, bool, float 字符串 str 元组 tuple 可变类型，值可以改变：（不可哈希）\n列表 list 字典 dict 字典的常见操作：\n#增加\n变量名['键'] = 数据\n如果在使用 变量名['键'] = 数据 时，这个\"键\"在字典中，存在，覆盖这个键值对。不存在，那么就会新增这个元素\ndict.setdefault(\"键值\"，\"数据\")\n有键值对不做任何操作，没有键值就会增加\n删除 dict.pop(\"键值\")\n有返回值，按键删除，如果没有此建会报错\ndict.pop（\"键值\", None）\n按键删除，None可换成提示，没有键值会返回提示，有键值会直接删除\ndict.popitem()\n在不同python版本中不同：\npython3.6之前dict={x:x}print打印无序的，popitem()删除的时候是删除打印后的第一个\npython3.6 dict打印是有序的，即如何设置的就如何打印，popitem()删除的时候就是删除的最后一个\ndict.clear()\n清空字典\ndel dict[键值]\ndel可以删除整个字典，也可以按键删除\n修改 dict[\"键值\"]=val\n直接根据键值对其赋值，如果键值不存在，会直接增加对应键值对\ndict.update(dict1)\n把dict1 的键值对覆盖到dict中\n查找 dict.keys()\n遍历键值\ndict.values()\n遍历值\ndict.item()\n遍历元素\ndict.get(\"键值\")\n根据键值查找值，可以自定义返回值，未找到时有返回值，比如dict.get(\"键值\"，\"未找到\")\ndict[\"键值\"]\n找不到报错，找到返回对应的值\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 字典的操作","uri":"/2017/12/20/cnblog_8073028/"},{"categories":["笔记","博客园"],"content":"这是👉python 列表的常见操作👈的摘要 列表的相关操作 列表中存放的数据是可以进行修改的，比如\"增\"、\"删\"、\"改\"\"\n\u003c1\u003e添加元素(\"增\"append, extend, insert) append 通过append可以向列表添加元素\nextend 通过extend可以将另一个集合中的元素逐一添加到列表中\ninsert insert(index, object) 在指定位置index前插入元素object\n\u003c2\u003e修改元素(\"改\") 修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改\n\u003c3\u003e查找元素(\"查\"in, not in, index, count) 所谓的查找，就是看看指定的元素是否存在\nin, not in python中查找的常用方法为：\nin（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false index, count index和count与字符串中的用法相同\n\u003c4\u003e删除元素(\"删\"del, pop, remove) 类比现实生活中，如果某位同学调班了，那么就应该把这个条走后的学生的姓名删除掉；在开发中经常会用到删除这种功能。\n列表元素的常用删除方法有：\ndel：根据下标进行删除 pop：删除最后一个元素 remove：根据元素的值进行删除 del list[num]\nlist.pop(\"xxx\")\n注：有返回值，返回删除的值\nlist.remove(\"xxx\")\n\u003c5\u003e排序(sort, reverse) sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。\nreverse方法是将list逆置。\nlist.sort()\nlist.reverse()\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 列表的常见操作","uri":"/2017/12/19/cnblog_8064765/"},{"categories":["笔记","博客园"],"content":"这是👉python字符串Str方法👈的摘要 \u003c1\u003efind 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1\n使用方法：str.find(\"xx\",0,len(str))\n\u003c2\u003eindex 跟find()方法一样，只不过如果str不在 mystr中会报一个异常.\n使用方法：str.index(\"xx\")\n\u003c3\u003ecount 返回 str在start和end之间 在 mystr里面出现的次数\n使用方法：str.count(\"xx\",0,len(str))\n\u003c4\u003ereplace 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.\n使用方法：str.replace(str1, str2, str.count(str1))\n\u003c5\u003esplit 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串\n使用方法：str.split(\" \", 2)\n\u003c6\u003ecapitalize 把字符串的第一个字符大写\n使用方法：str.capitalize()\n\u003c7\u003etitle 把字符串的每个单词首字母大写\n使用方法：str.title()\n\u003c8\u003estartswith 检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False\n使用方法：str.starswith(\"obj\")\n\u003c9\u003eendswith 检查字符串是否以obj结束，如果是返回True,否则返回 False.\n使用方法：str.endswith(\"obj\")\n\u003c10\u003elower 转换 mystr 中所有大写字符为小写\n使用方法：str.lower()\n\u003c11\u003eupper 转换 mystr 中的小写字母为大写\n使用方法：str.upper()\n\u003c12\u003eljust 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串\n使用方法：str.ljust(5)\n\u003c13\u003erjust 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串\n使用方法：str.rjust(width)\n\u003c14\u003ecenter 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串\n使用方法：str.center(width)\n\u003c15\u003elstrip 删除 str 左边的空白字符\n使用方法：str.lstrip()\n\u003c16\u003erstrip 删除 str 字符串末尾的空白字符\n使用方法：str.rstrip()\n\u003c17\u003estrip 删除str字符串两端的空白字符\n使用方法：str.strip()\n\u003c18\u003erfind 类似于 find()函数，不过是从右边开始查找.\n使用方法：str.rfind(\"xx\")\n\u003c19\u003erindex 类似于 index()，不过是从右边开始.\n使用方法：str.rindex(\"xx\")\n\u003c20\u003epartition 把mystr以str分割成三部分,str前，str和str后\n使用方法：mystr.partition(str)\n\u003c21\u003erpartition 类似于 partition()函数,不过是从右边开始.\n使用方法：mystr.rpartition(str)\n\u003c22\u003esplitlines 按照行分隔，返回一个包含各行作为元素的列表\n使用方法：mystr.splitlines()\n\u003c23\u003eisalpha 如果 mystr 所有字符都是字母 则返回 True,否则返回 False\n使用方法：str.isalpha()\n\u003c24\u003eisdigit 如果 mystr 只包含数字则返回 True 否则返回 False.\n使用方法：str.isdigit()\n\u003c25\u003eisalnum 如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False\n使用方法：str.isalnum()\n\u003c26\u003eisspace 如果 mystr 中只包含空格，则返回 True，否则返回 False.\n使用方法：str.isspace()\n\u003c27\u003ejoin mystr 中每个字符后面插入str,构造出一个新的字符串\n使用方法：str.join(str)\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python字符串Str方法","uri":"/2017/12/19/cnblog_8063941/"},{"categories":["笔记","博客园"],"content":"这是👉python 的基础数据类型👈的摘要 Number（数字）\nString（字符串） List（列表） Tuple（元组） Sets（集合） Dictionary（字典） 使用type()可以查看变量类型\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python 的基础数据类型","uri":"/2017/12/19/cnblog_8063770/"},{"categories":["笔记","博客园"],"content":"这是👉win10 下的python虚拟环境安装使用（使用powershell）👈的摘要 安装virtualenv 若要使用python虚拟环境进行开发，首先需要安装virtualenv。\n命令： pip install virtualenv\n我已经装过了😁\n创建虚拟环境 命令： virtualenv [自定义虚拟环境名称]\n运行完以后会在当前路径下生成你的虚拟环境\n还有另外一种创建虚拟环境的命令，上面是默认的使用python3\n如果想使用指定的python版本创建虚拟环境 命令如下：\nvirtualenv -p [python所在的路径+python运行文件的名字（加后缀名）] + 虚拟环境名\n同样能达到效果\n激活虚拟环境 命令： [虚拟环境名称]\\scripts\\activate\n可能有点慢😥\n退出虚拟环境： 命令： deactivate\n删除虚拟环境，直接删除环境目录就可以了，简单粗暴\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"win10 下的python虚拟环境安装使用（使用powershell）","uri":"/2017/12/18/cnblog_8056860/"},{"categories":["笔记","博客园"],"content":"这是👉python运算符优先级👈的摘要 对于or与and运算\n其一, 在不加括号时候, and优先级大于or\n其二, x or y 的值只可能是x或y. x为真就是x, x为假就是y\n第三, x and y 的值只可能是x或y. x为真就是y, x为假就是x\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"python运算符优先级","uri":"/2017/12/18/cnblog_8056277/"},{"categories":["笔记","博客园"],"content":"这是👉gbk,utf-8,unicode编码，单位换算👈的摘要 Unicode 英文，中文都是用两个字节\nutf-8 英文是1个字节，中文用3个字节\nGbk 英文是1个字节，中文是2个字节\nBit,Bytes,Kb,Mb,Gb,Tb之间的转换关系。\n8Bit = 1Bytes\n1024Bytes = 1Kb\n1024Kb = 1Mb\n1024Mb = 1Gb\n1024GB = 1TB\n","description":"","tags":["博客园","搬家","cnblogs"],"title":"gbk,utf-8,unicode编码，单位换算","uri":"/2017/12/18/cnblog_8056251/"}]