<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#333333">
    <meta name="msapplication-TileColor" content="#333333">
    
    
    
    <meta name="google-site-verification" content="LY-yWUgw7WEmNuBW7lLOj8jSiKZEVgOCmsisfGWtZCg">
    
    
    <meta name="msvalidate.01" content="1A54BC0D6A4D102B72F2A0E9870611FA" />
    
    
    <meta name="keywords" content="Weii, Wevsmy, Wilson, Python, Golang, PyQt5, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#333333">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="wilson's blog" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          $(e).before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout with line number.
              return trigger.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          $(e).parent().before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout without line number.
              return trigger.nextElementSibling.firstChild;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <script type="text/javascript" src="/js/love.js"></script>
    <title>MySQL 之 索引原理与慢查询优化 | wilson's blog - Life is short, you need Python</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #333333;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">wilson's blog</a></h1>
        <h2 class="subtitle">Life is short, you need Python</h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://bolg.weii.ink/2018/02/28/cnblog_8485214/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="wilson">
       <meta itemprop="description" content="٩(๑❛ᴗ❛๑)۶">
       <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="wilson's blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">MySQL 之 索引原理与慢查询优化</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-02-28T10:47:00+08:00">2018-02-28 10:47:00</time></span>
        </span>
        

        
        <span class="post-updated">
           <span class="post-meta-divider divider">|</span>
           <i class="far fa-calendar-edit"></i>
           <span>
              <time title="post-updated" itemprop="dateUpdated datePublished" datetime="2019-06-10T19:54:42+08:00">
                2019-06-10 19:54:42
              </time>
           </span>
        </span>
        

        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/笔记/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/笔记/博客园/" itemprop="url" rel="index"><span itemprop="name">博客园</span></a></span>
        </span>
        
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-comment-count">
          <i class="far fa-comments"></i><span><a href="/2018/02/28/cnblog_8485214/#disqus_thread" itemprop="discussionUrl"><span class="post-comment-count disqus-comment-count" data-disqus-identifier="2018/02/28/cnblog_8485214/" itemprop="commentCount"></span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h1 id="这是👉MySQL-之-索引原理与慢查询优化👈的摘要"><a href="#这是👉MySQL-之-索引原理与慢查询优化👈的摘要" class="headerlink" title="这是👉MySQL 之 索引原理与慢查询优化👈的摘要"></a><a href="/2018/02/28/cnblog_8485214/">这是👉MySQL 之 索引原理与慢查询优化👈的摘要</a></h1><a id="more"></a>
<h1 id="浏览目录"><a href="#浏览目录" class="headerlink" title="浏览目录"></a><a href="http://www.cnblogs.com/wangfengming/articles/8092914.html" target="_blank" rel="noopener"></a>浏览目录</h1><ul>
<li><strong>一  索引介绍</strong></li>
<li><strong>二  索引类型</strong></li>
<li><strong>三  索引分类</strong></li>
<li><strong>四  聚合索引和辅助索引 </strong></li>
<li><strong>五  测试索引</strong></li>
<li><strong>六  正确使用索引</strong></li>
<li><strong>七  组合索引</strong></li>
<li><strong>八  注意事项</strong></li>
<li><strong>九  查询计划</strong></li>
<li><strong>十  慢日志查询</strong></li>
<li><strong>十一  大数据量分页优化</strong></li>
</ul>
<h2 id="1-索引介绍"><a href="#1-索引介绍" class="headerlink" title="1. 索引介绍"></a>1. 索引介绍</h2><blockquote>
</blockquote>
<p>一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。  </p>
<blockquote>
<p>说起加速查询，就不得不提到索引了。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>什么索引:</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>简单的说,相当于图书的目录,可以帮助用户快速的找到需要的内容.</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p>在MySQL中也叫做”键”，是存储引擎用于快速找到记录的一种数据结构。能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍.  </p>
<blockquote>
</blockquote>
<h2 id="2-索引类型"><a href="#2-索引类型" class="headerlink" title="2.索引类型"></a>2.索引类型</h2><blockquote>
<p><strong>1. BTREE 类型</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong><em>就是一种将索引值按一定的算法，存入一个树形的数据结构中.(如下图:)</em></strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>#####<br><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171224192713225-1028521247.png" alt=""></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一磁盘块中的数据会被一次性读取出来，而不是按需读取。InnoDB<br>存储引擎使用页作为数据读取单位，页是其磁盘管理的最小单位，默认 page 大小是 16kB。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p>如上图，是一颗b+树，关于b+树的定义可以参见<a href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<blockquote>
</blockquote>
<blockquote>
<p><strong>b+树的查找过程</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<blockquote>
</blockquote>
<blockquote>
<p><strong>  注意:1.索引字段要尽量的小,磁盘块可以存储更多的索引.</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>   2. </strong>索引最左匹配特性<em>**</em></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>  2. HASH 类型</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>_hash就是一种（key=<br>value）形式的键值对,允许多个key对应相同的value，但不允许一个key对应多个value,为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据.<br>_ <em>hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率.</em></strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171223131106459-1539286084.png" alt=""></p>
<blockquote>
</blockquote>
<blockquote>
<p>假设索引使用hash函数f( )，如下：</p>
</blockquote>
<blockquote>
<pre><code>f(&apos;Arjen&apos;) = 2323
</code></pre></blockquote>
<blockquote>
<pre><code>f(&apos;Baron&apos;) = 7437
</code></pre></blockquote>
<blockquote>
<pre><code>f(&apos;Peter&apos;) = 8784
</code></pre></blockquote>
<blockquote>
<pre><code>f(&apos;Vadim&apos;) = 2458
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>此时，索引的结构大概如下：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><img src="https://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql02-03.JPG" alt=""></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<pre><code>**3.HASH与BTREE比较:**
</code></pre></blockquote>
<blockquote>
<pre><code>hash类型的索引：查询单条快，范围查询慢
</code></pre></blockquote>
<blockquote>
<pre><code>btree类型的索引：b+树，层数越多，数据量越大,范围查询和随机查询快（innodb默认索引类型）
</code></pre></blockquote>
<blockquote>
<pre><code>不同的存储引擎支持的索引类型也不一样
</code></pre></blockquote>
<blockquote>
<pre><code>InnoDB 支持事务，支持行级别锁定，支持 Btree、Full-text 等索引，不支持 Hash 索引；
</code></pre></blockquote>
<blockquote>
<pre><code>MyISAM 不支持事务，支持表级别锁定，支持 Btree、Full-text 等索引，不支持 Hash 索引；
</code></pre></blockquote>
<blockquote>
<pre><code>Memory 不支持事务，支持表级别锁定，支持 Btree、Hash 等索引，不支持 Full-text 索引；
</code></pre></blockquote>
<blockquote>
<pre><code>NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 Btree、Full-text 等索引；
</code></pre></blockquote>
<blockquote>
<pre><code>Archive 不支持事务，支持表级别锁定，不支持 Btree、Hash、Full-text 等索引；
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3.索引分类"></a>3.索引分类</h2><blockquote>
<p>MySQL中常见索引有：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ul>
<li>普通索引</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>唯一索引</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>主键索引</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>组合索引</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>全文索引</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h5></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>普通索引仅有一个功能：加速查询</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>#创建表同时添加name字段为普通索引
</code></pre></blockquote>
<blockquote>
<pre><code>create table tb1(
</code></pre></blockquote>
<blockquote>
<pre><code>id int not null auto_increment primary key,
</code></pre></blockquote>
<blockquote>
<pre><code>name varchar(100) not null,
</code></pre></blockquote>
<blockquote>
<pre><code>   index idx_name(name)  
);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建表+索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>#单独为表指定普通索引
</code></pre></blockquote>
<blockquote>
<pre><code>create index idx_name on tb1(name);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>drop index idx_name on tb1;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>删除索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>show index from tb1;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>查看索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h5></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>唯一索引有两个功能：加速查询 和 唯一约束（可含一个null 值）</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>create table tb2(
</code></pre></blockquote>
<blockquote>
<pre><code>id int not null auto_increment primary key,
</code></pre></blockquote>
<blockquote>
<pre><code>name varchar(50) not null,
</code></pre></blockquote>
<blockquote>
<pre><code>age int not null,
</code></pre></blockquote>
<blockquote>
<pre><code>  unique index idx_age (age)  
)
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建表+唯一(unique)索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>create unique index idx_age on tb2(age);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建unique索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>drop unique  index idx_age on tb2;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>删除unique索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h5></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p> 主键有两个功能：加速查询 和 唯一约束（不可含null）</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p> 注意:一个表中最多只能有一个主键索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>#方式一:
</code></pre></blockquote>
<blockquote>
<pre><code>create table tb3(
</code></pre></blockquote>
<blockquote>
<pre><code>id int not null auto_increment primary key,
</code></pre></blockquote>
<blockquote>
<pre><code>name varchar(50) not null,
</code></pre></blockquote>
<blockquote>
<pre><code>age int default 0
</code></pre></blockquote>
<blockquote>
<pre><code>);
</code></pre></blockquote>
<blockquote>
<pre><code>#方式二:
</code></pre></blockquote>
<blockquote>
<pre><code>create table tb3(
</code></pre></blockquote>
<blockquote>
<pre><code>id int not null auto_increment,
</code></pre></blockquote>
<blockquote>
<pre><code>name varchar(50) not null,
</code></pre></blockquote>
<blockquote>
<pre><code>age int default 0 ,
</code></pre></blockquote>
<blockquote>
<pre><code>primary key(id)
</code></pre></blockquote>
<blockquote>
<pre><code>);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建表 + 创建主键</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>alter table tb3 add primary key(id);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建主键</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>#方式一
</code></pre></blockquote>
<blockquote>
<pre><code>alter table tb3 drop primary key;
</code></pre></blockquote>
<blockquote>
<pre><code>#方式二:
</code></pre></blockquote>
<blockquote>
<pre><code>#如果当前主键为自增主键,则不能直接删除.需要先修改自增属性,再删除
</code></pre></blockquote>
<blockquote>
<pre><code>alter table tb3 modify id int ,drop primary key;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>删除主键</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="4-组合索引"><a href="#4-组合索引" class="headerlink" title="4.组合索引"></a>4.组合索引</h5></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>组合索引是将n个列组合成一个索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = ‘alex’ and n2 = 666。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>create table tb4(
</code></pre></blockquote>
<blockquote>
<pre><code>id int not null primary key,
</code></pre></blockquote>
<blockquote>
<pre><code>name varchar(50),
</code></pre></blockquote>
<blockquote>
<pre><code>age int,
</code></pre></blockquote>
<blockquote>
<pre><code>sex char(1),
</code></pre></blockquote>
<blockquote>
<pre><code>index idx_age_sex(age,sex)
</code></pre></blockquote>
<blockquote>
<pre><code>);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建表+组合索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>create index idx_age_sex on tb4(age,sex);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建组合索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>drop index idx_age_sex on tb4;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>删除组合索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="5-全文索引-了解"><a href="#5-全文索引-了解" class="headerlink" title="5.全文索引(了解)"></a>5.全文索引(了解)</h5></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用 [分词技术]<br>等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>强烈注意</strong> ：MySQL自带的全文索引只能用于数据库引擎为 <strong> <em>MyISAM</em></strong><br>的数据表，如果是其他数据引擎，则全文索引不会生效。此外，MySQL(5.6版本之前)自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，可以采用一些外部工具来完成.。比如采用Sphinx来做mysql的全文索引工具是一个很好的选择。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>介绍索引创建的原则:
</code></pre></blockquote>
<blockquote>
<pre><code>可以创建索引:
</code></pre></blockquote>
<blockquote>
<pre><code>1.    字段经常出现在where子句或者连接条件中
</code></pre></blockquote>
<blockquote>
<pre><code>2.    字段识别度高
</code></pre></blockquote>
<blockquote>
<pre><code>3.    表经常被访问、数据量很大，且通常每次访问的数据量小于记录总量的2%-4%
</code></pre></blockquote>
<blockquote>
<pre><code>不用创建索引:
</code></pre></blockquote>
<blockquote>
<pre><code>1.    表很小的情况下，没有必要使用索引
</code></pre></blockquote>
<blockquote>
<pre><code>2.    不经常在Where后使用的字段
</code></pre></blockquote>
<blockquote>
<pre><code>3.    字段的识别度低(比如性别)
</code></pre></blockquote>
<blockquote>
<pre><code>4.    如果表数据需要频繁修改，不建议使用索引
</code></pre></blockquote>
<blockquote>
<pre><code>5.    如果查询返回记录很多(每次访问的数据量大于记录总数的2%-4%)，不建议使用索引
</code></pre></blockquote>
<blockquote>
<pre><code>6.    如果where后含IS NULL /IS NOT NULL/ like &apos;%输入符%&apos;等条件，不建议使用索引。
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>索引创建的原则</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<h2 id="4-聚合索引和辅助索引"><a href="#4-聚合索引和辅助索引" class="headerlink" title="4.聚合索引和辅助索引"></a>4.聚合索引和辅助索引</h2><blockquote>
<p><strong>数据库中的B+树索引可以分为聚集索引和辅助索引.</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>聚集索引 ：InnoDB表 索引组织表，即表中数据按主键B+树存放，叶子节点直接存放整条数据，每张表只能有一个聚集索引。</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>1.当你定义一个主键时，InnnodDB存储引擎则把它当做聚集索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>2.如果你没有定义一个主键，则InnoDB定位到第一个唯一索引，且该索引的所有列值均飞空的，则将其当做聚集索引。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>3如果表没有主键或合适的唯一索引INNODB会产生一个隐藏的行ID值6字节的行ID聚集索引，</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>补充：由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能有一个聚集索引，聚集索引对于主键的排序和范围查找非常有利.</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>例子:<br>比如图书馆新进了一批书。那么这些书需要放到图书馆内。书如何放呢？一般都有一个规则，杂志类的放到101房间，文学类的放到102房间，理工类的放到103房间等等。这些存储的规则决定了每本书应该放到哪里。而这个例子中聚集索引为书的类别。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>辅助索引：</strong><br>（也称非聚集索引）是指叶节点不包含行的全部数据，叶节点除了包含键值之外，还包含一个书签连接，通过该书签再去找相应的行数据。下图显示了InnoDB存储引擎辅助索引和聚集索引的关系：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><img src="http://img.blog.csdn.net/20130613111257656" alt=""></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p>从上图中可以看出，辅助索引叶节点存放的是主键值，获得主键值后，再从聚集索引中查找整行数据。举个例子，如果在一颗高度为3的辅助索引中查找数据，首先从辅助索引中获得主键值（3次IO），接着从高度为3的聚集索引中查找以获得整行数据（3次IO），总共需6次IO。一个表上可以存在多个辅助索引。</p>
<blockquote>
</blockquote>
<blockquote>
<p>  例子: 同学如果想去图书馆找一本书，而不知道这本书在哪里？那么这个同学首先应该找的就是<br>检索室吧。对于要查找一本书来说，在检索室查是一个非常快捷的的途径了吧。但是，在检索室中你查到了该书在XX室XX书架的信息。你的查询结束了吗？没有吧。你仅仅找到了目的书的位置信息，你还要去该位置去取书。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>对于这种方式来说，你需要两个步骤：<br> 1、查询该记录所在的位置。<br> 2、通过该位置去取要找的记录。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>总结二者区别:</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>**不同的是：聚集索引叶子结点存放的是一整行的信息,而辅助索引 </strong> <strong>叶子结点存放的是单个索引列信息.<strong>**</strong></strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>为了阐述非聚集索引写性能问题，我们先来看一个例子：
</code></pre></blockquote>
<blockquote>
<pre><code>mysql&gt;create table t (
</code></pre></blockquote>
<blockquote>
<pre><code>id int auto_increment,
</code></pre></blockquote>
<blockquote>
<pre><code>name varchar(30),
</code></pre></blockquote>
<blockquote>
<pre><code>primary key (id));
</code></pre></blockquote>
<blockquote>
</blockquote>
<p>我们创建了一个表，表的主键是id，id列式自增长的，即当执行插入操作时，id列会自动增长，页中行记录按id顺序存放，不需要随机读取其它页的数据。因此，在这样的情况下（即聚集索引），插入操作效率很高。</p>
<blockquote>
</blockquote>
<p>但是，在大部分应用中，很少出现表中只有一个聚集索引的情况，更多情况下，表上会有多个非聚集的（辅助索引）。比如，对于上一张表t，业务上还需要按非唯一的name字段查找，则表定义改为：</p>
<blockquote>
<pre><code>mysql&gt;create table t (
</code></pre></blockquote>
<blockquote>
<pre><code>id int auto_increment,
</code></pre></blockquote>
<blockquote>
<pre><code>name varchar(30),
</code></pre></blockquote>
<blockquote>
<pre><code>primary key (id),
</code></pre></blockquote>
<blockquote>
<pre><code>key (name));
</code></pre></blockquote>
<blockquote>
</blockquote>
<p>这时，除了主键聚合索引外，还产生了一个name列的辅助索引，对于该非聚集索引来说，叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。</p>
<blockquote>
</blockquote>
<blockquote>
<p>辅助索引写性能问题</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>何时使用聚集索引或非聚集索引</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>下面的表总结了何时使用聚集索引或非聚集索引（很重要）：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>动作描述</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>使用聚集索引</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>使用非聚集索引  </p>
<p>—|—|—  </p>
<p>列经常被分组排序</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应  </p>
<p>返回某范围内的数据</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>不应  </p>
<p>一个或极少不同值</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>不应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>不应  </p>
<p>小数目的不同值</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>不应  </p>
<p>大数目的不同值</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>不应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应  </p>
<p>频繁更新的列</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>不应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应  </p>
<p>外键列</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应  </p>
<p>主键列</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应  </p>
<p>频繁修改索引列</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>不应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>|</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<h2 id="5-测试索引"><a href="#5-测试索引" class="headerlink" title="5.测试索引"></a>5.测试索引</h2><blockquote>
<p><strong>1.创建数据</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>-- 1.创建表
</code></pre></blockquote>
<blockquote>
<pre><code>CREATE TABLE userInfo(
</code></pre></blockquote>
<blockquote>
<pre><code>id int NOT NULL,
</code></pre></blockquote>
<blockquote>
<pre><code>name VARCHAR(16) DEFAULT NULL,
</code></pre></blockquote>
<blockquote>
<pre><code>age int,
</code></pre></blockquote>
<blockquote>
<pre><code>sex char(1) not null,
</code></pre></blockquote>
<blockquote>
<pre><code>email varchar(64) default null
</code></pre></blockquote>
<blockquote>
<pre><code>)ENGINE=MYISAM DEFAULT CHARSET=utf8;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建表</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>注意:MYISAM存储引擎 不产生引擎事务，数据插入速度极快，为方便快速插入测试数据，等我们插完数据，再把存储类型修改为InnoDB</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong>**</strong>2.创建存储过程，插入数据<strong>**</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>-- 2.创建存储过程
</code></pre></blockquote>
<blockquote>
<pre><code>delimiter$$
</code></pre></blockquote>
<blockquote>
<pre><code>CREATE PROCEDURE insert_user_info(IN num INT)
</code></pre></blockquote>
<blockquote>
<pre><code>BEGIN
</code></pre></blockquote>
<blockquote>
<pre><code>DECLARE val INT DEFAULT 0;
</code></pre></blockquote>
<blockquote>
<pre><code>DECLARE n INT DEFAULT 1;
</code></pre></blockquote>
<blockquote>
<pre><code>-- 循环进行数据插入
</code></pre></blockquote>
<blockquote>
<pre><code>WHILE n &lt;= num DO
</code></pre></blockquote>
<blockquote>
<pre><code>set val = rand()*50;
</code></pre></blockquote>
<blockquote>
<pre><code>INSERT INTO
</code></pre><p>userInfo(id,name,age,sex,email)values(n,concat(‘alex’,val),rand()*50,if(val%2=0,’女’,’男’),concat(‘alex’,n,<a href="mailto:&#39;@qq.com" target="_blank" rel="noopener">&#39;@qq.com</a>‘));</p>
</blockquote>
<blockquote>
<pre><code>set n=n+1;
</code></pre></blockquote>
<blockquote>
<pre><code>end while;
</code></pre></blockquote>
<blockquote>
<pre><code>END $$
</code></pre></blockquote>
<blockquote>
<pre><code>delimiter;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>创建存储过程</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><strong><strong>3.调用存储过程,插入500万条数据</strong></strong></p>
</blockquote>
<blockquote>
<pre><code>call insert_user_info(5000000);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226094421369-1281265499.png" alt=""></p>
<blockquote>
</blockquote>
<blockquote>
<p>  <strong> </strong>4.此步骤可以忽略。修改引擎为INNODB<em>**</em></p>
</blockquote>
<blockquote>
<pre><code>ALTER TABLE userinfo ENGINE=INNODB;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226094602650-1078997557.png" alt=""></p>
<blockquote>
</blockquote>
<blockquote>
<p><strong>5.测试索引</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li>在没有索引的前提下测试查询速度</li>
</ol>
</blockquote>
<blockquote>
<pre><code>SELECT * FROM userinfo WHERE id = 4567890;
</code></pre></blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226100011322-1119889126.png" alt=""></p>
<blockquote>
</blockquote>
<p>注意:无索引情况,mysql根本就不知道id等于4567890的记录在哪里，只能把数据表从头到尾扫描一遍，此时有多少个磁盘块就需要进行多少IO操作，所以查询速度很慢.</p>
<blockquote>
</blockquote>
<blockquote>
<p>2.在表中已经存在大量数据的前提下，为某个字段段建立索引，建立速度会很慢</p>
</blockquote>
<blockquote>
<pre><code>CREATE INDEX idx_id on userinfo(id);
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226095723509-1270958485.png" alt=""></p>
<blockquote>
</blockquote>
<blockquote>
<p> 3.在索引建立完毕后，以该字段为查询条件时，查询速度提升明显</p>
</blockquote>
<blockquote>
<pre><code>select * from userinfo where id  = 4567890;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226100144572-1811075076.png" alt=""></p>
<blockquote>
</blockquote>
<blockquote>
<p> 注意:</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li><strong> </strong> mysql先去索引表里根据b+树的搜索原理很快搜索到id为4567890的数据,IO大大降低，因而速度明显提升</li>
</ol>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol start="2">
<li>我们可以去mysql的data目录下找到该表，可以看到添加索引后该表占用的硬盘空间多了</li>
</ol>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>3.如果使用没有添加索引的字段进行条件查询,速度依旧会很慢(如图:)</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226101828337-80007504.png" alt=""></p>
<h2 id="6-正确使用索引"><a href="#6-正确使用索引" class="headerlink" title="6.正确使用索引"></a>6.正确使用索引</h2><blockquote>
<p>  <strong>数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。<br> 即使建立索引，索引也不会生效,例如:</strong></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>1. 范围查询(&gt;、&gt;=、&lt;、&lt;=、!= 、between...and)
</code></pre></blockquote>
<blockquote>
<pre><code>#1. = 等号
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where id = 1000 -- 执行索引,索引效率高
</code></pre></blockquote>
<blockquote>
<pre><code>#2. &gt; &gt;= &lt; &lt;= between...and 区间查询
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where id &lt;100; -- 执行索引,区间范围越小,索引效率越高
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where id &gt;100; --执行索引,区间范围越大,索引效率越低
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where id between 10 and 500000
</code></pre><p>–执行索引,区间范围越大,索引效率越低</p>
</blockquote>
<blockquote>
<pre><code>#3. != 不等于
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where id != 1000;  -- 索引范围大,索引效率低
</code></pre></blockquote>
<blockquote>
<pre><code>2.like &apos;%xx%&apos;
</code></pre></blockquote>
<blockquote>
<pre><code>为 name 字段添加索引
</code></pre></blockquote>
<blockquote>
<pre><code>create index idx_name on userinfo(name);
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where name like &apos;%xxxx%&apos;; --
</code></pre><p>全模糊查询,索引效率低</p>
</blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where name like &apos;%xxxx&apos;;   --
</code></pre><p>以什么结尾模糊查询,索引效率低</p>
</blockquote>
<blockquote>
<pre><code>例外: 当like使用以什么开头会索引使用率高
</code></pre></blockquote>
<blockquote>
<pre><code>select * from userinfo where name like &apos;xxxx%&apos;;
</code></pre></blockquote>
<blockquote>
<pre><code>3.or
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where id = 12334 or email =&apos;xxxx&apos;; --
</code></pre><p>email不是索引字段,索引此查询全表扫描</p>
</blockquote>
<blockquote>
<pre><code>例外：当or条件中有未建立索引的列才失效，以下会走索引
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where id = 12334 or name = &apos;alex3&apos;; --
</code></pre><p>id 和 name 都为索引字段时, or条件也会执行索引</p>
</blockquote>
<blockquote>
<pre><code>4.使用函数
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where reverse(name) = &apos;5xela&apos;; --
</code></pre><p>name索引字段,使用函数时,索引失效</p>
</blockquote>
<blockquote>
<pre><code>例外:索引字段对应的值可以使用函数,我们可以改为一下形式
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where name = reverse(&apos;5xela&apos;);
</code></pre></blockquote>
<blockquote>
<pre><code>5.类型不一致
</code></pre></blockquote>
<blockquote>
<pre><code>如果列是字符串类型，传入条件是必须用引号引起来，不然...
</code></pre></blockquote>
<blockquote>
<pre><code>select count(*) from userinfo where name = 454;
</code></pre></blockquote>
<blockquote>
<pre><code>6.order by
</code></pre></blockquote>
<blockquote>
<pre><code>#排序条件为索引，则select字段必须也是索引字段，否则无法命中  
select email from userinfo ORDER BY name DESC; -- 无法命中索引
</code></pre></blockquote>
<blockquote>
<pre><code>select name from userinfo ORDER BY name DESC;  -- 命中索引
</code></pre></blockquote>
<blockquote>
<pre><code>特别的:如果对主键排序，则还是速度很快：
</code></pre></blockquote>
<blockquote>
<pre><code>select * from userinfo order by id desc;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>示例</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<h2 id="7-组合索引"><a href="#7-组合索引" class="headerlink" title="7.组合索引"></a>7.组合索引</h2><blockquote>
<p> 组合索引: 是指对表上的多个列组合起来做一个索引.</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p> 组合索引好处:简单的说有两个主要原因：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>  *<br>“一个顶三个”。建了一个(a,b,c)的组合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ul>
<li>索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select <em> from table where a = 1<br>and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W</em>10%=100w<br>条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是组合索引，通过索引筛选出1000w <em>10% </em>10%<br>*10%=1w，然后再排序、分页，哪个更高效，一眼便知</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<pre><code>&gt; 组合索引最左匹配原则: 从左往右依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<blockquote>
<pre><code>select * from mytable where a=3 and b=5 and c=4;
</code></pre></blockquote>
<blockquote>
<pre><code>　　abc三个索引都在where条件里面用到了，而且都发挥了作用
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where  c=4 and b=6 and a=3;
</code></pre></blockquote>
<blockquote>
<pre><code>　　这条语句列出来只想说明 mysql没有那么笨，where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where a=3 and c=7;
</code></pre></blockquote>
<blockquote>
<pre><code>　　a用到索引，b没有用，所以c是没有用到索引效果的
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where a=3 and b&gt;7 and c=3;
</code></pre></blockquote>
<blockquote>
<pre><code>　　a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where b=3 and c=4;
</code></pre></blockquote>
<blockquote>
<pre><code>　　因为a索引没有使用，所以这里 bc都没有用上索引效果
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where a&gt;4 and b=7 and c=9;
</code></pre></blockquote>
<blockquote>
<pre><code>　　a用到了  b没有使用，c没有使用
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where a=3 order by b;
</code></pre></blockquote>
<blockquote>
<pre><code>　　a用到了索引，b在结果排序中也用到了索引的效果
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where a=3 order by c;
</code></pre></blockquote>
<blockquote>
<pre><code>　　a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mytable where b=3 order by a;
</code></pre></blockquote>
<blockquote>
<pre><code>　　b没有用到索引，排序中a也没有发挥索引效果
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>示例</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<h2 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8.注意事项"></a>8.注意事项</h2><blockquote>
</blockquote>
<blockquote>
<pre><code>1. 避免使用select *
</code></pre></blockquote>
<blockquote>
<pre><code>2. count(1)或count(列) 代替 count(*)
</code></pre></blockquote>
<blockquote>
<pre><code>3. 创建表时尽量时 char 代替 varchar
</code></pre></blockquote>
<blockquote>
<pre><code>4. 表的字段顺序固定长度的字段优先
</code></pre></blockquote>
<blockquote>
<pre><code>5. 组合索引代替多个单列索引（经常使用多个条件查询时）
</code></pre></blockquote>
<blockquote>
<pre><code>6. 使用连接（JOIN）来代替子查询(Sub-Queries)
</code></pre></blockquote>
<blockquote>
<pre><code>7. 不要有超过5个以上的表连接（JOIN）
</code></pre></blockquote>
<blockquote>
<pre><code>8. 优先执行那些能够大量减少结果的连接。
</code></pre></blockquote>
<blockquote>
<pre><code>9. 连表时注意条件类型需一致
</code></pre></blockquote>
<blockquote>
<pre><code>10.索引散列值不适合建索引，例：性别不适合
</code></pre></blockquote>
<blockquote>
</blockquote>
<h2 id="9-查询计划"><a href="#9-查询计划" class="headerlink" title="9.查询计划"></a>9.查询计划</h2><blockquote>
<p><strong>explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化</strong></p>
</blockquote>
<blockquote>
<pre><code>explain  select count(*) from userinfo where  id = 1;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226134625135-198622003.png" alt=""></p>
<blockquote>
<pre><code>执行计划：让mysql预估执行操作(一般正确)
</code></pre></blockquote>
<blockquote>
<pre><code>all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt;
</code></pre><p>system/const</p>
</blockquote>
<blockquote>
<pre><code>慢：
</code></pre></blockquote>
<blockquote>
<pre><code>explain select * from userinfo where email=&apos;alex&apos;;
</code></pre></blockquote>
<blockquote>
<pre><code>type: ALL(全表扫描)
</code></pre></blockquote>
<blockquote>
<pre><code>特别的: select * from userinfo limit 1;
</code></pre></blockquote>
<blockquote>
<pre><code>快：
</code></pre></blockquote>
<blockquote>
<pre><code>explain select * from userinfo where name=&apos;alex&apos;;
</code></pre></blockquote>
<blockquote>
<pre><code>type: ref(走索引)
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p><a href="http://www.cnblogs.com/wangfengming/articles/8275448.html" target="_blank" rel="noopener">EXPLAIN 参数详解:<br>http://www.cnblogs.com/wangfengming/articles/8275448.html</a></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<h2 id="10-慢日志查询"><a href="#10-慢日志查询" class="headerlink" title="10. 慢日志查询"></a>10. <strong>慢日志查询</strong></h2><blockquote>
<p>  <strong>慢查询日志</strong>  </p>
</blockquote>
<blockquote>
<p>将mysql服务器中影响数据库性能的相关SQL语句记录到日志文件，通过对这些特殊的SQL语句分析，改进以达到提高数据库性能的目的。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>慢查询日志参数:</p>
</blockquote>
<blockquote>
<pre><code>long_query_time     ：  设定慢查询的阀值，超出设定值的SQL即被记录到慢查询日志，缺省值为10s
</code></pre></blockquote>
<blockquote>
<pre><code>slow_query_log      ：  指定是否开启慢查询日志
</code></pre></blockquote>
<blockquote>
<pre><code>log_slow_queries    ：  指定是否开启慢查询日志(该参数已经被slow_query_log取代，做兼容性保留)
</code></pre></blockquote>
<blockquote>
<pre><code>slow_query_log_file ：  指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log
</code></pre></blockquote>
<blockquote>
<pre><code>log_queries_not_using_indexes: 为使用索引的搜索是否记录
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>查看 MySQL慢日志信息</p>
</blockquote>
<blockquote>
<pre><code>#.查询慢日志配置信息 :
</code></pre></blockquote>
<blockquote>
<pre><code>show variables like &apos;%query%&apos;;
</code></pre></blockquote>
<blockquote>
<pre><code>#.修改配置信息
</code></pre></blockquote>
<blockquote>
<pre><code>set global slow_query_log  = on;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>查看不使用索引参数状态:</p>
</blockquote>
<blockquote>
<pre><code># 显示参数　　
</code></pre></blockquote>
<blockquote>
<pre><code>show variables like &apos;%log_queries_not_using_indexes&apos;;
</code></pre></blockquote>
<blockquote>
<pre><code># 开启状态
</code></pre></blockquote>
<blockquote>
<pre><code>set global log_queries_not_using_indexes  = on;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>查看慢日志显示的方式</p>
</blockquote>
<blockquote>
<pre><code>#查看慢日志记录的方式
</code></pre></blockquote>
<blockquote>
<pre><code>show variables like &apos;%log_output%&apos;;
</code></pre></blockquote>
<blockquote>
<pre><code>#设置慢日志在文件和表中同时记录
</code></pre></blockquote>
<blockquote>
<pre><code>set global log_output=&apos;FILE,TABLE&apos;;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>测试慢查询日志</p>
</blockquote>
<blockquote>
<pre><code>#查询时间超过10秒就会记录到慢查询日志中
</code></pre></blockquote>
<blockquote>
<pre><code>select sleep(3) FROM user ;
</code></pre></blockquote>
<blockquote>
<pre><code>#查看表中的日志
</code></pre></blockquote>
<blockquote>
<pre><code>select * from mysql.slow_log;
</code></pre></blockquote>
<blockquote>
</blockquote>
<h2 id="11-大数据量分页优化"><a href="#11-大数据量分页优化" class="headerlink" title="11.大数据量分页优化"></a>11.大数据量分页优化</h2><blockquote>
<p> 执行此段代码:</p>
</blockquote>
<blockquote>
<pre><code>select * from tb1 limit 3000000,10;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>优化方案:</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>一. 简单粗暴，就是不允许查看这么靠后的数据，比如百度就是这样的</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171213221208894-1193507537.png" alt=""></p>
<blockquote>
</blockquote>
<blockquote>
<p>最多翻到72页就不让你翻了，这种方式就是从业务上解决；</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>二.在查询下一页时把上一页的行id作为参数传递给客户端程序，然后sql就改成了</p>
</blockquote>
<blockquote>
<pre><code>select * from tb1 where id&gt;3000000 limit 10;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>这条语句执行也是在毫秒级完成的，id&gt;300w其实就是让mysql直接跳到这里了，不用依次在扫描全面所有的行</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>如果你的table的主键id是自增的，并且中间没有删除和断点，那么还有一种方式，比如100页的10条数据</p>
</blockquote>
<blockquote>
<pre><code>select * from tb1 where id&gt;100*10 limit 10;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>三.最后第三种方法：延迟关联</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>我们在来分析一下这条语句为什么慢，慢在哪里。</p>
</blockquote>
<blockquote>
<pre><code>select * from tb1 limit 3000000,10;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>玄机就处在这个 <em> 里面，这个表除了id主键肯定还有其他字段  比如 name  age  之类的，因为select  </em><br>所以mysql在沿着id主键走的时候要回行拿数据，走一下拿一下数据；</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>如果把语句改成</p>
</blockquote>
<blockquote>
<pre><code>select id from tb1 limit 3000000,10;
</code></pre></blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>你会发现时间缩短了一半；然后我们在拿id分别去取10条数据就行了；</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>语句就改成这样了：</p>
</blockquote>
<blockquote>
<pre><code>select table.* from tb1 inner join ( select id from tb1 limit 3000000,10
</code></pre><p>) as tmp on tmp.id=table.id;</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>这三种方法最先考虑第一种 其次第二种，第三种是别无选择</p>
</blockquote>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/博客园/" rel="tag"><i class="fas fa-tags"></i>博客园</a>
        
        <a class="post-tag button" href="/tags/搬家/" rel="tag"><i class="fas fa-tags"></i>搬家</a>
        
        <a class="post-tag button" href="/tags/cnblogs/" rel="tag"><i class="fas fa-tags"></i>cnblogs</a>
        
      </div>
      
    </footer>
  </article>
  
  
<div class="reward" id="reward">
  <div class="liker">
	<div class="liker-canvas">
		<canvas class="hearts-canvas"></canvas>
	</div>
	<p>打赏码还是要放的，万一真有人打赏嘞！🤣</p>
  	<button id="reward-button" class="btn" disable="enable">
  	    <i class="fas fa-heart"></i>
  	</button>
  	<span>打赏</span>
  </div>
  <div id="qr" class="qr" style="display: none;" aria-hidden="true">
    
    <div id="wechat">
      <img id="wechat_qr" src="/images/WeChatPay.png" alt="微信支付"/>
      <span>微信支付</span>
    </div>
    
    
    <div id="alipay">
      <img id="alipay_qr" src="/images/AliPay.png" alt="支付宝"/>
      <span>支付宝</span>
    </div>
    
    
  </div>
</div>


  
  
  <nav class="page-nav">
	<div class="page-nav-prev page-nav-item">
	  
	  <a href="/2018/03/05/cnblog_8508917/" rel="prev" title="前端知识之HTML内容"><i class="fas fa-angle-left"></i><span class="nav-title">前端知识之HTML内容</span></a>
	  
	</div>
    <div class="page-nav-next page-nav-item">
      
      <a href="/2018/02/28/cnblog_8485209/" rel="next" title="MySQL 之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】"><span class="nav-title">MySQL 之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  <script defer id="dsq-count-scr" src="//wevsmy.disqus.com/count.js"></script>
  
  <div id="disqus_thread" class="disqus_thread"></div>
  <script type="text/javascript">
  var disqus_config = function () {
    this.page.url = "https://bolg.weii.ink/2018/02/28/cnblog_8485214/";
    this.page.identifier = "2018/02/28/cnblog_8485214/";
  };
  (function() {
    var d = document, s = d.createElement("script");
    s.src = "https://wevsmy.disqus.com/embed.js";
    s.setAttribute("data-timestamp", +new Date());
    (d.head || d.body).appendChild(s);
  })();
  </script>
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.png" alt="wilson">
  
  <h1 class="author-name">wilson</h1>
  <h2 class="author-description">٩(๑❛ᴗ❛๑)۶</h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">77</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">8</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">18</a></div>
    </div>
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#这是👉MySQL-之-索引原理与慢查询优化👈的摘要"><span class="toc-text">这是👉MySQL 之 索引原理与慢查询优化👈的摘要</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#浏览目录"><span class="toc-text">浏览目录</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#1-索引介绍"><span class="toc-text">1. 索引介绍</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#2-索引类型"><span class="toc-text">2.索引类型</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#3-索引分类"><span class="toc-text">3.索引分类</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#1-普通索引"><span class="toc-text">1.普通索引</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#2-唯一索引"><span class="toc-text">2.唯一索引</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#3-主键索引"><span class="toc-text">3.主键索引</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#4-组合索引"><span class="toc-text">4.组合索引</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#5-全文索引-了解"><span class="toc-text">5.全文索引(了解)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#4-聚合索引和辅助索引"><span class="toc-text">4.聚合索引和辅助索引</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#5-测试索引"><span class="toc-text">5.测试索引</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#6-正确使用索引"><span class="toc-text">6.正确使用索引</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#7-组合索引"><span class="toc-text">7.组合索引</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#8-注意事项"><span class="toc-text">8.注意事项</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#9-查询计划"><span class="toc-text">9.查询计划</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#10-慢日志查询"><span class="toc-text">10. 慢日志查询</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#11-大数据量分页优化"><span class="toc-text">11.大数据量分页优化</span></a></li></ol></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fas fa-envelope"></i><a href="mailto:wevsmy@gmail.com" target="_blank">E-Mail</a></li>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/wevsmy" target="_blank">GitHub</a></li>
        
        <li><i class="fab fa-weibo"></i><a href="https://weibo.com/wevsmy" target="_blank">Weibo</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="https://codeloop.org" target="_blank">Code Loop</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://pythoncharles.github.io" target="_blank">Charles的博客</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://github.com/wevsmy" target="_blank">友链招租🤪</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #333333;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">wilson</span><span class="year"><i class="far fa-copyright"></i>2014 - 2019</span><span class="creative-commons"><i class="fab fa-creative-commons"></i><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">BY-NC-SA 4.0</a></span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a> <iframe style="margin-left:2px;margin-bottom:-5px;"frameborder="0" scrolling="0" width="100px" height="20px" src="https://ghbtns.com/github-btn.html?user=wevsmy&repo=wevsmy.github.io&type=star&count=true"></iframe>
          
        </div>
        <div class="powered-by">
           由 <a href="https://hexo.io/" target="_blank">Hexo</a> 驱动 | 基于 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a> 主题 | 由 <a href="https://github.com/wevsmy/hexo-theme-aria/" target="_blank">Wilson</a> 微改
        </div>
      </div>
    </div>
  </div>
</footer>


    <script type="text/javascript" margin-top="10%" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="/js/canvas-nest.js"></script>
    <script type="text/javascript" src="/js/heartsFlow.js"></script>
  </body>
</html>
