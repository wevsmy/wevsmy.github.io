<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>博客园不在更新</title>
      <link href="/2019/03/22/cnblog_10576224/"/>
      <url>/2019/03/22/cnblog_10576224/</url>
      <content type="html"><![CDATA[<p><strong>不更新了</strong></p><p><strong>新的地址👉<a href="https://wevsmy.github.io">https://wevsmy.github.io</a></strong></p><p><strong>会陆续把内容迁走 江湖再见😘</strong></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker安装宝塔管理面板</title>
      <link href="/2019/03/12/docker%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/"/>
      <url>/2019/03/12/docker%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>拉取centos基础镜像，用容器启动该基础镜像，直接在容器中部署宝塔管理面板<br><a id="more"></a><br>1.拉取纯净系统镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker pull centos:7.2.1511<br></code></pre></td></tr></table></figure></p><p>2.启动镜像，映射主机与容器内8888端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker run -d -it -p 8888:8888 centos:7.2.1511<br></code></pre></td></tr></table></figure></p><p>如果映射多个端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker run -d -it -p 8888:8888 -p 80:80  centos:7.2.1511<br></code></pre></td></tr></table></figure></p><p>一般我们再映射时候。都会把  8888  80 443  3306  21 等一些常用端口都映射过去。<br>注：<code>-p 80:80</code> 前面80是宿主机本机端口，后面的80是docker容器的。<br>3.<code>docker ps</code>查看容器id，并进入容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker exec -it 容器ID bash<br></code></pre></td></tr></table></figure></p><p>4.执行宝塔面板Centos安装命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh<br></code></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于docker-compose构建数据库</title>
      <link href="/2019/02/19/%E5%9F%BA%E4%BA%8Edocker-compose%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/02/19/%E5%9F%BA%E4%BA%8Edocker-compose%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>使用docker构建mysql、mongo、redis数据库，可以直接使用，免去安装的繁琐。</p><a id="more"></a><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.1'</span><br><span class="hljs-attr">services:</span><br><br><span class="hljs-attr">  mysql:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-attr">mysql:5.7</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"3306:3306"</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">willson</span><br><span class="hljs-attr">      MYSQL_DATABASE:</span> <span class="hljs-string">willson</span><br><span class="hljs-attr">      MYSQL_USER:</span> <span class="hljs-string">willson</span><br><span class="hljs-attr">      MYSQL_PASSWORD:</span> <span class="hljs-string">willson</span><br><br><span class="hljs-attr">  mongo:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">mongo</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">mongo</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-number">27017</span><span class="hljs-string">:27017</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      MONGO_INITDB_ROOT_USERNAME:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">      MONGO_INITDB_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">      MONGO_INITDB_DATABASE_NAME:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">    command:</span> <span class="hljs-string">["mongod","--bind_ip","0.0.0.0"]</span><br><br><span class="hljs-attr">  redis:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">"redis:alpine"</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"6379:6379"</span><br><span class="hljs-attr">command:</span> <span class="hljs-string">["redis-server","--bind","0.0.0.0"]</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"/mnt/data2/test:/data"</span><br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Flask-Migrate进行管理数据库升级</title>
      <link href="/2019/01/17/%E4%BD%BF%E7%94%A8Flask-Migrate%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/01/17/%E4%BD%BF%E7%94%A8Flask-Migrate%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>我们在升级系统的时候，经常碰到需要更新服务器端数据结构等操作，之前的方式是通过手工编写alter sql脚本处理，经常会发现遗漏，导致程序发布到服务器上后无法正常使用。<br>现在我们可以使用<a href="https://flask-migrate.readthedocs.org/en/latest/" target="_blank" rel="noopener">Flask-Migrate</a>插件来解决之，Flask-Migrate插件是基于<a href="http://alembic.readthedocs.org/en/latest/" target="_blank" rel="noopener">Alembic</a>，Alembic是由大名鼎鼎的<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>作者开发数据迁移工具。</p><a id="more"></a><h1 id="使用Flask-Migrate进行管理数据库升级"><a href="#使用Flask-Migrate进行管理数据库升级" class="headerlink" title="使用Flask-Migrate进行管理数据库升级"></a>使用Flask-Migrate进行管理数据库升级</h1><p>我们在升级系统的时候，经常碰到需要更新服务器端数据结构等操作，之前的方式是通过手工编写alter sql脚本处理，经常会发现遗漏，导致程序发布到服务器上后无法正常使用。<br>现在我们可以使用<a href="https://flask-migrate.readthedocs.org/en/latest/" target="_blank" rel="noopener">Flask-Migrate</a>插件来解决之，Flask-Migrate插件是基于<a href="http://alembic.readthedocs.org/en/latest/" target="_blank" rel="noopener">Alembic</a>，Alembic是由大名鼎鼎的<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>作者开发数据迁移工具。</p><p>具体操作如下：</p><ul><li>1.安装Flask-Migrate插件<br><code>$ pip install Flask-Migrate</code></li><li><p>2.修改Flask App部分的代码，以增加Migrate相关的Command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">db = SQLAlchemy(app)<br>migrate = Migrate(app, db)<br><br>manager = Manager(app)<br>manager.add_command(&apos;db&apos;, MigrateCommand)<br></code></pre></td></tr></table></figure></li><li><p>3.初始化<br><code>$ python app.py db init</code></p></li><li>4.数据迁移，自动创建迁移代码<br><code>$ python app.py db migrate</code></li><li>5.更新数据库<br><code>$ python app.py db upgrade</code><br>后面如果有Model变更的话，在开发环境下只需要重复执行第4、5步即可。</li></ul><p>而在服务器端只需要执行第5步即可实现数据库的迁移工作。</p><p><a href="http://www.cnblogs.com/maplye/p/5351060.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Flask </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>换电脑hexo源码迁移</title>
      <link href="/2019/01/15/%E6%8D%A2%E7%94%B5%E8%84%91hexo%E6%BA%90%E7%A0%81%E8%BF%81%E7%A7%BB/"/>
      <url>/2019/01/15/%E6%8D%A2%E7%94%B5%E8%84%91hexo%E6%BA%90%E7%A0%81%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>更换电脑后迁移hexo源代码😂<br><a id="more"></a></p><h1 id="备份必要文件"><a href="#备份必要文件" class="headerlink" title="备份必要文件"></a>备份必要文件</h1><p>进入原来电脑的 hexo 博客目录，只拷如下几个目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">scaffolds            文章模版                          必须备份<br>source               博客文章                          必须备份<br>themes               主题                             必须备份<br>.gitignore           限定在push时那些文件可以忽略         必须备份<br>_config.yml          站点配置文件                       必须备份<br>package.json         安装包的名称                       必须备份<br><br>.ssh                 密钥文件                          必须备份<br></code></pre></td></tr></table></figure></p><p><code>ps:上面的文件可以存U盘或者打包上传到xx网盘。</code></p><h1 id="安装配置-Hexo"><a href="#安装配置-Hexo" class="headerlink" title="安装配置 Hexo"></a>安装配置 Hexo</h1><p>用之前的套路安装 Node.js 环境  Git 环境</p><ul><li>打开 开始菜单 运行 cmd</li><li>新建 blog 文件夹<br><code>md d:\blog</code></li><li>进入 blog 文件夹<br><code>cd blog</code></li><li>安装 Hexo<br><code>npm install -g hexo</code></li><li>初始化 Hexo<br><code>hexo init</code></li><li>安装依赖包<br><code>npm install</code></li></ul><p>上面的命令执行完了，你的博客目录会生成新的 hexo 博客文件，我们把刚才拷贝过来的文件，替换掉新生成的 博客文件，然后在复制 密钥文件 到新的密钥文件夹<br>在blog文件夹中打开 <code>Git Bash Here</code></p><ul><li>初始化git本地仓库<br><code>git init</code></li><li>安装上传插件<br><code>npm install hexo-deployer-git --save</code></li><li>RSS插件<br><code>npm install hexo-generator-feed</code></li><li>字数统计 阅读时长 插件<br><code>npm i --save hexo-wordcount</code></li><li><p>搜索插件<br><code>npm install hexo-generator-searchdb --save</code><br>如果你使用了更多的插件，在这里安装就可以了。<br>配置Git 输入你自己的邮箱地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name<br>git config --global user.email<br></code></pre></td></tr></table></figure></li><li><p>生成新的 public 文件夹<br><code>hexo g</code></p></li><li>开始上传 hexo博客<br><code>hexo d</code></li></ul><hr><p>date: 2019-05-31 09:41:53</p><p>采用Onedrive备份hexo博客源码</p><ul><li><p>备份文件</p><p>简单方便，只要把blog文件目录放到Onedrive中，其会自动备份的。新电脑登录Onedrive拉取blog文件。</p></li><li><p>安装环境</p><ul><li>安装node.js</li><li>安装hexo <code>npm install -g hexo</code></li><li>预览blog <code>hexo s</code></li><li>生成blog <code>hexo g</code></li><li>上传blog <code>hexo d</code></li><li>搞定收工😁</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker镜像部署Flask</title>
      <link href="/2018/06/05/Docker%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2Flask/"/>
      <url>/2018/06/05/Docker%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2Flask/</url>
      <content type="html"><![CDATA[<p>入坑了，入了Docker的坑，了解了一下docker安装，<br>照着教程学着部署了一下Flask，<br>Docker使用uwsgi+nginx+python3.6镜像部署Flask<br><a id="more"></a></p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>占坑，因为我已经装过了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo apt-get install docker<br></code></pre></td></tr></table></figure></p><p>然后查看是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo docker -v<br></code></pre></td></tr></table></figure></p><h1 id="Docker-镜像制作"><a href="#Docker-镜像制作" class="headerlink" title="Docker 镜像制作"></a>Docker 镜像制作</h1><p>编写Dockerfile 文件<br>因为我是用的flask项目是一个简单的demo没有使用第三方库<br>也就不用安装第三方库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">FROM tiangolo/uwsgi-nginx-flask:python3.6<br>COPY ./app /app<br></code></pre></td></tr></table></figure></p><ul><li>第一句表示，该镜像由 tiangolo/uwsgi-nginx-flask:python3.6 继承而来</li><li>第二句 拷贝项目文件到镜像中</li></ul><p>我的项目结构<br><img src="/2018/06/05/Docker镜像部署Flask/33765843.jpg" alt="项目结构" title="项目结构" style="width:197px;height:213px"></p><p>uwsgi.ini 文件：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><br><span class="hljs-attr">module</span> = main<br><span class="hljs-attr">callable</span> = app<br></code></pre></td></tr></table></figure></p><p>完成后，在跟目录，即 Dockerfile 所在目录运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo docker build -t myimage .<br></code></pre></td></tr></table></figure></p><p>构建镜像。（注意后面的 点 ）</p><h1 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h1><p>运行以下命令启动 容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker container run --name mycon --rm -d -p 9001:80 -it myimage<br></code></pre></td></tr></table></figure></p><p>其中 –name 表示容器名， –rm 表示停止容器后删除容器， -p 9001:80 表示将当前宿主机 9001 端口对应到容器中 80 端口， -it myimage 表示使用 myimage 镜像（即上面生成的镜像）。</p><p><a href="https://blog.csdn.net/Bear_861110453/article/details/80356153" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一键创建blog文</title>
      <link href="/2018/06/04/%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAblog%E6%96%87/"/>
      <url>/2018/06/04/%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAblog%E6%96%87/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用hexo搭建静态博客确实方便,页面托管到github pages上<br>写博客只需编写md文件即可,markdown语法简单,使用方便<br>原来也用过wordpress建博客,也挺好的,相比较下hexo比wordpress要轻便<br><a id="more"></a></p><h1 id="使用hexo优点"><a href="#使用hexo优点" class="headerlink" title="使用hexo优点"></a>使用hexo优点</h1><ul><li>熟练git使用方法</li><li>掌握markdown语法</li><li>GitHub pages托管静态页面</li><li>可以加入最大同性交友社区(误)</li></ul><hr><h1 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h1><p>hexo具体安装自己google</p><p>生成页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo g<br></code></pre></td></tr></table></figure></p><p>创建博文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo n 博文名<br></code></pre></td></tr></table></figure></p><p>发布博文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo d<br></code></pre></td></tr></table></figure></p><h1 id="改进创建博文的不便捷"><a href="#改进创建博文的不便捷" class="headerlink" title="改进创建博文的不便捷"></a>改进创建博文的不便捷</h1><p>创建博文需要到blog根目录打开powershell 运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo n name<br></code></pre></td></tr></table></figure></p><p>然后需要到_posts目录下打开刚才创建的name.md 进行编写博文<br>个人觉得比较繁琐,就想着改进一下</p><h2 id="一键创建blog文原理"><a href="#一键创建blog文原理" class="headerlink" title="一键创建blog文原理"></a>一键创建blog文原理</h2><p>就是把几个命令组合到一起,很简单<br>比如我的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cd D:\python\WilsonBlog | hexo n &#123;query&#125; | notepad++.exe D:\python\WilsonBlog\source\_posts\&#123;query&#125;.md<br></code></pre></td></tr></table></figure></p><ul><li>先cd到博客目录</li><li>运行hexo n name 创建博文</li><li>调用notepad++打开刚创建的博文<br>这样就能在任何地方打开powershell就能创建博文了<br>但是这个还不够好,因为还需要手敲命令,麻烦!<h2 id="在改进一下"><a href="#在改进一下" class="headerlink" title="在改进一下"></a>在改进一下</h2>个人非常喜欢使用listary这个快速搜索工具<br>其支持自定义命令,每次启动只需双击ctrl就可以<br>具体如下图所示:<br><img src="/2018/06/04/一键创建blog文/82574636.jpg" alt="我的自定义命令"><br>这样在任何地方只需双击ctrl键输入关键字blog 博文名 即可创建博文<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><img src="/2018/06/04/一键创建blog文/46250370.jpg" alt="gif"></li></ul>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Win10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用阿里云OSS图床</title>
      <link href="/2018/06/02/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A/"/>
      <url>/2018/06/02/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A/</url>
      <content type="html"><![CDATA[<p>本Blog中所有文章图片都采用阿里云OSS对象存储作为图床<br>下面简单说一下如何使用oss作为图床</p><a id="more"></a><hr><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol><li><a href="https://shimo.im/docs/vbmdsh2LSwoo628P/" target="_blank" rel="noopener">开通阿里云OSS对象储存</a></li><li>使用<a href="https://jiantuku.com" target="_blank" rel="noopener">极简图床</a></li><li>下载谷歌插件<a href="https://chrome.google.com/webstore/detail/%E6%9E%81%E7%AE%80%E5%9B%BE%E5%BA%8A/heebflcbemenefckkgfnnklbhdbdkagg" target="_blank" rel="noopener">极简图床</a>方便采集上传图片</li><li>获取图片链接插入博客中即可</li></ol><p><img src="https://wevsmy.github.io/favicons/android-chrome-96x96.png" alt="就是这么简单，讲完了" title="end" style="width:96px;height:96px"></p><hr><p>date: 2019-01-17 13:41:57</p><p>换成静态资源了，怕图床挂了 🌚</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于本Blog的评论系统</title>
      <link href="/2018/06/02/%E5%85%B3%E4%BA%8E%E6%9C%ACBlog%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/06/02/%E5%85%B3%E4%BA%8E%E6%9C%ACBlog%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>本博客采用的是Disqus评论系统，国内加载不出来<br><a id="more"></a></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>评论系统Disqus需使用google账号登陆，并FQ才能评论，<br>哈哈，并不是没个人都能评论的！！！<br>(整的好像有人会评论似的😂)<br>换句话说，留下的评论的都会FQ，开门社区送温暖！！！</p>]]></content>
      
      
        <tags>
            
            <tag> Disqus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>test</title>
      <link href="/2018/06/02/test/"/>
      <url>/2018/06/02/test/</url>
      <content type="html"><![CDATA[<p>这是一篇测试文章，用于测试Hexo搭建的github静态网站<br><a id="more"></a></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>添加分类</li><li>添加标签<h1 id="hexo添加分类and标签的方法"><a href="#hexo添加分类and标签的方法" class="headerlink" title="hexo添加分类and标签的方法"></a>hexo添加分类and标签的方法</h1>只需要在文章分类中加入以下代码即可：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">---<br>title: test<br>date: 2018-06-02 20:16:09<br>categories:<br>- 计算机<br>- Linux<br>- Docker<br>tags:<br>- Python<br>- Docker<br>- HTML<br>---<br></code></pre></td></tr></table></figure></li></ul><p>上述代码即是本片文章的分类and标签</p><h1 id="测试插入图片"><a href="#测试插入图片" class="headerlink" title="测试插入图片"></a>测试插入图片</h1><ol><li>markdown语法不支持指定宽高<br>代码<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">![Dog](test/63035737.jpg )<br></code></pre></td></tr></table></figure></li></ol><p><img src="/2018/06/02/test/63035737.jpg" alt="Dog"></p><ol start="2"><li>使用img标签指定宽高<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;img src=&quot;test/63035737.jpg&quot; alt=&quot;Dog&quot; title=&quot;神烦狗&quot; style=&quot;width:100px;height:100px&quot;&gt;<br></code></pre></td></tr></table></figure></li></ol><p><img src="/2018/06/02/test/63035737.jpg" alt="Dog" title="神烦狗" style="width:100px;height:100px"></p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django基础01</title>
      <link href="/2018/03/22/cnblog_8621513/"/>
      <url>/2018/03/22/cnblog_8621513/</url>
      <content type="html"><![CDATA[<h1 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h1><p>我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端。 这样我们就可以自己实现Web框架了。</p><pre><code>import socketsk = socket.socket()sk.bind((&quot;127.0.0.1&quot;, 80))sk.listen(5)while True:    conn, addr = sk.accept()    data = conn.recv(8096)    conn.send(b&quot;OK&quot;)    conn.close()</code></pre><p>可以说Web服务本质上都是在这十几行代码基础上扩展出来的。这段代码就是它们的祖宗。</p><p>用户的浏览器一输入网址，会给服务端发送数据，那浏览器会发送什么数据？怎么发？这个谁来定？ 你这个网站是这个规定，他那个网站按照他那个规定，这互联网还能玩么？</p><p>所以，必须有一个统一的规则，让大家发送消息、接收消息的时候有个格式依据，不能随便写。</p><p>这个规则就是HTTP协议，以后浏览器发送请求信息也好，服务器回复响应信息也罢，都要按照这个规则来。</p><p>HTTP协议主要规定了客户端和服务器之间的通信格式，那HTTP协议是怎么规定消息格式的呢？</p><p>让我们首先看下我们在服务端接收到的消息是什么。</p><p>然后再看下我们浏览器收到的响应信息是什么。</p><p>响应头在浏览器的network窗口可以看到，我们看到的HTML页面内容就是响应体。本质上还是字符串，因为浏览器认识HTML，所以才会渲染出页面。</p><p><a href="http://www.cnblogs.com/liwenzhou/articles/8620663.html" target="_blank" rel="noopener">HTTP协议介绍</a></p><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。 HTTP响应的Header中有一个<br><code>Content-Type</code>表明响应的内容格式。如 <code>text/html</code>表示HTML网页。</p><p>HTTP GET请求的格式：</p><pre><code>GET /path HTTP/1.1header1:v1\r\nheader2:v2\r\n</code></pre><p>使用 <code>\r\n</code>分隔多个header</p><p>HTTP POST请求格式：</p><pre><code>POST /path HTTP/1.1header1:v1\r\nheader2:v2\r\n\r\n\r\n请求体...</code></pre><p>当遇到连续两个 <code>\r\n\r\n</code>时，表示Header部分结束了，后面的数据是Body。</p><p>HTTP响应的格式：</p><pre><code>200 OKHeader1:v1\r\nHeader2:v2\r\n\r\n\r\n响应体...</code></pre><p>让我们的Web框架在给客户端回复响应的时候按照HTTP协议的规则加上响应头，这样我们就实现了一个正经的Web框架了。</p><pre><code>import socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&apos;127.0.0.1&apos;, 8000))sock.listen(5)while True:    conn, addr = sock.accept()    data = conn.recv(8096)    conn.send(b&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)    conn.send(b&quot;OK&quot;)    conn.close()</code></pre><p>上述通过socket来实现了其本质。</p><p>对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。</p><p>服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。</p><p>应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py<br>等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。</p><p>这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。</p><p>这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。</p><p>WSGI（Web Server Gateway<br>Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。</p><p>常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。</p><pre><code>from wsgiref.simple_server import make_serverdef run_server(environ, start_response):    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;)])  # 设置HTTP响应的状态码和头信息    return [bytes(&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;, encoding=&quot;utf8&quot;),]if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;&apos;, 8000, run_server)    print(&quot;Serving HTTP on port 8000...&quot;)    httpd.serve_forever()</code></pre><p>这样就结束了吗？ 如何让我们的Web服务根据用户请求的URL不同而返回不同的内容呢？</p><p>小事一桩，我们可以从请求相关数据里面拿到请求的URL，然后做一个判断。</p><pre><code>from wsgiref.simple_server import make_serverdef run_server(environ, start_response):    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;), ])  # 设置HTTP响应的状态码和头信息    url = environ[&apos;PATH_INFO&apos;]  # 取到用户输入的url    if url == &quot;/index/&quot;:        return [bytes(&quot;&lt;h1&gt;这是index页面&lt;/h1&gt;&quot;, encoding=&quot;utf8&quot;), ]    elif url == &quot;/home/&quot;:        return [bytes(&quot;&lt;h1&gt;这是home页面&lt;/h1&gt;&quot;, encoding=&quot;utf8&quot;), ]    else:        return [bytes(&quot;404没有该页面&quot;, encoding=&quot;utf8&quot;), ]if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;&apos;, 8000, run_server)    print(&quot;Serving HTTP on port 8000...&quot;)    httpd.serve_forever()</code></pre><p>解决了不同URL返回不同内容的需求。 但是问题又来了，如果有很多很多页面怎么办？难道要挨个判断？ 当然不用，我们有更聪明的办法。</p><pre><code>from wsgiref.simple_server import make_serverdef index():    return [bytes(&quot;&lt;h1&gt;这是index页面&lt;/h1&gt;&quot;, encoding=&quot;utf8&quot;), ]def home():    return [bytes(&quot;&lt;h1&gt;这是home页面&lt;/h1&gt;&quot;, encoding=&quot;utf8&quot;), ]# 定义一个url和函数的对应关系URL_LIST = [    (&quot;/index/&quot;, index),    (&quot;/home/&quot;, home),]def run_server(environ, start_response):    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;), ])  # 设置HTTP响应的状态码和头信息    url = environ[&apos;PATH_INFO&apos;]  # 取到用户输入的url    func = None  # 将要执行的函数    for i in URL_LIST:        if i[0] == url:            func = i[1]  # 去之前定义好的url列表里找url应该执行的函数            break    if func:  # 如果能找到要执行的函数        return func()  # 返回函数的执行结果    else:        return [bytes(&quot;404没有该页面&quot;, encoding=&quot;utf8&quot;), ]if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;&apos;, 8000, run_server)    print(&quot;Serving HTTP on port 8000...&quot;)    httpd.serve_forever()</code></pre><p>完美解决了不同URL返回不同内容的问题。 但是我不想仅仅返回几个字符串，我想给浏览器返回完整的HTML内容，这又该怎么办呢？</p><p>没问题，不管是什么内容，最后都是转换成字节数据发送出去的。 我可以打开HTML文件，读取出它内部的二进制数据，然后发送给浏览器。</p><pre><code>from wsgiref.simple_server import make_serverdef index():    with open(&quot;index.html&quot;, &quot;rb&quot;) as f:        data = f.read()    return [data, ]def home():    with open(&quot;home.html&quot;, &quot;rb&quot;) as f:        data = f.read()    return [data, ]# 定义一个url和函数的对应关系URL_LIST = [    (&quot;/index/&quot;, index),    (&quot;/home/&quot;, home),]def run_server(environ, start_response):    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;), ])  # 设置HTTP响应的状态码和头信息    url = environ[&apos;PATH_INFO&apos;]  # 取到用户输入的url    func = None  # 将要执行的函数    for i in URL_LIST:        if i[0] == url:            func = i[1]  # 去之前定义好的url列表里找url应该执行的函数            break    if func:  # 如果能找到要执行的函数        return func()  # 返回函数的执行结果    else:        return [bytes(&quot;404没有该页面&quot;, encoding=&quot;utf8&quot;), ]if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;&apos;, 8000, run_server)    print(&quot;Serving HTTP on port 8000...&quot;)    httpd.serve_forever()</code></pre><p>这网页能够显示出来了，但是都是静态的啊。页面的内容都不会变化的，我想要的是动态网站。</p><p>没问题，我也有办法解决。我选择使用字符串替换来实现这个需求。</p><pre><code>from wsgiref.simple_server import make_serverdef index():    with open(&quot;index.html&quot;, &quot;rb&quot;) as f:        data = f.read()    import time    time_str = str(time.time())    data_str = str(data, encoding=&quot;utf8&quot;)    data_str = data_str.replace(&quot;@@a@@&quot;, time_str)    return [bytes(data_str, encoding=&quot;utf8&quot;), ]def home():    with open(&quot;home.html&quot;, &quot;rb&quot;) as f:        data = f.read()    return [data, ]# 定义一个url和函数的对应关系URL_LIST = [    (&quot;/index/&quot;, index),    (&quot;/home/&quot;, home),]def run_server(environ, start_response):    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;), ])  # 设置HTTP响应的状态码和头信息    url = environ[&apos;PATH_INFO&apos;]  # 取到用户输入的url    func = None  # 将要执行的函数    for i in URL_LIST:        if i[0] == url:            func = i[1]  # 去之前定义好的url列表里找url应该执行的函数            break    if func:  # 如果能找到要执行的函数        return func()  # 返回函数的执行结果    else:        return [bytes(&quot;404没有该页面&quot;, encoding=&quot;utf8&quot;), ]if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;&apos;, 8000, run_server)    print(&quot;Serving HTTP on port 8000...&quot;)    httpd.serve_forever()</code></pre><p>这是一个简单的动态，我完全可以从数据库中查询数据，然后去替换我html中的对应内容，然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。<br>本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： <code>jinja2</code></p><p>下载jinja2:</p><pre><code>pip install jinja2</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;姓名：{{name}}&lt;/h1&gt;    &lt;h1&gt;爱好：&lt;/h1&gt;    &lt;ul&gt;        {% for hobby in hobby_list %}            <li>{{hobby}}</li>            {% endfor %}    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>index2.html文件</p><p>使用jinja2渲染index2.html文件：</p><pre><code>from wsgiref.simple_server import make_serverfrom jinja2 import Templatedef index():    with open(&quot;index2.html&quot;, &quot;r&quot;) as f:        data = f.read()    template = Template(data)  # 生成模板文件    ret = template.render({&quot;name&quot;: &quot;Alex&quot;, &quot;hobby_list&quot;: [&quot;烫头&quot;, &quot;泡吧&quot;]})  # 把数据填充到模板里面    return [bytes(ret, encoding=&quot;utf8&quot;), ]def home():    with open(&quot;home.html&quot;, &quot;rb&quot;) as f:        data = f.read()    return [data, ]# 定义一个url和函数的对应关系URL_LIST = [    (&quot;/index/&quot;, index),    (&quot;/home/&quot;, home),]def run_server(environ, start_response):    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;), ])  # 设置HTTP响应的状态码和头信息    url = environ[&apos;PATH_INFO&apos;]  # 取到用户输入的url    func = None  # 将要执行的函数    for i in URL_LIST:        if i[0] == url:            func = i[1]  # 去之前定义好的url列表里找url应该执行的函数            break    if func:  # 如果能找到要执行的函数        return func()  # 返回函数的执行结果    else:        return [bytes(&quot;404没有该页面&quot;, encoding=&quot;utf8&quot;), ]if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;&apos;, 8000, run_server)    print(&quot;Serving HTTP on port 8000...&quot;)    httpd.serve_forever()</code></pre><p>现在的数据是我们自己手写的，那可不可以从数据库中查询数据，来填充页面呢？</p><p>使用pymysql连接数据库：</p><pre><code>conn = pymysql.connect(host=&quot;127.0.0.1&quot;, port=3306, user=&quot;root&quot;, passwd=&quot;xxx&quot;, db=&quot;xxx&quot;, charset=&quot;utf8&quot;)cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)cursor.execute(&quot;select name, age, department_id from userinfo&quot;)user_list = cursor.fetchall()cursor.close()conn.close()</code></pre><p>创建一个测试的user表：</p><pre><code>CREATE TABLE user(  id int auto_increment PRIMARY KEY,  name CHAR(10) NOT NULL,  hobby CHAR(20) NOT NULL)engine=innodb DEFAULT charset=UTF8;</code></pre><p>模板的原理就是字符串替换，我们只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容。</p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p><a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">Django官网下载页面</a></p><h3 id="安装（安装最新LTS版）："><a href="#安装（安装最新LTS版）：" class="headerlink" title="安装（安装最新LTS版）："></a>安装（安装最新LTS版）：</h3><pre><code>pip3 install django==1.11.9</code></pre><h3 id="创建一个django项目："><a href="#创建一个django项目：" class="headerlink" title="创建一个django项目："></a>创建一个django项目：</h3><p>下面的命令创建了一个名为”mysite”的Django 项目：</p><pre><code>django-admin startproject mysite</code></pre><h3 id="目录介绍："><a href="#目录介绍：" class="headerlink" title="目录介绍："></a>目录介绍：</h3><pre><code>mysite/├── manage.py  # 管理文件└── mysite  # 项目目录    ├── __init__.py    ├── settings.py  # 配置    ├── urls.py  # 路由 --&gt; URL和函数的对应关系    └── wsgi.py  # runserver命令就使用wsgiref模块做简单的web server</code></pre><h3 id="运行Django项目："><a href="#运行Django项目：" class="headerlink" title="运行Django项目："></a>运行Django项目：</h3><pre><code>python manage.py runserver 127.0.0.1:8000</code></pre><h3 id="模板文件配置："><a href="#模板文件配置：" class="headerlink" title="模板文件配置："></a>模板文件配置：</h3><pre><code>TEMPLATES = [    {        &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;,        &apos;DIRS&apos;: [os.path.join(BASE_DIR, &quot;template&quot;)],  # template文件夹位置        &apos;APP_DIRS&apos;: True,        &apos;OPTIONS&apos;: {            &apos;context_processors&apos;: [                &apos;django.template.context_processors.debug&apos;,                &apos;django.template.context_processors.request&apos;,                &apos;django.contrib.auth.context_processors.auth&apos;,                &apos;django.contrib.messages.context_processors.messages&apos;,            ],        },    },]</code></pre><h3 id="静态文件配置："><a href="#静态文件配置：" class="headerlink" title="静态文件配置："></a>静态文件配置：</h3><pre><code>STATIC_URL = &apos;/static/&apos;  # HTML中使用的静态文件夹前缀STATICFILES_DIRS = [    os.path.join(BASE_DIR, &quot;static&quot;),  # 静态文件存放位置]</code></pre><p><strong>看不明白？有图有真相：</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/867021/201801/867021-20180110190001816-1349372864.png" alt=""></strong></p><p><strong>刚开始学习时可在配置文件中暂时禁用csrf中间件，方便表单提交测试。</strong></p><pre><code>MIDDLEWARE = [     &apos;django.middleware.security.SecurityMiddleware&apos;,    &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,    &apos;django.middleware.common.CommonMiddleware&apos;,    # &apos;django.middleware.csrf.CsrfViewMiddleware&apos;,    &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;,    &apos;django.contrib.messages.middleware.MessageMiddleware&apos;,    &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,]</code></pre><h2 id="Django基础必备三件套："><a href="#Django基础必备三件套：" class="headerlink" title="Django基础必备三件套："></a>Django基础必备三件套：</h2><pre><code>from django.shortcuts import HttpResponse, render, redirect</code></pre><h3 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h3><p>内部传入一个字符串参数，返回给浏览器。</p><p>例如：</p><pre><code>def index(request):    # 业务逻辑代码    return HttpResponse(&quot;OK&quot;)</code></pre><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>除request参数外还接受一个待渲染的模板文件和一个保存具体数据的字典参数。</p><p>将数据填充进模板文件，最后把结果返回给浏览器。（类似于我们上面用到的jinja2）</p><p>例如：</p><pre><code>def index(request):    # 业务逻辑代码    return render(request, &quot;index.html&quot;, {&quot;name&quot;: &quot;alex&quot;, &quot;hobby&quot;: [&quot;烫头&quot;, &quot;泡吧&quot;]})</code></pre><h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><p>接受一个URL参数，表示跳转到指定的URL。</p><p>例如：</p><pre><code>def index(request):    # 业务逻辑代码    return redirect(&quot;/home/&quot;)</code></pre><h2 id="课后练习："><a href="#课后练习：" class="headerlink" title="课后练习："></a>课后练习：</h2><p>Django版登录</p><h2 id="启动Django报错："><a href="#启动Django报错：" class="headerlink" title="启动Django报错："></a>启动Django报错：</h2><p>Django 启动时报错 UnicodeEncodeError …</p><p>报这个错误通常是因为计算机名为中文，改成英文的计算机名重启下电脑就可以了。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python连接MySQL数据库之pymysql模块使用</title>
      <link href="/2018/03/21/cnblog_8616189/"/>
      <url>/2018/03/21/cnblog_8616189/</url>
      <content type="html"><![CDATA[<h1 id="Python3连接MySQL"><a href="#Python3连接MySQL" class="headerlink" title="Python3连接MySQL"></a>Python3连接MySQL</h1><p>本文介绍Python3连接MySQL的第三方库–PyMySQL的基本使用。</p><h2 id="PyMySQL介绍"><a href="#PyMySQL介绍" class="headerlink" title="PyMySQL介绍"></a>PyMySQL介绍</h2><p>PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。</p><p>Django中也可以使用PyMySQL连接MySQL数据库。</p><h2 id="PyMySQL安装"><a href="#PyMySQL安装" class="headerlink" title="PyMySQL安装"></a>PyMySQL安装</h2><p>​<br>    pip install pymysql</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在进行本文以下内容之前需要注意：</p><ul><li>你有一个MySQL数据库，并且已经启动。</li><li>你有可以连接该数据库的用户名和密码</li><li>你有一个有权限操作的database</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>​    </p><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 定义要执行的SQL语句sql = &quot;&quot;&quot;CREATE TABLE USER1 (id INT auto_increment PRIMARY KEY ,name CHAR(10) NOT NULL UNIQUE,age TINYINT NOT NULL)ENGINE=innodb DEFAULT CHARSET=utf8;&quot;&quot;&quot;# 执行SQL语句cursor.execute(sql)# 关闭光标对象cursor.close()# 关闭数据库连接conn.close()</code></pre><p>返回字典格式数据：</p><p>​    </p><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句并且将结果作为字典返回的游标cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)# 定义要执行的SQL语句sql = &quot;&quot;&quot;CREATE TABLE USER1 (id INT auto_increment PRIMARY KEY ,name CHAR(10) NOT NULL UNIQUE,age TINYINT NOT NULL)ENGINE=innodb DEFAULT CHARSET=utf8;&quot;&quot;&quot;# 执行SQL语句cursor.execute(sql)# 关闭光标对象cursor.close()# 关闭数据库连接conn.close()</code></pre><p>注意：</p><p>charset=”utf8”，编码不要写成”utf-8”</p><h2 id="增删改查操作"><a href="#增删改查操作" class="headerlink" title="增删改查操作"></a>增删改查操作</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>​    </p><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;username = &quot;Alex&quot;age = 18# 执行SQL语句cursor.execute(sql, [username, age])# 提交事务conn.commit()cursor.close()conn.close()</code></pre><p><strong>插入数据失败回滚</strong></p><p>​    </p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;username = &quot;Alex&quot;age = 18try:    # 执行SQL语句    cursor.execute(sql, [username, age])    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><p><strong>获取插入数据的ID(关联操作时会用到)</strong></p><p>​    </p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;username = &quot;Alex&quot;age = 18try:    # 执行SQL语句    cursor.execute(sql, [username, age])    # 提交事务    conn.commit()    # 提交之后，获取刚插入的数据的ID    last_id = cursor.lastrowidexcept Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><p><strong>批量执行</strong></p><p>​    </p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;data = [(&quot;Alex&quot;, 18), (&quot;Egon&quot;, 20), (&quot;Yuan&quot;, 21)]try:    # 批量执行多条插入SQL语句    cursor.executemany(sql, data)    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>​    </p><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;DELETE FROM USER1 WHERE id=%s;&quot;try:    cursor.execute(sql, [4])    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>​    </p><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 修改数据的SQL语句sql = &quot;UPDATE USER1 SET age=%s WHERE name=%s;&quot;username = &quot;Alex&quot;age = 80try:    # 执行SQL语句    cursor.execute(sql, [age, username])    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><strong>查询单条数据</strong></p><p>​    </p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 查询数据的SQL语句sql = &quot;SELECT id,name,age from USER1 WHERE id=1;&quot;# 执行SQL语句cursor.execute(sql)# 获取单条查询数据ret = cursor.fetchone()cursor.close()conn.close()# 打印下查询结果print(ret)</code></pre><p><strong>查询多条数据</strong></p><p>​    </p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 查询数据的SQL语句sql = &quot;SELECT id,name,age from USER1;&quot;# 执行SQL语句cursor.execute(sql)# 获取多条查询数据ret = cursor.fetchall()cursor.close()conn.close()# 打印下查询结果print(ret)</code></pre><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 可以获取指定数量的数据<br>cursor.fetchmany(3)<br># 光标按绝对位置移动1<br>cursor.scroll(1, mode=&quot;absolute&quot;)<br># 光标按照相对位置(当前位置)移动1<br>cursor.scroll(1, mode=&quot;relative&quot;)<br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown 语法说明 (简体中文版)</title>
      <link href="/2018/03/14/cnblog_8565323/"/>
      <url>/2018/03/14/cnblog_8565323/</url>
      <content type="html"><![CDATA[<h1 id="Markdown-语法说明-简体中文版"><a href="#Markdown-语法说明-简体中文版" class="headerlink" title="Markdown 语法说明 (简体中文版)"></a>Markdown 语法说明 (简体中文版)</h1><h1 id="转载之WOWUBUNTO"><a href="#转载之WOWUBUNTO" class="headerlink" title="转载之WOWUBUNTO"></a>转载之WOWUBUNTO</h1><h1 id="点击查看原链接"><a href="#点击查看原链接" class="headerlink" title="(点击查看原链接)"></a>(<a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="noopener">点击查看原链接</a>)</h1><ul><li>概述<ul><li>宗旨</li><li>兼容 HTML</li><li>特殊字符自动转换</li></ul></li><li>区块元素<ul><li>段落和换行</li><li>标题</li><li>区块引用</li><li>列表</li><li>代码区块</li><li>分隔线</li></ul></li><li>区段元素<ul><li>链接</li><li>强调</li><li>代码</li><li>图片</li></ul></li><li>其它<ul><li>反斜杠</li><li>自动链接</li></ul></li></ul><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p><p>可读性，无论如何，都是最重要的。一份使用 Markdown<br>格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML<br>格式的影响，包括<br><a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener">Grutatext</a><br>和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p><p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像<em>强调</em>。Markdown<br>的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p><h3 id="兼容-HTML"><a href="#兼容-HTML" class="headerlink" title="兼容 HTML"></a>兼容 HTML</h3><p>Markdown 语法的目标是：成为一种适用于网络的 _书写_ 语言。</p><p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想 _不是_<br>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种 _发布_<br>的格式，Markdown 是一种 _书写_ 的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是<br>Markdown；只要直接加标签就可以了。</p><p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code><br>等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML<br>区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p><p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p><pre><code>这是一个普通段落。&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;Foo&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;这是另一个普通段落。</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown<br>样式的<code>*强调*</code>会没有效果。</p><p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown<br>的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的<br><code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p><p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p><h3 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML<br>实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p><p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code><br>字符也要转换。比如你要链接到：</p><pre><code>http://images.google.com/images?num=30&amp;q=larry+bird</code></pre><p>你必须要把网址转换写为：</p><pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird</code></pre><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p><p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成<br><code>&amp;amp</code>;。</p><p>所以你如果要在文档中插入一个版权符号 <code>(C)</code>，你可以这样写：</p><pre><code>&amp;copy;</code></pre><p>Markdown 会保留它不动。而若你写：</p><pre><code>AT&amp;T</code></pre><p>Markdown 就会将它转为：</p><pre><code>AT&amp;amp;T</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那<br>Markdown 也不会对它做任何转换，但是如果你写：</p><pre><code>4 &lt; 5</code></pre><p>Markdown 将会把它转换为：</p><pre><code>4 &amp;lt; 5</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都 _一定_ 会被转换成 HTML 实体，这项特性让你可以很容易地用<br>Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在<br>HTML 文件里面写出 HTML code。）</p><hr><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>一个 Markdown<br>段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p><p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML<br>格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p><p>如果你 _确实_ 想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p><p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合，<br>Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题的语法，类<br><a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 和类<br><a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a> 形式。</p><p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><pre><code>This is an H1=============This is an H2-------------</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p><p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p><pre><code># 这是 H1## 这是 H2###### 这是 H6</code></pre><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code><br>数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p><pre><code># 这是 H1 ### 这是 H2 ##### 这是 H3 ######</code></pre><h3 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h3><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在<br>Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.</code></pre><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p><pre><code>&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><pre><code>&gt; ## 这是一个标题。&gt; &gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择 <em>增加引用阶层</em> 。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号、加号或是减号作为列表标记：</p><pre><code>*   Red*   Green*   Blue</code></pre><p>等同于：</p><pre><code>+   Red+   Green+   Blue</code></pre><p>也等同于：</p><pre><code>-   Red-   Green-   Blue</code></pre><p>有序列表则使用数字接着一个英文句点：</p><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p><pre><code>&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt;</code></pre><p>如果你的列表标记写成：</p><pre><code>1.  Bird1.  McHale1.  Parish</code></pre><p>或甚至是：</p><pre><code>3. Bird1. McHale8. Parish</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p><p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p><pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,    viverra nec, fringilla in, laoreet vitae, risus.*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.    Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre><p>但是如果你懒，那也行：</p><pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code> 标签包起来，举例来说：</p><pre><code>*   Bird*   Magic</code></pre><p>会被转换为：</p><pre><code>&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt;</code></pre><p>但是这个：</p><pre><code>*   Bird*   Magic</code></pre><p>会被转换为：</p><pre><code>&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p><pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor    sit amet, consectetuer adipiscing elit. Aliquam hendrerit    mi posuere lectus.    Vestibulum enim wisi, viverra nec, fringilla in, laoreet    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum    sit amet velit.2.  Suspendisse id sem consectetuer libero luctus adipiscing.</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><pre><code>*   This is a list item with two paragraphs.    This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.*   Another item in the same list.</code></pre><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p><pre><code>*   A list item with a blockquote:    &gt; This is a blockquote    &gt; inside a list item.</code></pre><p>如果要放代码区块的话，该区块就需要缩进 _两次_ ，也就是 8 个空格或是 2 个制表符：</p><pre><code>*   一列表项包含一个列表区块：        &lt;代码写在这&gt;</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p><pre><code>1986. What a great season.</code></pre><p>换句话说，也就是在行首出现 <em>数字-句点-空白</em> ，要避免这样的状况，你可以在句点前面加上反斜杠。</p><pre><code>1986\. What a great season.</code></pre><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown<br>会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p><p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p><pre><code>这是一个普通段落：    这是一个代码区块。</code></pre><p>Markdown 会转换成：</p><pre><code>&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt;</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p><pre><code>Here is an example of AppleScript:    tell application &quot;Foo&quot;        beep    end tell</code></pre><p>会被转换为：</p><pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;    beepend tell&lt;/code&gt;&lt;/pre&gt;</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML<br>原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p><pre><code>&lt;div class=&quot;footer&quot;&gt;    &amp;copy; 2004 Foo Corporation&lt;/div&gt;</code></pre><p>会被转换为：</p><pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;    &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;</code></pre><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown<br>语法相关的文件。</p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code>* * *********- - ----------------------------------------</code></pre><hr><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支持两种形式的链接语法： <em>行内式</em> 和 <em>参考式</em> 两种形式。</p><p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p>要建立一个 <em>行内式</em> 的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把<br>title 文字包起来即可，例如：</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><p>会产生：</p><pre><code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt;</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p><pre><code>See my [About](/about/) page for details.</code></pre><p><em>参考式</em> 的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p><pre><code>This is [an example] [id] reference-style link.</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code></pre><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同：</p><pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;[foo]: http://example.com/  &apos;Optional Title Here&apos;[foo]: http://example.com/  (Optional Title Here)</code></pre><p><strong>请注意：</strong> 有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p><p>链接网址也可以用尖括号包起来：</p><pre><code>[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p><pre><code>[id]: http://example.com/longish/path/to/resource/here    &quot;Optional Title Here&quot;</code></pre><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p><p>链接辨别标签可以有字母、数字、空白和标点符号，但是并 _不_ 区分大小写，因此下面两个链接是一样的：</p><pre><code>[link text][a][link text][A]</code></pre><p><em>隐式链接标记</em> 功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让<br>“Google” 链接到 google.com，你可以简化成：</p><pre><code>[Google][]</code></pre><p>然后定义链接内容：</p><pre><code>[Google]: http://google.com/</code></pre><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p><pre><code>Visit [Daring Fireball][] for more information.</code></pre><p>然后接着定义链接：</p><pre><code>[Daring Fireball]: http://daringfireball.net/</code></pre><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>下面是一个参考式链接的范例：</p><pre><code>I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].  [1]: http://google.com/        &quot;Google&quot;  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;  [3]: http://search.msn.com/    &quot;MSN Search&quot;</code></pre><p>如果改成用链接名称的方式写：</p><pre><code>I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][].  [google]: http://google.com/        &quot;Google&quot;  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</code></pre><p>上面两种写法都会产生下面的 HTML。</p><pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;</code></pre><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p><pre><code>I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or[MSN](http://search.msn.com/ &quot;MSN Search&quot;).</code></pre><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176<br>个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p><p>使用 Markdown<br>的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个<br><code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p><pre><code>*single asterisks*_single underscores_**double asterisks**__double underscores__</code></pre><p>会转成：</p><pre><code>&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt;</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p><p>强调也可以直接插在文字中间：</p><pre><code>un*frigging*believable</code></pre><p>但是 <strong>如果你的<code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong> 。</p><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p><pre><code>\*this text is surrounded by literal asterisks\*</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>`</code>），例如：</p><pre><code>Use the `printf()` function.</code></pre><p>会产生：</p><pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><pre><code>``There is a literal backtick (`) here.``</code></pre><p>这段语法会产生：</p><pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;</code></pre><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p><pre><code>A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` ``</code></pre><p>会产生：</p><pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;</code></pre><p>在代码区段内，<code>&amp;</code> 和尖括号 <strong>都</strong> 会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p><pre><code>Please don&apos;t use any `&lt;blink&gt;` tags.</code></pre><p>转为：</p><pre><code>&lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;</code></pre><p>你也可以这样写：</p><pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.</code></pre><p>以产生：</p><pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em> 和 <em>参考式</em> 。</p><p>行内式的图片语法看起来像是：</p><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre><p>详细叙述如下：</p><ul><li>一个惊叹号 <code>!</code></li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li></ul><p>参考式的图片语法则长得像这样：</p><pre><code>![Alt text][id]</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p><pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown<br>就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><pre><code>&lt;http://example.com/&gt;</code></pre><p>Markdown 会转为：</p><pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML<br>实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p><pre><code>&lt;address@example.com&gt;</code></pre><p>Markdown 会转成：</p><pre><code>&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;</code></pre><p>在浏览器里面，这段字串（其实是 <code>&lt;ahref=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「<a href="mailto:address@example.com" target="_blank" rel="noopener">address@example.com</a>」链接。</p><p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code><br>标签），你可以在星号的前面加上反斜杠：</p><pre><code>\*literal asterisks\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><h2 id="转载之wowubuntu"><a href="#转载之wowubuntu" class="headerlink" title="转载之wowubuntu"></a><a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="noopener">转载之wowubuntu</a></h2>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jQuery</title>
      <link href="/2018/03/14/cnblog_8565153/"/>
      <url>/2018/03/14/cnblog_8565153/</url>
      <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h2><ol><li>jQuery是一个轻量级的、兼容多浏览器的JavaScript库。</li><li>jQuery使用户能够更方便地处理HTML Document、Events、实现动画效果、方便地进行Ajax交互，能够极大地简化JavaScript编程。它的宗旨就是：”Write less, do more.”</li></ol><h2 id="jQuery的优势"><a href="#jQuery的优势" class="headerlink" title="jQuery的优势"></a>jQuery的优势</h2><ol><li>一款轻量级的JS框架。jQuery核心js文件才几十kb，不会影响页面加载速度。</li><li>丰富的DOM选择器,jQuery的选择器用起来很方便，比如要找到某个DOM对象的相邻元素，JS可能要写好几行代码，而jQuery一行代码就搞定了，再比如要将一个表格的隔行变色，jQuery也是一行代码搞定。</li><li>链式表达式。jQuery的链式操作可以把多个操作写在一行代码里，更加简洁。</li><li>事件、样式、动画支持。jQuery还简化了js操作css的代码，并且代码的可读性也比js要强。</li><li>Ajax操作支持。jQuery简化了AJAX操作，后端只需返回一个JSON格式的字符串就能完成与前端的通信。</li><li>跨浏览器兼容。jQuery基本兼容了现在主流的浏览器，不用再为浏览器的兼容问题而伤透脑筋。</li><li>插件扩展开发。jQuery有着丰富的第三方的插件，例如：树形菜单、日期控件、图片切换插件、弹出窗口等等基本前端页面上的组件都有对应插件，并且用jQuery插件做出来的效果很炫，并且可以根据自己需要去改写和封装插件，简单实用。</li></ol><h2 id="jQuery内容："><a href="#jQuery内容：" class="headerlink" title="jQuery内容："></a>jQuery内容：</h2><ol><li>选择器</li><li>筛选器</li><li>样式操作</li><li>文本操作</li><li>属性操作</li><li>文档处理</li><li>事件</li><li>动画效果</li><li>插件</li><li>each、data、Ajax</li></ol><p>下载链接：<a href="https://jquery.com/" target="_blank" rel="noopener">jQuery官网</a></p><h2 id="jQuery版本"><a href="#jQuery版本" class="headerlink" title="jQuery版本"></a>jQuery版本</h2><ul><li>1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</li><li>2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</li><li>3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本。</li></ul><p><em>维护IE678是一件让人头疼的事情，一般我们都会额外加载一个CSS和JS单独处理。值得庆幸的是使用这些浏览器的人也逐步减少，PC端用户已经逐步被移动端用户所取代，如果没有特殊要求的话，一般都会选择放弃对678的支持。</em></p><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p><strong>jQuery对象</strong> 就是通过jQuery包装DOM对象后产生的对象。 <strong>jQuery对象</strong> 是 jQuery独有的。如果一个对象是<br><strong>jQuery对象</strong> ，那么它就可以使用 <strong>jQuery</strong> 里的方法：例如$(“#i1”).html()。</p><p><code>$(&quot;#i1&quot;).html()</code>的意思是：获取id值为 <code>i1</code>的元素的html代码。其中 <code>html()</code>是jQuery里的方法。</p><p>相当于： <code>document.getElementById(&quot;i1&quot;).innerHTML;</code></p><p>虽然 <code>jQuery对象</code>是包装 <code>DOM对象</code>后产生的，但是 <code>jQuery对象</code>无法使用 <code>DOM对象</code>的任何方法，同理 <code>DOM对象</code>也没不能使用<br><code>jQuery</code>里的方法。</p><p>一个约定，我们在声明一个jQuery对象变量的时候在变量名前面加上$：</p><pre><code>var $variable = jQuery对像var variable = DOM对象$variable[0]//jQuery对象转成DOM对象</code></pre><p>拿上面那个例子举例，jQuery对象和DOM对象的使用：</p><pre><code>$(&quot;#i1&quot;).html();//jQuery对象可以使用jQuery的方法$(&quot;#i1&quot;)[0].innerHTML;// DOM对象使用DOM的方法</code></pre><h2 id="jQuery基础语法"><a href="#jQuery基础语法" class="headerlink" title="jQuery基础语法"></a>jQuery基础语法</h2><p><code>$(selector).action()</code></p><h2 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p><strong>id选择器：</strong></p><pre><code>$(&quot;#id&quot;)</code></pre><p><strong>标签选择器：</strong></p><pre><code>$(&quot;tagName&quot;)</code></pre><p><strong>class选择器：</strong></p><pre><code>$(&quot;.className&quot;)</code></pre><p><strong>配合使用：</strong></p><pre><code>$(&quot;div.c1&quot;)   // 找到有c1 class类的div标签</code></pre><p><strong>所有元素选择器：</strong></p><pre><code>$(&quot;*&quot;)</code></pre><p><strong>组合选择器：</strong></p><pre><code>$(&quot;#id, .className, tagName&quot;)</code></pre><p><strong>层级选择器：</strong></p><p><em>x和y可以为任意选择器</em></p><pre><code>$(&quot;x y&quot;); // x的所有后代y（子子孙孙）$(&quot;x &gt; y&quot;);// x的所有儿子y（儿子）$(&quot;x + y&quot;)// 找到所有紧挨在x后面的y$(&quot;x ~ y&quot;)// x之后所有的兄弟y</code></pre><p><strong>基本筛选器：</strong></p><pre><code>:first  // 第一个:last // 最后一个:eq(index)// 索引等于index的那个元素:even // 匹配所有索引值为偶数的元素，从 0 开始计数:odd // 匹配所有索引值为奇数的元素，从 0 开始计数:gt(index)// 匹配所有大于给定索引值的元素:lt(index)// 匹配所有小于给定索引值的元素:not(元素选择器)// 移除所有满足not条件的标签:has(元素选择器)// 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找)</code></pre><p><strong>例子：</strong></p><pre><code>$(&quot;div:has(h1)&quot;) // 找到所有后代中有h1标签的div标签$(&quot;div:has(.c1)&quot;)// 找到所有后代中有c1样式类的div标签$(&quot;li:not(.c1)&quot;)// 找到所有不包含c1样式类的li标签$(&quot;li:not(:has(a))&quot;)// 找到所有后代中不含a标签的li标签</code></pre><p>练习：</p><p>自定义模态框，使用jQuery实现弹出和隐藏功能。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;自定义模态框&lt;/title&gt;  &lt;style&gt;    .cover {      position: fixed;      left: 0;      right: 0;      top: 0;      bottom: 0;      background-color: darkgrey;      z-index: 999;    }    .modal {      width: 600px;      height: 400px;      background-color: white;      position: fixed;      left: 50%;      top: 50%;      margin-left: -300px;      margin-top: -200px;      z-index: 1000;    }    .hide {      display: none;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;弹&quot; id=&quot;i0&quot;&gt;&lt;div class=&quot;cover hide&quot;&gt;&lt;/div&gt;&lt;div class=&quot;modal hide&quot;&gt;  &lt;label for=&quot;i1&quot;&gt;姓名&lt;/label&gt;  &lt;input id=&quot;i1&quot; type=&quot;text&quot;&gt;   &lt;label for=&quot;i2&quot;&gt;爱好&lt;/label&gt;  &lt;input id=&quot;i2&quot; type=&quot;text&quot;&gt;  &lt;input type=&quot;button&quot; id=&quot;i3&quot; value=&quot;关闭&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  var tButton = $(&quot;#i0&quot;)[0];  tButton.onclick=function () {    var coverEle = $(&quot;.cover&quot;)[0];    var modalEle = $(&quot;.modal&quot;)[0];    $(coverEle).removeClass(&quot;hide&quot;);    $(modalEle).removeClass(&quot;hide&quot;);  };  var cButton = $(&quot;#i3&quot;)[0];  cButton.onclick=function () {    var coverEle = $(&quot;.cover&quot;)[0];    var modalEle = $(&quot;.modal&quot;)[0];    $(coverEle).addClass(&quot;hide&quot;);    $(modalEle).addClass(&quot;hide&quot;);  }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>jQuery版自定义模态框</p><p><strong>属性选择器：</strong></p><pre><code> [attribute][attribute=value]// 属性等于[attribute!=value]// 属性不等于  </code></pre><p><strong>例子：</strong></p><pre><code> // 示例&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;$(&quot;input[type=&apos;checkbox&apos;]&quot;);// 取到checkbox类型的input标签$(&quot;input[type!=&apos;text&apos;]&quot;);// 取到类型不是text的input标签</code></pre><p><strong>表单常用筛选</strong> ：</p><pre><code>:text:password  :file:radio:checkbox  :submit:reset:button  </code></pre><p><strong>例子：</strong></p><pre><code>$(&quot;:checkbox&quot;)   // 找到所有的checkbox</code></pre><p>表单对象属性:</p><pre><code>:enabled:disabled:checked:selected</code></pre><p><strong>例子：</strong></p><pre><code>&lt;form&gt;  &lt;input name=&quot;email&quot; disabled=&quot;disabled&quot; /&gt;  &lt;input name=&quot;id&quot; /&gt;&lt;/form&gt;$( &quot;input:enabled&quot;)  // 找到可用的input标签&lt;select id=&quot;s1&quot;&gt;  &lt;option value=&quot;beijing&quot;&gt;北京市&lt;/option&gt;  &lt;option value=&quot;shanghai&quot;&gt;上海市&lt;/option&gt;  &lt;option selected value=&quot;guangzhou&quot;&gt;广州市&lt;/option&gt;  &lt;option value=&quot;shenzhen&quot;&gt;深圳市&lt;/option&gt;&lt;/select&gt;$(&quot;:selected&quot;)  // 找到所有被选中的option</code></pre><h3 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h3><p>下一个元素：</p><pre><code>$(&quot;#id&quot;).next()$(&quot;#id&quot;).nextAll()$(&quot;#id&quot;).nextUntil(&quot;#i2&quot;)</code></pre><p>上一个元素：</p><pre><code>$(&quot;#id&quot;).prev()$(&quot;#id&quot;).prevAll()$(&quot;#id&quot;).prevUntil(&quot;#i2&quot;)</code></pre><p>父亲元素：</p><pre><code>$(&quot;#id&quot;).parent()$(&quot;#id&quot;).parents()  // 查找当前元素的所有的父辈元素  $(&quot;#id&quot;).parentsUntil() // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。</code></pre><p>儿子和兄弟元素：</p><pre><code>$(&quot;#id&quot;).children();// 儿子们$(&quot;#id&quot;).siblings();// 兄弟们</code></pre><p>查找元素：</p><pre><code>$(&quot;#id&quot;).find()// 搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</code></pre><p>补充：</p><pre><code>.first()// 获取匹配的第一个元素.last()// 获取匹配的最后一个元素.not()// 从匹配元素的集合中删除与指定表达式匹配的元素.has()// 保留包含特定后代的元素，去掉那些不含有指定后代的元素。</code></pre><p>示例：左侧菜单</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;左侧菜单示例&lt;/title&gt;  &lt;style&gt;    .left {      position: fixed;      left: 0;      top: 0;      width: 20%;      height: 100%;      background-color: rgb(47, 53, 61);    }    .right {      width: 80%;      height: 100%;    }    .menu {      color: white;    }    .title {      text-align: center;      padding: 10px 15px;      border-bottom: 1px solid #23282e;    }    .items {      background-color: #181c20;    }    .item {      padding: 5px 10px;      border-bottom: 1px solid #23282e;    }    .hide {      display: none;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;left&quot;&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;菜单一&lt;/div&gt;    &lt;div class=&quot;items&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;title&quot;&gt;菜单二&lt;/div&gt;    &lt;div class=&quot;items hide&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;title&quot;&gt;菜单三&lt;/div&gt;    &lt;div class=&quot;items hide&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;.title&quot;).click(function (){  // jQuery绑定事件    // 隐藏所有class里有.items的标签    $(&quot;.items&quot;).addClass(&quot;hide&quot;);  //批量操作    $(this).next().removeClass(&quot;hide&quot;);  });&lt;/script&gt;</code></pre><p>左侧菜单示例</p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p>样式类</p><pre><code>addClass();// 添加指定的CSS类名。removeClass();// 移除指定的CSS类名。hasClass();// 判断样式存不存在toggleClass();// 切换CSS类名，如果有就移除，如果没有就添加。</code></pre><p>示例：开关灯和模态框</p><p>CSS</p><pre><code>css(&quot;color&quot;,&quot;red&quot;)//DOM操作：tag.style.color=&quot;red&quot;</code></pre><p>示例：</p><pre><code>$(&quot;p&quot;).css(&quot;color&quot;, &quot;red&quot;); //将所有p标签的字体设置为红色</code></pre><p>位置：</p><pre><code>offset()// 获取匹配元素在当前窗口的相对偏移或设置元素位置position()// 获取匹配元素相对父元素的偏移scrollTop()// 获取匹配元素相对滚动条顶部的偏移scrollLeft()// 获取匹配元素相对滚动条左侧的偏移</code></pre><p><code>.offset()</code>方法允许我们检索一个元素相对于文档（document）的当前位置。</p><p>和 <code>.position()</code>的差别在于： <code>.position()</code>是相对于相对于父级元素的位移。</p><p>示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;位置相关示例之返回顶部&lt;/title&gt;  &lt;style&gt;    .c1 {      width: 100px;      height: 200px;      background-color: red;    }    .c2 {      height: 50px;      width: 50px;      position: fixed;      bottom: 15px;      right: 15px;      background-color: #2b669a;    }    .hide {      display: none;    }    .c3 {      height: 100px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;b1&quot; class=&quot;btn btn-default&quot;&gt;点我&lt;/button&gt;&lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;95&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;96&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;97&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;98&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;99&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;100&lt;/div&gt;&lt;button id=&quot;b2&quot; class=&quot;btn btn-default c2 hide&quot;&gt;返回顶部&lt;/button&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;#b1&quot;).on(&quot;click&quot;, function () {    $(&quot;.c1&quot;).offset({left: 200, top:200});  });  $(window).scroll(function () {    if ($(window).scrollTop() &gt; 100) {      $(&quot;#b2&quot;).removeClass(&quot;hide&quot;);    }else {      $(&quot;#b2&quot;).addClass(&quot;hide&quot;);    }  });  $(&quot;#b2&quot;).on(&quot;click&quot;, function () {    $(window).scrollTop(0);  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>返回顶部示例</p><p>尺寸：</p><pre><code>height()width()innerHeight()innerWidth()outerHeight()outerWidth()</code></pre><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><p>HTML代码：</p><pre><code>html()// 取得第一个匹配元素的html内容html(val)// 设置所有匹配元素的html内容</code></pre><p>文本值：</p><pre><code>text()// 取得所有匹配元素的内容text(val)// 设置所有匹配元素的内容</code></pre><p>值：</p><pre><code>val()// 取得第一个匹配元素的当前值val(val)// 设置所有匹配元素的值val([val1, val2])// 设置checkbox、select的值</code></pre><p>示例：</p><p>获取被选中的checkbox或radio的值：</p><pre><code>&lt;label for=&quot;c1&quot;&gt;女&lt;/label&gt;&lt;input name=&quot;gender&quot; id=&quot;c1&quot; type=&quot;radio&quot; value=&quot;0&quot;&gt;&lt;label for=&quot;c2&quot;&gt;男&lt;/label&gt;&lt;input name=&quot;gender&quot; id=&quot;c2&quot; type=&quot;radio&quot; value=&quot;1&quot;&gt;</code></pre><p>可以使用：</p><pre><code>$(&quot;input[name=&apos;gender&apos;]:checked&quot;).val()</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;jQuery val示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;label for=&quot;s1&quot;&gt;城市&lt;/label&gt;&lt;select id=&quot;s1&quot;&gt;  &lt;option value=&quot;beijing&quot;&gt;北京市&lt;/option&gt;  &lt;option value=&quot;shanghai&quot;&gt;上海市&lt;/option&gt;  &lt;option selected value=&quot;guangzhou&quot;&gt;广州市&lt;/option&gt;  &lt;option value=&quot;shenzhen&quot;&gt;深圳市&lt;/option&gt;&lt;/select&gt;&lt;hr&gt;&lt;label for=&quot;s2&quot;&gt;爱好&lt;/label&gt;&lt;select id=&quot;s2&quot; multiple=&quot;multiple&quot;&gt;  &lt;option value=&quot;basketball&quot; selected&gt;篮球&lt;/option&gt;  &lt;option value=&quot;football&quot;&gt;足球&lt;/option&gt;  &lt;option value=&quot;doublecolorball&quot; selected&gt;双色球&lt;/option&gt;&lt;/select&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // 单选下拉框  $(&quot;#s1&quot;).val(&quot;shanghai&quot;);  // 多选下拉框   $(&quot;#s2&quot;).val([&quot;basketball&quot;, &quot;football&quot;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>jQuery val赋值示例</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;文本操作之登录验证&lt;/title&gt;  &lt;style&gt;    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt;  &lt;div&gt;    &lt;label for=&quot;input-name&quot;&gt;用户名&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;input-name&quot; name=&quot;name&quot;&gt;    &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;label for=&quot;input-password&quot;&gt;密码&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;input-password&quot; name=&quot;password&quot;&gt;    &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  &lt;/div&gt;&lt;/form&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;#btn&quot;).click(function () {    var username = $(&quot;#input-name&quot;).val();    var password = $(&quot;#input-password&quot;).val();    if (username.length === 0) {      $(&quot;#input-name&quot;).siblings(&quot;.error&quot;).text(&quot;用户名不能为空&quot;);    }    if (password.length === 0) {      $(&quot;#input-password&quot;).siblings(&quot;.error&quot;).text(&quot;密码不能为空&quot;);    }  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>自定义登录校验示例</p><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>用于ID等或自定义属性：</p><pre><code>attr(attrName)// 返回第一个匹配元素的属性值attr(attrName, attrValue)// 为所有匹配元素设置一个属性值attr({k1: v1, k2:v2})// 为所有匹配元素设置多个属性值removeAttr()// 从每一个匹配的元素中删除一个属性</code></pre><p>用于checkbox和radio</p><pre><code>prop() // 获取属性removeProp() // 移除属性</code></pre><p><strong>注意：</strong></p><p>在1.x及2.x版本的jQuery中使用attr对checkbox进行复制操作时会出bug，在3.x版本的jQuery中则没有这个问题。为了兼容性，我们在处理checkbox和radio的时候尽量使用特定的prop()，不要使用attr(“checked”,<br>“checked”)。</p><pre><code>&lt;input type=&quot;checkbox&quot; value=&quot;1&quot;&gt;&lt;input type=&quot;radio&quot; value=&quot;2&quot;&gt;&lt;script&gt;  $(&quot;:checkbox[value=&apos;1&apos;]&quot;).prop(&quot;checked&quot;, true);  $(&quot;:radio[value=&apos;2&apos;]&quot;).prop(&quot;checked&quot;, true);&lt;/script&gt;</code></pre><p>示例：全选、反选、取消</p><h3 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h3><p>添加到指定元素 <strong>内部</strong> 的后面</p><pre><code>$(A).append(B)// 把B追加到A$(A).appendTo(B)// 把A追加到B</code></pre><p>添加到指定元素 <strong>内部</strong> 的前面</p><pre><code>$(A).prepend(B)// 把B前置到A$(A).prependTo(B)// 把A前置到B</code></pre><p>添加到指定元素 <strong>外部</strong> 的后面</p><pre><code>$(A).after(B)// 把B放到A的后面$(A).insertAfter(B)// 把A放到B的后面</code></pre><p>添加到指定元素 <strong>外部</strong> 的前面</p><pre><code>$(A).before(B)// 把B放到A的前面$(A).insertBefore(B)// 把A放到B的前面</code></pre><p>移除和清空元素</p><pre><code>remove()// 从DOM中删除所有匹配的元素。empty()// 删除匹配的元素集合中所有的子节点。</code></pre><p>例子：</p><p>点击按钮在表格添加一行数据。</p><p>点击每一行的删除按钮删除当前行数据。</p><p>替换</p><pre><code>replaceWith()replaceAll()</code></pre><p>克隆</p><pre><code>clone()// 参数</code></pre><p>克隆示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;克隆&lt;/title&gt;  &lt;style&gt;    #b1 {      background-color: deeppink;      padding: 5px;      color: white;      margin: 5px;    }    #b2 {      background-color: dodgerblue;      padding: 5px;      color: white;      margin: 5px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;b1&quot;&gt;屠龙宝刀，点击就送&lt;/button&gt;&lt;hr&gt;&lt;button id=&quot;b2&quot;&gt;屠龙宝刀，点击就送&lt;/button&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // clone方法不加参数true，克隆标签但不克隆标签带的事件  $(&quot;#b1&quot;).on(&quot;click&quot;, function () {    $(this).clone().insertAfter(this);  });  // clone方法加参数true，克隆标签并且克隆标签带的事件  $(&quot;#b2&quot;).on(&quot;click&quot;, function () {    $(this).clone(true).insertAfter(this);  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>点击复制按钮</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><pre><code>click(function(){...})hover(function(){...})blur(function(){...})focus(function(){...})change(function(){...})keyup(function(){...})</code></pre><p>keydown和keyup事件组合示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;键盘事件示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;  &lt;thead&gt;  &lt;tr&gt;    &lt;th&gt;#&lt;/th&gt;    &lt;th&gt;姓名&lt;/th&gt;    &lt;th&gt;操作&lt;/th&gt;  &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Egon&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Alex&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Yuan&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;EvaJ&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Gold&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;全选&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;取消&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b3&quot; value=&quot;反选&quot;&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // 全选  $(&quot;#b1&quot;).on(&quot;click&quot;, function () {    $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, true);  });  // 取消  $(&quot;#b2&quot;).on(&quot;click&quot;, function () {    $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, false);  });  // 反选  $(&quot;#b3&quot;).on(&quot;click&quot;, function () {    $(&quot;:checkbox&quot;).each(function () {      var flag = $(this).prop(&quot;checked&quot;);      $(this).prop(&quot;checked&quot;, !flag);    })  });  // 按住shift键，批量操作  // 定义全局变量  var flag = false;  // 全局事件，监听键盘shift按键是否被按下  $(window).on(&quot;keydown&quot;, function (e) {//    alert(e.keyCode);    if (e.keyCode === 16){      flag = true;    }  });  // 全局事件,shift按键抬起时将全局变量置为false  $(window).on(&quot;keyup&quot;, function (e) {    if (e.keyCode === 16){      flag = false;    }  });  // select绑定change事件  $(&quot;table select&quot;).on(&quot;change&quot;, function () {    // 是否为批量操作模式    if (flag) {      var selectValue = $(this).val();      // 找到所有被选中的那一行的select，选中指定值      $(&quot;input:checked&quot;).parent().parent().find(&quot;select&quot;).val(selectValue);    }  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>按住shift键批量操作</p><p>实时监听input输入值变化示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;实时监听input输入值变化&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;i1&quot;&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  /*  * oninput是HTML5的标准事件  * 能够检测textarea,input:text,input:password和input:search这几个元素的内容变化，  * 在内容修改后立即被触发，不像onchange事件需要失去焦点才触发  * oninput事件在IE9以下版本不支持，需要使用IE特有的onpropertychange事件替代  * 使用jQuery库的话直接使用on同时绑定这两个事件即可。  * */  $(&quot;#i1&quot;).on(&quot;input propertychange&quot;, function () {    alert($(this).val());  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>input值变化事件</p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ol><li><code>.on( events [, selector ],function(){})</code></li></ol><ul><li>events： 事件</li><li>selector: 选择器（可选的）</li><li>function: 事件处理函数</li></ul><h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><ol><li><code>.off( events [, selector ][,function(){}])</code></li></ol><p><code>off()</code> 方法移除用 <code>.on()</code>绑定的事件处理程序。</p><ul><li>events： 事件</li><li>selector: 选择器（可选的）</li><li>function: 事件处理函数</li></ul><h3 id="阻止后续事件执行"><a href="#阻止后续事件执行" class="headerlink" title="阻止后续事件执行"></a>阻止后续事件执行</h3><ol><li><code>return false; // 常见阻止表单提交等</code></li></ol><p>注意：</p><p>像click、keydown等DOM中定义的事件，我们都可以使用<code>.on()</code>方法来绑定事件，但是<code>hover</code>这种jQuery中定义的事件就不能用<code>.on()</code>方法来绑定了。</p><p>想使用事件委托的方式绑定hover事件处理函数，可以参照如下代码分两步绑定事件：</p><pre><code>$(&apos;ul&apos;).on(&apos;mouseenter&apos;, &apos;li&apos;, function() {//绑定鼠标进入事件    $(this).addClass(&apos;hover&apos;);});$(&apos;ul&apos;).on(&apos;mouseleave&apos;, &apos;li&apos;, function() {//绑定鼠标划出事件    $(this).removeClass(&apos;hover&apos;);});</code></pre><h3 id="页面载入"><a href="#页面载入" class="headerlink" title="页面载入"></a>页面载入</h3><p>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。</p><p>两种写法：</p><pre><code>$(document).ready(function(){// 在这里写你的JS代码...})</code></pre><p>简写：</p><pre><code>$(function(){// 你在这里写你的代码})</code></pre><p>文档加载完绑定事件，并且阻止默认事件发生：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;登录注册示例&lt;/title&gt;  &lt;style&gt;    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&quot;myForm&quot;&gt;  &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;  &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;  &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;label for=&quot;passwd&quot;&gt;密码&lt;/label&gt;  &lt;input type=&quot;password&quot; id=&quot;passwd&quot;&gt;  &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;input type=&quot;submit&quot; id=&quot;modal-submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;s7validate.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  function myValidation() {    // 多次用到的jQuery对象存储到一个变量，避免重复查询文档树    var $myForm = $(&quot;#myForm&quot;);    $myForm.find(&quot;:submit&quot;).on(&quot;click&quot;, function () {      // 定义一个标志位，记录表单填写是否正常      var flag = true;      $myForm.find(&quot;:text, :password&quot;).each(function () {        var val = $(this).val();        if (val.length &lt;= 0 ){          var labelName = $(this).prev(&quot;label&quot;).text();          $(this).next(&quot;span&quot;).text(labelName + &quot;不能为空&quot;);          flag = false;        }      });      // 表单填写有误就会返回false，阻止submit按钮默认的提交表单事件      return flag;    });    // input输入框获取焦点后移除之前的错误提示信息    $myForm.find(&quot;input[type!=&apos;submit&apos;]&quot;).on(&quot;focus&quot;, function () {      $(this).next(&quot;.error&quot;).text(&quot;&quot;);    })  }  // 文档树就绪后执行  $(document).ready(function () {    myValidation();  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>登录校验示例</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是通过事件冒泡的原理，利用父标签去捕获子标签的事件。</p><p>示例：</p><p>表格中每一行的编辑和删除按钮都能触发相应的事件。</p><pre><code>$(&quot;table&quot;).on(&quot;click&quot;, &quot;.delete&quot;, function () {  // 删除按钮绑定的事件})</code></pre><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><pre><code>// 基本show([s,[e],[fn]])hide([s,[e],[fn]])toggle([s],[e],[fn])// 滑动slideDown([s],[e],[fn])slideUp([s,[e],[fn]])slideToggle([s],[e],[fn])// 淡入淡出fadeIn([s],[e],[fn])fadeOut([s],[e],[fn])fadeTo([[s],o,[e],[fn]])fadeToggle([s,[e],[fn]])// 自定义（了解即可）animate(p,[s],[e],[fn])</code></pre><p>自定义动画示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;点赞动画示例&lt;/title&gt;  &lt;style&gt;    div {      position: relative;      display: inline-block;    }    div&gt;i {      display: inline-block;      color: red;      position: absolute;      right: -16px;      top: -5px;      opacity: 1;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;d1&quot;&gt;点赞&lt;/div&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;#d1&quot;).on(&quot;click&quot;, function () {    var newI = document.createElement(&quot;i&quot;);    newI.innerText = &quot;+1&quot;;    $(this).append(newI);    $(this).children(&quot;i&quot;).animate({      opacity: 0    }, 1000)  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>点赞特效简单示例</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p><strong>jQuery.each(collection, callback(indexInArray, valueOfElement))：</strong></p><p>描述：一个通用的迭代函数，它可以用来无缝迭代对象和数组。数组和类似数组的对象通过一个长度属性（如一个函数的参数对象）来迭代数字索引，从0到length -<br>1。其他对象通过其属性名进行迭代。</p><pre><code>li =[10,20,30,40]$.each(li,function(i, v){  console.log(i, v);//index是索引，ele是每次循环的具体元素。})</code></pre><p>输出：</p><pre><code>010120230340</code></pre><p><strong>.each(function(index, Element))：</strong></p><p>描述：遍历一个jQuery对象，为每个匹配元素执行一个函数。</p><p><code>.each()</code><br>方法用来迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。由于回调函数是在当前DOM元素为上下文的语境中触发的，所以关键字<br><code>this</code> 总是指向这个元素。</p><pre><code>// 为每一个li标签添加foo$(&quot;li&quot;).each(function(){  $(this).addClass(&quot;c1&quot;);});</code></pre><p>注意: jQuery的方法返回一个jQuery对象，遍历jQuery集合中的元素 - 被称为隐式 _迭代_<br>的过程。当这种情况发生时，它通常不需要显式地循环的 <code>.each()</code>方法：</p><p>也就是说，上面的例子没有必要使用each()方法，直接像下面这样写就可以了：</p><pre><code>$(&quot;li&quot;).addClass(&quot;c1&quot;);  // 对所有标签做统一操作</code></pre><p><strong>注意：</strong></p><p>在遍历过程中可以使用 <code>return false</code>提前结束each循环。</p><p><strong>终止each循环</strong></p><pre><code>return false；</code></pre><p>伏笔…</p><h3 id="data"><a href="#data" class="headerlink" title=".data()"></a>.data()</h3><p>在匹配的元素集合中的所有元素上存储任意相关数据或返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p><p><strong>.data(key, value):</strong></p><p>描述：在匹配的元素上存储任意相关数据。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;,100);//给所有div标签都保存一个名为k，值为100</code></pre><p><strong>.data(key):</strong></p><p>描述: 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值–通过 <code>.data(name, value)</code>或 <code>HTML5 data-*</code>属性设置。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;);//返回第一个div标签中保存的&quot;k&quot;的值</code></pre><p>.removeData(key):</p><p>描述：移除存放在元素上的数据，不加key参数表示移除所有保存的数据。</p><pre><code>$(&quot;div&quot;).removeData(&quot;k&quot;);  //移除元素上存放k对应的数据</code></pre><p>示例：</p><p>模态框编辑的数据回填表格</p><h3 id="插件-了解即可"><a href="#插件-了解即可" class="headerlink" title="插件(了解即可)"></a>插件(了解即可)</h3><p>jQuery.extend(object)</p><p>jQuery的命名空间下添加新的功能。多用于插件开发者向 jQuery 中添加新函数时使用。</p><p>示例：</p><pre><code>&lt;script&gt;jQuery.extend({  min:function(a, b){return a &lt; b ? a : b;},  max:function(a, b){return a &gt; b ? a : b;}});jQuery.min(2,3);// =&gt; 2jQuery.max(4,5);// =&gt; 5&lt;/script&gt;</code></pre><p>jQuery.fn.extend(object)</p><p>一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。</p><pre><code>&lt;script&gt;  jQuery.fn.extend({    check:function(){      return this.each(function(){this.checked =true;});    },    uncheck:function(){      return this.each(function(){this.checked =false;});    }  });// jQuery对象可以使用新添加的check()方法了。$(&quot;input[type=&apos;checkbox&apos;]&quot;).check();&lt;/script&gt;</code></pre><p>单独写在文件中的扩展：</p><pre><code>(function(jq){  jq.extend({    funcName:function(){    ...    },  });})(jQuery);</code></pre><p>例子：</p><p>自定义的jQuery登录验证插件</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;登录校验示例&lt;/title&gt;  &lt;style&gt;    .login-form {      margin: 100px auto 0;      max-width: 330px;    }    .login-form &gt; div {      margin: 15px 0;    }    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;  &lt;form action=&quot;&quot; class=&quot;login-form&quot; novalidate&gt;    &lt;div&gt;      &lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;      &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;name&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;passwd&quot;&gt;密码&lt;/label&gt;      &lt;input id=&quot;passwd&quot; type=&quot;password&quot; name=&quot;password&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;mobile&quot;&gt;手机&lt;/label&gt;      &lt;input id=&quot;mobile&quot; type=&quot;text&quot; name=&quot;mobile&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;where&quot;&gt;来自&lt;/label&gt;      &lt;input id=&quot;where&quot; type=&quot;text&quot; name=&quot;where&quot; autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/div&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;validate.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $.validate();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTML文件</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&quot;use strict&quot;;(function ($) {  function check() {    // 定义一个标志位，表示验证通过还是验证不通过    var flag = true;    var errMsg;    // 校验规则    $(&quot;form input[type!=&apos;:submit&apos;]&quot;).each(function () {      var labelName = $(this).prev().text();      var inputName = $(this).attr(&quot;name&quot;);      var inputValue = $(this).val();      if ($(this).attr(&quot;required&quot;)) {        // 如果是必填项        if (inputValue.length === 0) {          // 值为空          errMsg = labelName + &quot;不能为空&quot;;          $(this).next().text(errMsg);          flag = false;          return false;        }        // 如果是密码类型，我们就要判断密码的长度是否大于6位        if (inputName === &quot;password&quot;) {          // 除了上面判断为不为空还要判断密码长度是否大于6位          if (inputValue.length &lt; 6) {            errMsg = labelName + &quot;必须大于6位&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }        // 如果是手机类型，我们需要判断手机的格式是否正确        if (inputName === &quot;mobile&quot;) {          // 使用正则表达式校验inputValue是否为正确的手机号码          if (!/^1[345678]\d{9}$/.test(inputValue)) {            // 不是有效的手机号码格式            errMsg = labelName + &quot;格式不正确&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }      }    });    return flag;  }  function clearError(arg) {    // 清空之前的错误提示    $(arg).next().text(&quot;&quot;);  }  // 上面都是我定义的工具函数  $.extend({    validate: function () {      $(&quot;form :submit&quot;).on(&quot;click&quot;, function () {      return check();    });    $(&quot;form :input[type!=&apos;submit&apos;]&quot;).on(&quot;focus&quot;, function () {      clearError(this);    });    }  });})(jQuery);</code></pre><p>JS文件</p><p> 传参版插件：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;登录校验示例&lt;/title&gt;  &lt;style&gt;    .login-form {      margin: 100px auto 0;      max-width: 330px;    }    .login-form &gt; div {      margin: 15px 0;    }    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;  &lt;form action=&quot;&quot; class=&quot;login-form&quot; novalidate&gt;    &lt;div&gt;      &lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;      &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;name&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;passwd&quot;&gt;密码&lt;/label&gt;      &lt;input id=&quot;passwd&quot; type=&quot;password&quot; name=&quot;password&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;mobile&quot;&gt;手机&lt;/label&gt;      &lt;input id=&quot;mobile&quot; type=&quot;text&quot; name=&quot;mobile&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;where&quot;&gt;来自&lt;/label&gt;      &lt;input id=&quot;where&quot; type=&quot;text&quot; name=&quot;where&quot; autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/div&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;validate3.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $.validate({&quot;name&quot;:{&quot;required&quot;: true}, &quot;password&quot;: {&quot;required&quot;: true, &quot;minLength&quot;: 8}, &quot;mobile&quot;: {&quot;required&quot;: true}});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTML文件</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&quot;use strict&quot;;(function ($) {  function check(arg) {    // 定义一个标志位，表示验证通过还是验证不通过    var flag = true;    var errMsg;    // 校验规则    $(&quot;form input[type!=&apos;:submit&apos;]&quot;).each(function () {      var labelName = $(this).prev().text();      var inputName = $(this).attr(&quot;name&quot;);      var inputValue = $(this).val();      if (arg[inputName].required) {        // 如果是必填项        if (inputValue.length === 0) {          // 值为空          errMsg = labelName + &quot;不能为空&quot;;          $(this).next().text(errMsg);          flag = false;          return false;        }        // 如果是密码类型，我们就要判断密码的长度是否大于6位        if (inputName === &quot;password&quot;) {          // 除了上面判断为不为空还要判断密码长度是否大于6位          if (inputValue.length &lt; arg[inputName].minLength) {            errMsg = labelName + &quot;必须大于&quot;+arg[inputName].minLength+&quot;位&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }        // 如果是手机类型，我们需要判断手机的格式是否正确        if (inputName === &quot;mobile&quot;) {          // 使用正则表达式校验inputValue是否为正确的手机号码          if (!/^1[345678]\d{9}$/.test(inputValue)) {            // 不是有效的手机号码格式            errMsg = labelName + &quot;格式不正确&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }      }    });    return flag;  }  function clearError(arg) {    // 清空之前的错误提示    $(arg).next().text(&quot;&quot;);  }  // 上面都是我定义的工具函数  $.extend({    validate: function (arg) {      $(&quot;form :submit&quot;).on(&quot;click&quot;, function () {      return check(arg);    });    $(&quot;form :input[type!=&apos;submit&apos;]&quot;).on(&quot;focus&quot;, function () {      clearError(this);    });    }  });})(jQuery);</code></pre><p>JS文件</p><p>课后习题：</p><ol><li>登录+验证</li><li>左侧菜单</li><li>表格-增、删、改、查</li></ol>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux screen 常用命令</title>
      <link href="/2018/03/13/cnblog_8554604/"/>
      <url>/2018/03/13/cnblog_8554604/</url>
      <content type="html"><![CDATA[<pre><code>screen  -s  yourname   # 创建一个名字为yourname的screenscreen  -ls   # 查看所有screenscreen -r  yourname   # 回到yourname这个screenscreen -d yourname   # 结束yourname这个screenscreen -d -r yourname   # 结束当前screen回到yourname在当前这个screen  按ctrl + A + K  杀死当前screenctrl + A + D  后台当前screen </code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端基础之BOM和DOM</title>
      <link href="/2018/03/12/cnblog_8550048/"/>
      <url>/2018/03/12/cnblog_8550048/</url>
      <content type="html"><![CDATA[<h1 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h1><p>到目前为止，我们已经学过了JavaScript的一些简单的语法。但是这些简单的语法，并没有和浏览器有任何交互。</p><p>也就是我们还不能制作一些我们经常看到的网页的一些交互，我们需要继续学习BOM和DOM相关知识。</p><p>JavaScript分为 ECMAScript，DOM，BOM。</p><p>BOM（Browser Object Model）是指浏览器窗口对象模型，顶级对象是window。</p><p>DOM （Document Object Model）是指文档对象模型，并非一个对象。</p><p>window、document都是一个实例对象，他们都属于Object，表示浏览器中打开的窗口。</p><p>Window对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先，在调用window对象的方法和属性时，可以省略window对象的引用。例如：window.document.write()可以简写成：document.write()。</p><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>window 对象表示一个浏览器窗口。</p><p>在客户端 JavaScript 中，Window<br>对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。例如，可以只写<br>document，而不必写 window.document</p><p>同样，可以把当前窗口对象的方法当作函数来使用，如只写 alert()，而不必写 Window.alert()。</p><pre><code>alert()            显示带有一段消息和一个确认按钮的警告框。setInterval()      按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval()    取消由 setInterval() 设置的 timeout。setTimeout()       在指定的毫秒数后调用函数或计算表达式。clearTimeout()     取消由 setTimeout() 方法设置的 timeout。scrollTo()         把内容滚动到指定的坐标。confirm()          显示带有一段消息以及确认按钮和取消按钮的对话框。prompt()           显示可提示用户输入的对话框。open()             打开一个新的浏览器窗口或查找一个已命名的窗口。close()            关闭浏览器窗口。</code></pre><p>几个例子</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>// 每隔一段时间就执行一次相应函数var timer = setInterval(function(){console.log(123);}, 3000)// 取消setInterval设置clearInterval(timer);// 在指定时间之后执行一次相应函数var timer = setTimeout(function(){alert(123);}, 3000)// 取消setTimeout设置clearTimeout(timer);</code></pre><p>View Code</p><h2 id="window的子对象"><a href="#window的子对象" class="headerlink" title="window的子对象"></a>window的子对象</h2><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。</p><pre><code>navigator.appName　　// Web浏览器全称navigator.appVersion　　// Web浏览器厂商和版本的详细字符串navigator.userAgent　　// 客户端绝大部分信息navigator.platform　　　// 浏览器运行所在的操作系统</code></pre><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>屏幕对象，不常用。</p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，可以用来前进或后退一个页面。</p><pre><code>history.forward()  // 前进一页history.back()  // 后退一页history.go(n)  //  前进n页</code></pre><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><pre><code>location.href  获取URLlocation.href=&quot;URL&quot; // 跳转到指定页面location.reload() 重新加载页面  </code></pre><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。<br>它是一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态地对文档的内容、结构和样式进行访问和修改。简单来讲，DOM是一种API（应用编程接口）。<br>JavaScript对DOM进行了实现，对应于JavaScript中的document对象，通过该对象对DOM文档进行程序级别的控制。</p><p>DOM标准规定HTML文档中的每个成分都是一个节点(node)：</p><ul><li>文档节点(document对象)：代表整个文档</li><li>元素节点(element 对象)：代表一个元素（标签）</li><li>文本节点(text对象)：代表元素（标签）中的文本</li><li>属性节点(attribute对象)：代表一个属性，元素（标签）才有属性</li><li>注释是注释节点(comment对象)</li></ul><h3 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h3><pre><code>document.getElementById                根据ID获取一个标签document.getElementsByName         根据name属性获取标签集合document.getElementsByClassName 根据class属性获取document.getElementsByTagName    根据标签名获取标签合集</code></pre><h3 id="间接查找"><a href="#间接查找" class="headerlink" title="间接查找"></a>间接查找</h3><pre><code>parentNode  父节点childNodes  所有子节点firstChild  第一个子节点lastChild  最后一个子节点nextSibling 下一个兄弟节点previousSibling  上一个兄弟节点  // 注意节点和标签的区别，主要记下面的parentElement 父节点标签元素children  所有子标签firstElementChild  第一个子标签元素lastElementChild  最后一个子标签元素nextElementSibling  下一个兄弟标签元素previousElementSibling  上一个兄弟标签元素</code></pre><h2 id="document对象的属性和操作"><a href="#document对象的属性和操作" class="headerlink" title="document对象的属性和操作"></a>document对象的属性和操作</h2><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>attributes</p><p>| 获取所有标签属性<br>—|—<br>getAttribute() | 获取指定标签属性<br>setAttribute() | 设置指定标签属<br>removeAttribute() | 移除指定标签属  </p><p>var s = document.createAttribute(“age”)</p><p>s.nodeValue = “18”</p><p>|</p><p>创建age属性</p><p>设置属性值为18</p><h3 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h3><table><thead><tr><th>innerText</th><th>所有的纯文本内容，包括子标签中的文本  </th></tr></thead><tbody><tr><td>outerText</td><td>与innerText类似  </td></tr><tr><td>innerHTML</td><td>所有子节点(包括元素、注释和文本节点)  </td></tr><tr><td>outerHTML</td><td>返回自身节点与所有子节点  </td></tr><tr><td></td><td></td></tr><tr><td>textContent</td><td>与innerText类似，返回的内容带样式  </td></tr><tr><td>data</td><td>文本内容  </td></tr><tr><td>length</td><td>文本长度  </td></tr><tr><td>createTextNode()</td><td>创建文本  </td></tr><tr><td>normalize()</td><td>删除文本与文本之间的空白  </td></tr><tr><td>splitText()</td><td>分割  </td></tr><tr><td>appendData()</td><td>追加  </td></tr><tr><td>deleteData(offset,count)</td><td>从offset指定的位置开始删除count个字符  </td></tr><tr><td>insertData(offset,text)</td><td>在offset指定的位置插入text  </td></tr><tr><td>replaceData(offset,count,text)</td><td>替换，从offset开始到offscount处的文本被text替换  </td></tr><tr><td>substringData(offset,count)</td><td>提取从ffset开始到offscount处的文本  </td></tr></tbody></table><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p><strong>操作class类</strong></p><pre><code> className  获取所有样式类名(字符串)  classList.remove(cls)  删除指定类classList.add(cls)  添加类  classList.contains(cls)  存在返回true，否则返回false  classList.toggle(cls)  存在就删除，否则添加</code></pre><p><strong>指定CSS操作</strong></p><pre><code>obj.style.backgroundColor=&quot;red&quot;</code></pre><p>JS操作CSS属性的规律：</p><p>1.对于没有中横线的CSS属性一般直接使用style.属性名即可。如：</p><pre><code>obj.style.marginobj.style.widthobj.style.leftobj.style.position</code></pre><p>2.对含有中横线的CSS属性，将中横线后面的第一个字母换成大写即可。如：</p><pre><code>obj.style.marginTopobj.style.borderLeftWidthobj.style.zIndexobj.style.fontFamily</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段<br>JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。</p><pre><code>onclick        当用户点击某个对象时调用的事件句柄。ondblclick     当用户双击某个对象时调用的事件句柄。onfocus        元素获得焦点。               // 练习：输入框onblur         元素失去焦点。               应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.onchange       域的内容被改变。             应用场景：通常用于表单元素,当元素内容被改变时触发.（select联动）onkeydown      某个键盘按键被按下。          应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.onkeypress     某个键盘按键被按下并松开。onkeyup        某个键盘按键被松开。onload         一张页面或一幅图像完成加载。onmousedown    鼠标按钮被按下。onmousemove    鼠标被移动。onmouseout     鼠标从某元素移开。onmouseover    鼠标移到某元素之上。onselect      在文本框中的文本被选中时发生。onsubmit      确认按钮被点击，使用的对象是form。</code></pre><h2 id="常用的那些"><a href="#常用的那些" class="headerlink" title="常用的那些"></a>常用的那些</h2><h3 id="操作内容"><a href="#操作内容" class="headerlink" title="操作内容"></a>操作内容</h3><pre><code>innerText  文本innerHTML  HTML内容value  值</code></pre><h3 id="文档节点的增删改查"><a href="#文档节点的增删改查" class="headerlink" title="文档节点的增删改查"></a>文档节点的增删改查</h3><p><strong>增</strong></p><pre><code> createElement(name)  创建节点（标签）  appendChild() 末尾添加节点，并返回新增节点  insertBefore()  参照节点之前插入节点，两个参数：要插入的节点和参照节点  </code></pre><p><strong>删</strong></p><pre><code> 查找到要删除的元素获取它的父元素使用removeChild()方法删除</code></pre><p><strong>改</strong>  </p><p>第一种方式:</p><pre><code>使用上面增和删结合完成修改</code></pre><p>第二种方式:</p><pre><code>使用setAttribute();方法修改属性          使用innerHTML属性修改元素的内容</code></pre><p><strong>查</strong></p><p>使用之前介绍的方法.</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>404 Not Found 页面走丢了😭</title>
      <link href="//404.html"/>
      <url>//404.html</url>
      <content type="html"><![CDATA[<hr><h1 id="👉回主页"><a href="#👉回主页" class="headerlink" title="👉回主页"></a><a href="https://wevsmy.github.io">👉回主页</a></h1>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="wilson"><a href="#wilson" class="headerlink" title="wilson"></a>wilson</h1><ul><li>Email:<a href="mailto:wevsmy@gmail.com" target="_blank" rel="noopener">wevsmy@gmail.com</a></li><li>Homepage:<a href="https://wevsmy.github.io">Wilson’s Blog</a></li><li>GitHub:<a href="https://github.com/wevsmy" target="_blank" rel="noopener">@wilson</a></li><li>Weibo:<a href="https://weibo.com/wevsmy" target="_blank" rel="noopener">@wilson</a></li></ul><hr><h1 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h1><p>长方体混凝土瞬间移动攻城狮<br>专职Python后端开发<br>略懂前端，略懂脚本，略懂机器学习</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
