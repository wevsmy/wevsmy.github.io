<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>使用docker搭建smtp服务</title>
      <link href="/2019/08/31/docker-install-smtp-server/"/>
      <url>/2019/08/31/docker-install-smtp-server/</url>
      <content type="html"><![CDATA[<p>前段时间搭建gitlab服务harbor仓库，需要用到SMTP服务用于发送邮件，用的自己办公邮箱做的测试，给别人自动发的邮件显示的是自己的邮箱。。。不正规😋申请公司的公共邮箱流程太繁琐了😥 还是自己搭建一个SMTP服务吧，自己动手丰衣足食。</p><a id="more"></a><h1 id="docker使用SMTP搭建邮件发送服务"><a href="#docker使用SMTP搭建邮件发送服务" class="headerlink" title="docker使用SMTP搭建邮件发送服务"></a>docker使用SMTP搭建邮件发送服务</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull namshi/smtp<br></code></pre></td></tr></table></figure><h2 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h2><p>采用<code>docker-compose</code>进行服务编排<br>启动<code>docker-compose up -d</code> or <code>docker-compose -f docker-compose.yml up -d</code></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── conf<br>│   ├── hosts<br>│   └── resolv.conf<br>├── docker-compose.yml<br>├── README.md<br>└── smtp.py<br><br>1 directory, 5 files<br></code></pre></td></tr></table></figure><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="hljs highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">  SMTP:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">namshi/smtp</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">SMTP</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"10025:25"</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      RELAY_NETWORKS:</span> <span class="hljs-string">:0.0.0.0/0</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">./conf/hosts:/etc/hosts</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">./conf/resolv.conf:/etc/resolv.conf</span><br></code></pre></td></tr></table></figure><ul><li>1.用为没有加密，所有就把默认的25端口给换个端口映射到宿主机，再说反正是公司内网环境。。。😎</li><li>2.RELAY_NETWORKS这个环境变量的作用是负责发件请求的拦截，当设置为“:0.0.0.0/0”时表示任意客户端皆可发起发件请求😁</li><li>3.指定主机域，不然发送出去的邮件，发件人为<code>Mail Delivery System &lt;Mailer-Daemon@c4de06bf41e5&gt;</code>，添加主机名后就可以伪造发件人啦🤔<br>  <img src="/2019/08/31/docker-install-smtp-server/1565665933.png" alt="没加hosts发送邮件" title="没加hosts发送邮件" style="width:200px;height:100px"><img src="/2019/08/31/docker-install-smtp-server/1565666449.png" alt="加过hosts之后发送邮件" title="加过hosts之后发送邮件" style="width:200px;height:100px"></li><li>4.邮件发送搜索goertek.com的域，因为公司内网DNS的MX邮件解析问题，在内网找不到要发送给内网邮箱用户的MX记录。。。就是内网找不到<a href="mailto:xxx@goertek.com" target="_blank" rel="noopener">xxx@goertek.com</a>的MX记录，所以指定DNS解析resolv.conf🌚</li></ul><h3 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">127.0.0.1 goertek.local<br></code></pre></td></tr></table></figure><h3 id="resolv-conf"><a href="#resolv-conf" class="headerlink" title="resolv.conf"></a>resolv.conf</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">search goertek.com<br>options ndots:0<br>nameserver 114.114.114.114<br></code></pre></td></tr></table></figure><h3 id="smtp-py"><a href="#smtp-py" class="headerlink" title="smtp.py"></a>smtp.py</h3><p>测试py<br><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> smtplib<br><span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header<br><span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText<br><br>sender = <span class="hljs-string">'willson-wu-shi-ge-dao-lao-ma?@goertek.local'</span><br>receivers = [<span class="hljs-string">'willson.wu@goertek.com'</span>]<br><br>message = MIMEText(<span class="hljs-string">'SMTP服务邮件发送测试...  请勿回复！'</span>, <span class="hljs-string">'plain'</span>, <span class="hljs-string">'utf-8'</span>)<br><br>subject = <span class="hljs-string">'SMTP服务邮件测试'</span><br>message[<span class="hljs-string">'Subject'</span>] = Header(subject, <span class="hljs-string">'utf-8'</span>)<br><br><span class="hljs-keyword">try</span>:<br>    smtpObj = smtplib.SMTP(<span class="hljs-string">'10.10.192.18'</span>, <span class="hljs-number">10025</span>)<br>    smtpObj.sendmail(sender, receivers, message.as_string())<br>    <span class="hljs-keyword">print</span> (<span class="hljs-string">"邮件发送成功"</span>)<br><span class="hljs-keyword">except</span> smtplib.SMTPException:<br>    <span class="hljs-keyword">print</span> (<span class="hljs-string">"Error: 无法发送邮件"</span>)<br></code></pre></td></tr></table></figure></p><p>执行测试<code>python3 smtp.py</code><br>亲测内网环境下发邮件没问题！满足需求！<br>这下搭建的服务都可以配置SMTP邮件通知啦！👌</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>镜像<a href="https://hub.docker.com/r/namshi/smtp" target="_blank" rel="noopener">namshi/smtp</a> docker hub 上 pulls 10M+</li><li>镜像作者的<a href="https://github.com/namshi/docker-smtp" target="_blank" rel="noopener">GayHub</a></li><li><a href="https://zhuanlan.zhihu.com/p/34162708" target="_blank" rel="noopener">使用Docker搭建SMTP服务器</a></li></ul>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SMTP </tag>
            
            <tag> 订阅 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker使用squid搭建代理服务</title>
      <link href="/2019/07/17/docker%E4%BD%BF%E7%94%A8squid%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/07/17/docker%E4%BD%BF%E7%94%A8squid%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>记录一下配置代理的过程。</p><a id="more"></a><h1 id="docker使用squid搭建代理服务"><a href="#docker使用squid搭建代理服务" class="headerlink" title="docker使用squid搭建代理服务"></a>docker使用squid搭建代理服务</h1><h2 id="记录一下"><a href="#记录一下" class="headerlink" title="记录一下"></a>记录一下</h2><ul><li>docker-compose.yml</li></ul><figure class="hljs highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span><br><br><span class="hljs-attr">services:</span><br><br><span class="hljs-attr">  squid:</span><br><span class="hljs-attr">      image:</span> <span class="hljs-string">sameersbn/squid:3.5.27-2</span><br><span class="hljs-attr">      ports:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">"3128:3128"</span><br><span class="hljs-attr">      volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">/home/dev/srv/docker/squid/cache:/var/spool/squid</span><br><span class="hljs-bullet">        -</span> <span class="hljs-string">./squid.conf:/etc/squid/squid.conf</span><br><span class="hljs-attr">      restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><ul><li>squid.conf</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">acl all src 0.0.0.0/0.0.0.0<br><br>acl SSL_ports port 443<br><br>acl Safe_ports port 80      # http<br><br>acl Safe_ports port 443     # https<br><br>acl CONNECT method CONNECT<br><br>http_access allow all<br><br>http_port 3128<br><br>visible_hostname proxy<br></code></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ftp_proxy</span>=http://10.10.192.18:3128<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">http_proxy</span>=http://10.10.192.18:3128<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">https_proxy</span>=http://10.10.192.18:3128<br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker修改默认网段</title>
      <link href="/2019/07/17/docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5/"/>
      <url>/2019/07/17/docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5/</url>
      <content type="html"><![CDATA[<p>docker-compose 启动的网桥使用的网段与公司172.31.xx.xx网段冲突</p><a id="more"></a><h1 id="docker使用docker-compose造成网段冲突"><a href="#docker使用docker-compose造成网段冲突" class="headerlink" title="docker使用docker-compose造成网段冲突"></a>docker使用docker-compose造成网段冲突</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>docker-compose每次创建新的网桥的时候，还是使用默认的172.xx.xx.xx<br>在使用docker-compose启动服务其，创建了一个172.31.0.1的网桥，你说巧不巧，恰好公司使用的网络网段为172.31.66.xx所以使用172.31.xx.xx的网络，访问不了，哭死，咋办，不能改公司网络，只能修改docker网络配置了</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><strong>只需修改一个地方，然后docker-compose up创建新网桥的时候就会使用我们设置的那个网段和子网；像修改docker0的网段一样，修改/etc/docker/daemon.json配置文件，docker0的网段就会变为在daemon.json里设置的这个；有没有类似于只要修改一个配置文件，docker-compose每次创建新的网桥的时候都会按照配置文件里的来</strong></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在<code>/etc/docker/daemon.json</code>添加</p><figure class="hljs highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"debug"</span> : <span class="hljs-literal">true</span>,<br><span class="hljs-attr">"default-address-pools"</span> : [<br>    &#123;<br>      <span class="hljs-attr">"base"</span> : <span class="hljs-string">"12.11.0.0/16"</span>,<br>      <span class="hljs-attr">"size"</span> : <span class="hljs-number">24</span><br>    &#125;<br>  ] <br>&#125;<br></code></pre></td></tr></table></figure><p>然后重启<code>docker</code>服务</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service docker restart<br></code></pre></td></tr></table></figure><p><strong>亲测可以使用</strong></p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker目录磁盘空间满了</title>
      <link href="/2019/07/16/docker%20low%20disk%20space/"/>
      <url>/2019/07/16/docker%20low%20disk%20space/</url>
      <content type="html"><![CDATA[<p>😂昨天刚建的GitLab服务今天就报500了，哭死<br>排查发现是<code>/var/lib/docker</code>目录满了，咱也不知道原来里面放的啥，咱也不敢动，咱走还不行嘛！</p><a id="more"></a><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[gitlab@cep-server-bj ~]$ df -h /var/lib/docker<br>文件系统             容量  已用  可用 已用% 挂载点<br>/dev/mapper/cl-root   50G   50G  180M  100% /<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>先看看哪里还有地方让俺去</p>  <figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[gitlab@cep-server-bj ~]$ df -h<br>文件系统             容量  已用  可用 已用% 挂载点<br>/dev/mapper/cl-root   50G   50G  180M  100% /<br>devtmpfs              63G     0   63G    0% /dev<br>tmpfs                 63G   96K   63G    1% /dev/shm<br>tmpfs                 63G  4.2G   59G    7% /run<br>tmpfs                 63G     0   63G    0% /sys/fs/cgroup<br>/dev/sda2           1014M  165M  850M   17% /boot<br>/dev/sda1            200M  9.5M  191M    5% /boot/efi<br>/dev/mapper/cl-home  5.7T  1.6T  4.2T   28% /home<br>tmpfs                 13G   20K   13G    1% /run/user/1000<br>tmpfs                 13G     0   13G    0% /run/user/987<br>tmpfs                 13G     0   13G    0% /run/user/1001<br></code></pre></td></tr></table></figure></li></ul><pre><code>嘿，`/dev/mapper/cl-home`这个地方挺大的，就搬到这里吧🙂</code></pre><ul><li><p>停了docker服务</p>  <figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop docker<br></code></pre></td></tr></table></figure></li><li><p>给docker建个窝</p>  <figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /home/dev/var/lib/docker<br></code></pre></td></tr></table></figure></li><li><p>搬家</p>  <figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rsync -avz /var/lib/docker/ /home/dev/var/lib/docker<br></code></pre></td></tr></table></figure></li><li><p>改配置，指向新家</p><p>查看<code>/etc/systemd/system/docker.service.d</code>目录及<code>devicemapper.conf</code>是否存在。如果不存在，就新建</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/systemd/system/docker.service.d/<br>sudo vim /etc/systemd/system/docker.service.d/devicemapper.conf<br></code></pre></td></tr></table></figure><p><code>devicemapper.conf</code>添加如下内容：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Service]<br>ExecStart=/usr/bin/dockerd  --graph=/home/dev/var/lib/docker<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>启动docker</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl restart docker<br>systemctl enable docker<br></code></pre></td></tr></table></figure></li><li><p>确认一哈<br>确认<code>Docker Root Dir</code>修改是否已经生效</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">[gitlab@cep-server-bj lib]$ docker info<br>Containers: 0<br> Running: 0<br> Paused: 0<br> Stopped: 0<br>Images: 2<br>Server Version: 18.09.7<br>Storage Driver: overlay2<br> Backing Filesystem: xfs<br> Supports d_type: true<br> Native Overlay Diff: false<br>Logging Driver: json-file<br>Cgroup Driver: cgroupfs<br>Plugins:<br> Volume: local<br> Network: bridge host macvlan null overlay<br> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog<br>Swarm: inactive<br>Runtimes: runc<br>Default Runtime: runc<br>Init Binary: docker-init<br>containerd version: 894b81a4b802e4eb2a91d1ce216b8817763c29fb<br>runc version: 425e105d5a03fabd737a126ad93d62a9eeede87f<br>init version: fec3683<br>Security Options:<br> seccomp<br>  Profile: default<br>Kernel Version: 3.10.0-514.el7.x86_64<br>Operating System: CentOS Linux 7 (Core)<br>OSType: linux<br>Architecture: x86_64<br>CPUs: 24<br>Total Memory: 125.1GiB<br>Name: cep-server-bj<br>ID: HL4V:SNMX:2JYC:WISH:K6HM:J4YR:4GQG:SAFL:7YS4:MHNE:WK3I:XRTW<br>Docker Root Dir: /home/dev/var/lib/docker<br>Debug Mode (client): false<br>Debug Mode (server): false<br>Registry: https://index.docker.io/v1/<br>Labels:<br>Experimental: false<br>Insecure Registries:<br> 127.0.0.0/8<br>Live Restore Enabled: false<br>Product License: Community Engine<br></code></pre></td></tr></table></figure></li></ul><p>  看到<code>Docker Root Dir: /home/dev/var/lib/docker</code>我就知道这次搬家稳了😁</p><p>  话说上面这配置，玩吃鸡卡不卡🙃</p><ul><li><p>看看原来的镜像还在嘛</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[gitlab@cep-server-bj lib]$ docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>sameersbn/gitlab    12.0.0              6f35c078d0de        2 days ago          2.48GB<br>sameersbn/redis     4.0.9-2             8f89b2ebe8be        6 months ago        90.3MB<br></code></pre></td></tr></table></figure></li><li><p>确认没问题删除<code>/var/lib/docker/</code>中文件</p></li></ul><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>深层次的问题点找到了。。。</p><p>我是猪🐷</p><p>系统盘总共才有50G的磁盘空间，我却把gitlab的数据全放到了系统根目录下了😂</p><p>gitlab的数据占了40多个G的空间</p><p>下次注意：启动<code>docker</code>其使用的<code>volumes</code>要放个大点的地方😁</p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gitlab服务器迁移</title>
      <link href="/2019/07/15/gitlab%E8%BF%81%E7%A7%BB/"/>
      <url>/2019/07/15/gitlab%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>公司有需求安装在172.31.66.63的gitlab服务需要迁移到10.10.192.18上，记录一下迁移过程。</p><a id="more"></a><h1 id="安装docker环境"><a href="#安装docker环境" class="headerlink" title="安装docker环境"></a>安装docker环境</h1><p>新机器CentOS安装docker环境</p><ul><li>清理自带的docker</li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum remove docker \<br>docker-client \<br>docker-client-latest \<br>docker-common \<br>docker-latest \<br>docker-latest-logrotate \<br>docker-logrotate \<br>docker-engine<br></code></pre></td></tr></table></figure><ul><li>安装依赖</li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y yum-utils \<br>device-mapper-persistent-data \<br>lvm2<br></code></pre></td></tr></table></figure><ul><li>添加仓库</li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum-config-manager \<br>--add-repo \<br>https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><ul><li>安装docker-ce</li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><ul><li>安装docker-compose</li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h1 id="迁移gitlab"><a href="#迁移gitlab" class="headerlink" title="迁移gitlab"></a>迁移gitlab</h1><p>把gitlab的数据迁移到新的机器中<code>/srv/docker/gitlab</code></p><p><code>scp -r 目录名 用户名@计算机IP或者计算机名称:远程路径</code></p><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p><code>bundle exec bin/rake gitlab:backup:create RAILS_ENV=production</code></p><h1 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h1><p><code>bundle exec bin/rake gitlab:backup:restore RAILS_ENV=production BACKUP=1563163325_2019_07_15_11.1.4</code></p><h2 id="docker-compose文件"><a href="#docker-compose文件" class="headerlink" title="docker-compose文件"></a>docker-compose文件</h2><figure class="hljs highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">'2'</span><br><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">  redis:</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">sameersbn/redis:4.0.9-2</span><br><span class="hljs-attr">    command:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--loglevel</span> <span class="hljs-string">warning</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">/srv/docker/gitlab/redis:/var/lib/redis</span><br><br><span class="hljs-attr">  postgresql:</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">sameersbn/postgresql:10-2</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">/srv/docker/gitlab/postgresql:/var/lib/postgresql</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_USER=gitlab</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_PASS=password</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_NAME=gitlabhq_production</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_EXTENSION=pg_trgm</span><br><br><span class="hljs-attr">  gitlab:</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">sameersbn/gitlab:12.0.0</span><br><span class="hljs-attr">    depends_on:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">redis</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">postgresql</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">"80:80"</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">"10022:22"</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">/srv/docker/gitlab/gitlab:/home/git/data</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DEBUG=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_ADAPTER=postgresql</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_HOST=postgresql</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_PORT=5432</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_USER=gitlab</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_PASS=password</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">DB_NAME=gitlabhq_production</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">REDIS_HOST=redis</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">REDIS_PORT=6379</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">TZ=UTC</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_TIMEZONE=UTC</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_HTTPS=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SSL_SELF_SIGNED=false</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_HOST=10.10.192.18</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_PORT=80</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_SSH_PORT=10022</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_RELATIVE_URL_ROOT=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_SECRETS_DB_KEY_BASE=9LMMzdfMCTwmmJLcq37kThXbv4xPrMCmWpmqcKxgTnvhg3VRVF4PTXXmXvv7twfr</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_SECRETS_SECRET_KEY_BASE=w9stWVkKTsj3qcPcV4vrCWhcmbrMm9W9fVvLKfV9NvgqXJwf9XKpbb43h4KnHsxR</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_SECRETS_OTP_KEY_BASE=KWFp9CgzRwWLFPKMTgHfwK4mVWtLTcFssw3JbnzkRHpPzcVWwFTww4wkzTxxvLwb</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_ROOT_PASSWORD=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_ROOT_EMAIL=willson.wu@goertek.com</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_NOTIFY_ON_BROKEN_BUILDS=true</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_NOTIFY_PUSHER=false</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_EMAIL=willson.wu@goertek.com</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_EMAIL_REPLY_TO=willson.wu@goertek.com</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_INCOMING_EMAIL_ADDRESS=willson.wu@goertek.com</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_BACKUP_SCHEDULE=daily</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">GITLAB_BACKUP_TIME=04:00</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_ENABLED=true</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_DOMAIN=www.goertek.com</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_HOST=smtp.goertek.com</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_PORT=465</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_USER=willson.wu@goertek.com</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_PASS=xxxxxxx</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_STARTTLS=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_TLS=true</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">SMTP_AUTHENTICATION=login</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">IMAP_ENABLED=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">IMAP_HOST=imap.gmail.com</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">IMAP_PORT=993</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">IMAP_USER=mailer@example.com</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">IMAP_PASS=password</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">IMAP_SSL=true</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">IMAP_STARTTLS=false</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_ENABLED=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_ALLOW_SSO=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_BLOCK_AUTO_CREATED_USERS=true</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AUTO_LINK_LDAP_USER=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AUTO_LINK_SAML_USER=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_EXTERNAL_PROVIDERS=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CAS3_LABEL=cas3</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CAS3_SERVER=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CAS3_LOGIN_URL=/cas/login</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CAS3_LOGOUT_URL=/cas/logout</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GOOGLE_API_KEY=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GOOGLE_APP_SECRET=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GOOGLE_RESTRICT_DOMAIN=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_FACEBOOK_API_KEY=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_FACEBOOK_APP_SECRET=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_TWITTER_API_KEY=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_TWITTER_APP_SECRET=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GITHUB_API_KEY=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GITHUB_APP_SECRET=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GITHUB_URL=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GITHUB_VERIFY_SSL=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GITLAB_API_KEY=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_GITLAB_APP_SECRET=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_BITBUCKET_API_KEY=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_BITBUCKET_APP_SECRET=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_IDP_CERT_FINGERPRINT=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_IDP_SSO_TARGET_URL=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_ISSUER=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_LABEL="Our</span> <span class="hljs-string">SAML</span> <span class="hljs-string">Provider"</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_GROUPS_ATTRIBUTE=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_EXTERNAL_GROUPS=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CROWD_SERVER_URL=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CROWD_APP_NAME=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_CROWD_APP_PASSWORD=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AUTH0_CLIENT_ID=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AUTH0_CLIENT_SECRET=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AUTH0_DOMAIN=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AZURE_API_KEY=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AZURE_API_SECRET=</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">OAUTH_AZURE_TENANT_ID=</span><br><br><span class="hljs-bullet">    -</span> <span class="hljs-string">NGINX_WORKERS=4</span><br>    <span class="hljs-comment">#- GITLAB_MATTERMOST_ENABLED=true</span><br>    <span class="hljs-comment">#- GITLAB_MATTERMOST_URL="http://10.10.192.18:10080/"</span><br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编写Dockerfile分阶段构建Vue项目</title>
      <link href="/2019/07/15/docker-build-vue/"/>
      <url>/2019/07/15/docker-build-vue/</url>
      <content type="html"><![CDATA[<p>docker构建部署vue项目，减少构建后的docker镜像的大小，采用分阶段构建，只保留build</p><a id="more"></a><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 第一阶段,拉取node基础镜像并安装依赖,执行构建</span><br><span class="hljs-keyword">FROM</span> node:latest as builder<br><span class="hljs-comment"># 标签</span><br><span class="hljs-keyword">LABEL</span><span class="bash"> maintainer=<span class="hljs-string">"&lt;willson.wu@goertek.com&gt;"</span><br></span><span class="hljs-comment"># 参数</span><br><span class="hljs-keyword">ARG</span> WEB_GIT_URL=http://willson.wu:<span class="hljs-number">12345678</span>@<span class="hljs-number">10.10</span>.<span class="hljs-number">192.18</span>/cep/BigData/energy-web.git<br><span class="hljs-comment"># npm源 淘宝源</span><br><span class="hljs-keyword">ARG</span> NPM_REGISTRY=https://registry.npm.taobao.org<br><span class="hljs-comment"># APT换源加速 阿里源</span><br><span class="hljs-keyword">COPY</span><span class="bash"> .docker/conf/sources.list /etc/apt<br></span><span class="hljs-comment"># 更新并安装git</span><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get -q update &amp;&amp; \<br>    apt-get -q install -y git<br></span><span class="hljs-comment"># 拉取代码</span><br><span class="hljs-keyword">RUN</span><span class="bash"> git <span class="hljs-built_in">clone</span> <span class="hljs-string">"<span class="hljs-variable">$WEB_GIT_URL</span>"</span><br></span><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /energy-web<br></span><span class="hljs-comment"># 换源加速并安装项目依赖</span><br><span class="hljs-keyword">RUN</span><span class="bash"> npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver &amp;&amp; \<br>npm config <span class="hljs-built_in">set</span> registry <span class="hljs-string">"<span class="hljs-variable">$NPM_REGISTRY</span>"</span> &amp;&amp; \<br>npm install &amp;&amp; \<br>npm rebuild node-sass<br></span><span class="hljs-comment"># 构建项目</span><br><span class="hljs-keyword">RUN</span><span class="bash"> npm run build --scripts-prepend-node-path=auto<br></span><span class="hljs-comment"># 第二阶段,将构建完的产物dist文件夹COPY到实际release的镜像中,并会丢弃第一阶段中其他的文件</span><br><span class="hljs-keyword">FROM</span> nginx:latest<br><span class="hljs-comment"># copy nginx配置</span><br><span class="hljs-keyword">COPY</span><span class="bash"> .docker/conf/default.conf /etc/nginx/conf.d<br></span><span class="hljs-comment"># copy 项目编译生成文件</span><br><span class="hljs-keyword">COPY</span><span class="bash"> --from=builder /energy-web/dist /usr/share/nginx/html<br></span><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo添加文章更新时间</title>
      <link href="/2019/07/09/hexo-add-updated/"/>
      <url>/2019/07/09/hexo-add-updated/</url>
      <content type="html"><![CDATA[<p>现在使用的主题只有文章创建时间，并没有文章更新时间，就自己捣鼓捣鼓添加了一个文章更新时间，记录一下。<br><a id="more"></a></p><p>注：在<a href="https://github.com/wevsmy/hexo-theme-aria/" target="_blank" rel="noopener">aria主题</a>捣鼓的，别的不一定使用，但可以参考。</p><h1 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h1><p>修改主题的配置<br>主题配置文件添加开关，便于不想显示了可以关掉。<br><figure class="hljs highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 显示更新日期 默认为post文件修改日期</span><br><span class="hljs-attr">display_updated:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></p><h1 id="index-njk"><a href="#index-njk" class="headerlink" title="index.njk"></a>index.njk</h1><p>修改样式<br>修改主页的样式，在创建日期<code>{% if post.date %}` xxxxx `{% endif %}</code>下方添加下面代码。</p><p>注：只有在主题配置中打开显示更新日期的开关，并且更新时间大于创建时间1天，才会显示更新时间。</p><figure class="hljs highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="xml"></span><span class="hljs-template-tag">&#123;%<span class="hljs-name"><span class="hljs-keyword">if</span></span> theme.display_updated and post.updated - post.date &gt; 86400000 %&#125;</span><span class="xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"post-updated"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"post-meta-divider divider"</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"far fa-calendar-plus"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"post-updated"</span> <span class="hljs-attr">itemprop</span>=<span class="hljs-string">"dateUpdated datePublished"</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;&#123; moment(post.updated).format() &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>&gt;</span><br></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">date</span><span class="hljs-params">(post.updated, config.date_format)</span> &#125;&#125;</span><span class="xml"><br><span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-keyword">endif</span></span> %&#125;</span><span class="xml"></span><br></code></pre></td></tr></table></figure><h1 id="post-njk"><a href="#post-njk" class="headerlink" title="post.njk"></a>post.njk</h1><p>修改每一页详细内容的样式。<br>修改内容与<code>index.njk</code>一样。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pip安装mysqlclient报错</title>
      <link href="/2019/06/18/pip%E5%AE%89%E8%A3%85mysqlclient%E6%8A%A5%E9%94%99/"/>
      <url>/2019/06/18/pip%E5%AE%89%E8%A3%85mysqlclient%E6%8A%A5%E9%94%99/</url>
      <content type="html"><![CDATA[<p>使用<code>Django==2.0.4</code>报错缺少<code>mysqlclient</code>模块的解决方案</p><a id="more"></a><p>写Django项目的时，启动Django==2.0.4启动直接报错，也是醉了。<br><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">django</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.ImproperlyConfigured</span>: <span class="hljs-selector-tag">Error</span> <span class="hljs-selector-tag">loading</span> <span class="hljs-selector-tag">MySQLdb</span> <span class="hljs-selector-tag">module</span>. <br><span class="hljs-selector-tag">Did</span> <span class="hljs-selector-tag">you</span> <span class="hljs-selector-tag">install</span> <span class="hljs-selector-tag">mysqlclient</span>?<br></code></pre></td></tr></table></figure></p><p>说缺少<code>mysqlclient</code>模块。<br>简单<code>pip install mysqlclient</code><br>😭也报错了。。。👇<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs undefined">(venv) wilson@goertek-pc:~/Project/electric$ pip <span class="hljs-keyword">install</span> mysqlclient<br>Collecting mysqlclient<br>  <span class="hljs-keyword">Using</span> cached https://files.pythonhosted.org/packages/f4/f1/<span class="hljs-number">3</span>bb6f64ca7a429729413e6556b7ba5976df06019a5245a43d36032f1061e/mysqlclient<span class="hljs-number">-1.4</span><span class="hljs-number">.2</span>.post1.tar.gz<br>    <span class="hljs-keyword">ERROR</span>: <span class="hljs-keyword">Complete</span> <span class="hljs-keyword">output</span> <span class="hljs-keyword">from</span> command python setup.py egg_info:<br>    <span class="hljs-keyword">ERROR</span>: /<span class="hljs-keyword">bin</span>/sh: <span class="hljs-number">1</span>: mysql_config: <span class="hljs-keyword">not</span> <span class="hljs-keyword">found</span><br>    Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>      <span class="hljs-keyword">File</span> <span class="hljs-string">"&lt;string&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-keyword">module</span>&gt;<br>      <span class="hljs-keyword">File</span> <span class="hljs-string">"/tmp/pip-install-rfq3y_2k/mysqlclient/setup.py"</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-keyword">module</span>&gt;<br>        metadata, options = get_config()<br>      <span class="hljs-keyword">File</span> <span class="hljs-string">"/tmp/pip-install-rfq3y_2k/mysqlclient/setup_posix.py"</span>, line <span class="hljs-number">51</span>, <span class="hljs-keyword">in</span> get_config<br>        libs = mysql_config(<span class="hljs-string">"libs"</span>)<br>      <span class="hljs-keyword">File</span> <span class="hljs-string">"/tmp/pip-install-rfq3y_2k/mysqlclient/setup_posix.py"</span>, line <span class="hljs-number">29</span>, <span class="hljs-keyword">in</span> mysql_config<br>        <span class="hljs-keyword">raise</span> EnvironmentError(<span class="hljs-string">"%s not found"</span> % (_mysql_config_path,))<br>    OSError: mysql_config <span class="hljs-keyword">not</span> <span class="hljs-keyword">found</span><br>    <span class="hljs-comment">----------------------------------------</span><br><span class="hljs-keyword">ERROR</span>: Command <span class="hljs-string">"python setup.py egg_info"</span> <span class="hljs-keyword">failed</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">error</span> code <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> /tmp/pip-<span class="hljs-keyword">install</span>-rfq3y_2k/mysqlclient/<br></code></pre></td></tr></table></figure></p><p>不会百度啊！一查原来是缺少依赖<code>libmysqld-dev</code><br>安装一哈<br><figure class="hljs highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo apt-<span class="hljs-built_in">get</span> install libmysqld-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure></p><p>ok 没毛病，解决了，记录一下。</p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zulip安装记录</title>
      <link href="/2019/06/18/zulip%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/18/zulip%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>简单记录一下采用Docker安装Zulip的过程</p><a id="more"></a><p>Zulip的docker镜像在国外比较慢，我才用的是自己阿里云的镜像加速。</p><p>修改docker-compose.yml文件，其中由个别需要记录的。</p><p>就拿邮箱配置吧，由于公司邮箱对随机token的名字的邮箱会识别为垃圾邮件。</p><figure class="hljs highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">'2'</span><br><span class="hljs-attr">services:</span><br><br><span class="hljs-attr">  database:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">'zulip/zulip-postgresql'</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      POSTGRES_DB:</span> <span class="hljs-string">'zulip'</span><br><span class="hljs-attr">      POSTGRES_USER:</span> <span class="hljs-string">'zulip'</span><br>      <span class="hljs-comment"># Note that you need to do a manual `ALTER ROLE` query if you</span><br>      <span class="hljs-comment"># change this on a system after booting the postgres container</span><br>      <span class="hljs-comment"># the first time on a host.  Instructions are available in README.md.</span><br><span class="hljs-attr">      POSTGRES_PASSWORD:</span> <span class="hljs-string">'REPLACE_WITH_SECURE_POSTGRES_PASSWORD'</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">'/opt/docker/zulip/postgresql/data:/var/lib/postgresql/data:rw'</span><br><br><span class="hljs-attr">  memcached:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">'quay.io/sameersbn/memcached:latest'</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><br><span class="hljs-attr">  rabbitmq:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">'rabbitmq:3.7.7'</span><br><span class="hljs-attr">    hostname:</span> <span class="hljs-string">zulip-rabbit</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      RABBITMQ_DEFAULT_USER:</span> <span class="hljs-string">'zulip'</span><br><span class="hljs-attr">      RABBITMQ_DEFAULT_PASS:</span> <span class="hljs-string">'REPLACE_WITH_SECURE_RABBITMQ_PASSWORD'</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">'/opt/docker/zulip/rabbitmq:/var/lib/rabbitmq:rw'</span><br><br><span class="hljs-attr">  redis:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">'quay.io/sameersbn/redis:latest'</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">'/opt/docker/zulip/redis:/var/lib/redis:rw'</span><br><br><span class="hljs-attr">  zulip:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">'zulip/docker-zulip:2.0.4-0'</span><br><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">'80:80'</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">'443:443'</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      DB_HOST:</span> <span class="hljs-string">'database'</span><br><span class="hljs-attr">      DB_HOST_PORT:</span> <span class="hljs-string">'5432'</span><br><span class="hljs-attr">      DB_USER:</span> <span class="hljs-string">'zulip'</span><br><span class="hljs-attr">      SSL_CERTIFICATE_GENERATION:</span> <span class="hljs-string">'self-signed'</span><br><span class="hljs-attr">      SETTING_MEMCACHED_LOCATION:</span> <span class="hljs-string">'memcached:11211'</span><br><span class="hljs-attr">      SETTING_RABBITMQ_HOST:</span> <span class="hljs-string">'rabbitmq'</span><br><span class="hljs-attr">      SETTING_REDIS_HOST:</span> <span class="hljs-string">'redis'</span><br>      <span class="hljs-comment"># 这是邮件的密码，用来配置SMTP的，所以邮箱需要打开SMTP支持</span><br><span class="hljs-attr">      SECRETS_email_password:</span> <span class="hljs-string">'xxxxxx'</span><br>      <span class="hljs-comment"># These should match POSTGRES_PASSWORD and RABBITMQ_DEFAULT_PASS.</span><br><span class="hljs-attr">      SECRETS_rabbitmq_password:</span> <span class="hljs-string">'REPLACE_WITH_SECURE_RABBITMQ_PASSWORD'</span><br><span class="hljs-attr">      SECRETS_postgres_password:</span> <span class="hljs-string">'REPLACE_WITH_SECURE_POSTGRES_PASSWORD'</span><br><span class="hljs-attr">      SECRETS_secret_key:</span> <span class="hljs-string">'REPLACE_WITH_SECURE_SECRET_KEY'</span><br><span class="hljs-attr">      SETTING_EXTERNAL_HOST:</span> <span class="hljs-string">'172.31.66.194'</span><br><span class="hljs-attr">      SETTING_ZULIP_ADMINISTRATOR:</span> <span class="hljs-string">'willson.wu@goertek.com'</span><br>      <span class="hljs-comment"># 公司的DNS服务器经常性的被污染，直接用IP访问</span><br><span class="hljs-attr">      SETTING_EMAIL_HOST:</span> <span class="hljs-string">'123.133.65.6'</span>  <span class="hljs-comment"># e.g. smtp.example.com</span><br><span class="hljs-attr">      SETTING_EMAIL_HOST_USER:</span> <span class="hljs-string">'willson.wu@goertek.com'</span><br><span class="hljs-attr">      SETTING_EMAIL_PORT:</span> <span class="hljs-string">'25'</span><br>      <span class="hljs-comment"># It seems that the email server needs to use ssl or tls and can't be used without it</span><br>      <span class="hljs-comment"># 公司邮箱支持SSL，但是使用SSL需要用域名，直接不用也没有事，反正是公司内网</span><br><span class="hljs-attr">      SETTING_EMAIL_USE_SSL:</span> <span class="hljs-string">'False'</span><br><span class="hljs-attr">      SETTING_EMAIL_USE_TLS:</span> <span class="hljs-string">'False'</span><br>      <span class="hljs-comment"># 下面这两个配置，小坑了一下，由于公司邮箱对垃圾邮件的拦截策略，所以需要把随机发送的邮箱名字给禁掉，并且固化为自己固定的邮箱。</span><br><span class="hljs-attr">      SETTING_ADD_TOKENS_TO_NOREPLY_ADDRESS:</span> <span class="hljs-string">'False'</span><br><span class="hljs-attr">      SETTING_NOREPLY_EMAIL_ADDRESS:</span> <span class="hljs-string">'willson.wu@goertek.com'</span><br><br><span class="hljs-attr">      ZULIP_AUTH_BACKENDS:</span> <span class="hljs-string">'EmailAuthBackend'</span><br>      <span class="hljs-comment"># Uncomment this when configuring the mobile push notifications service</span><br>      <span class="hljs-comment"># SETTING_PUSH_NOTIFICATION_BOUNCER_URL: 'https://push.zulipchat.com'</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">'/opt/docker/zulip/zulip:/data:rw'</span><br><span class="hljs-attr">    ulimits:</span><br><span class="hljs-attr">      nofile:</span><br><span class="hljs-attr">        soft:</span> <span class="hljs-number">40000</span><br><span class="hljs-attr">        hard:</span> <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Zulip </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客园文章迁移到Hexo</title>
      <link href="/2019/06/10/cnblog_to_hexo/"/>
      <url>/2019/06/10/cnblog_to_hexo/</url>
      <content type="html"><![CDATA[<p>最近有些空闲时间想着把原来自学python的时候在博客园写的乱七八糟的东西给迁移到Hexo托管到github pages.</p><p>毕竟那也算是我写的，虽然有的地方抄的别人的，但是我会了，那就是我的！（牛逼坏了，叉腰！）</p><a id="more"></a><h1 id="迁移准备"><a href="#迁移准备" class="headerlink" title="迁移准备"></a>迁移准备</h1><ul><li>下载博客园备份文件</li><li>使用python写个脚本</li></ul><h1 id="脚本原理"><a href="#脚本原理" class="headerlink" title="脚本原理"></a>脚本原理</h1><p>使用sax解析xml数据，然后使用html2text转换成markdown文档，然后分成单个文件存储。<br>就这么简单，没啥难度。</p><h1 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h1><p>运行python脚本，迁移就算完成了，简不简单，意不意外，惊不惊喜！</p><p>迁移脚本：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xml.sax<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">import</span> html2text<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNBlogsHandler</span><span class="hljs-params">(xml.sax.ContentHandler)</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self.CurrentData = <span class="hljs-string">""</span><br>        self.title = <span class="hljs-string">""</span><br>        self.author = <span class="hljs-string">""</span><br>        self.pubDate = <span class="hljs-string">""</span><br>        self.guid = <span class="hljs-string">""</span><br>        self.description = <span class="hljs-string">""</span><br><br>        self.fileName = <span class="hljs-string">""</span><br>        self.date = <span class="hljs-string">""</span><br>        self.url = <span class="hljs-string">""</span><br><br>    <span class="hljs-comment"># 元素开始调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startElement</span><span class="hljs-params">(self, tag, attributes)</span>:</span><br>        self.CurrentData = tag<br>        <span class="hljs-keyword">if</span> tag == <span class="hljs-string">"item"</span>:<br>            print(<span class="hljs-string">"*****item*****"</span>)<br><br>    <span class="hljs-comment"># 元素结束调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">endElement</span><span class="hljs-params">(self, tag)</span>:</span><br>        <span class="hljs-keyword">if</span> self.CurrentData == <span class="hljs-string">"title"</span>:<br>            print(<span class="hljs-string">"title:"</span>, self.title)<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"author"</span>:<br>            print(<span class="hljs-string">"author:"</span>, self.author)<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"pubDate"</span>:<br>            print(<span class="hljs-string">"pubDate:"</span>, self.pubDate)<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"guid"</span>:<br>            print(<span class="hljs-string">"guid:"</span>, self.guid)<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"description"</span>:<br>            <span class="hljs-comment"># print("description:", self.description)</span><br>            self.saveFile()<br>        self.CurrentData = <span class="hljs-string">""</span><br><br>    <span class="hljs-comment"># 读取字符时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">characters</span><span class="hljs-params">(self, content)</span>:</span><br>        <span class="hljs-keyword">if</span> self.CurrentData == <span class="hljs-string">"title"</span>:<br>            self.title = content<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"author"</span>:<br>            self.author = content<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"pubDate"</span>:<br>            self.pubDate = content<br>            GMT_FORMAT = <span class="hljs-string">'%a, %d %b %Y %H:%M:%S GMT'</span><br>            self.date = datetime.strptime(self.pubDate, GMT_FORMAT)<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"guid"</span>:<br>            self.guid = content<br>            name = <span class="hljs-string">"cnblog_"</span> + self.guid.split(<span class="hljs-string">"/"</span>)[<span class="hljs-number">-1</span>].replace(<span class="hljs-string">".html"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">"_"</span>, <span class="hljs-string">"-"</span>)<br>            self.fileName = name + <span class="hljs-string">".md"</span><br>            self.url = <span class="hljs-string">"../../../../&#123;&#125;/&#123;:0&gt;2&#125;/&#123;:0&gt;2&#125;/&#123;&#125;/"</span>.format(self.date.year, self.date.month, self.date.day, name)<br>        <span class="hljs-keyword">elif</span> self.CurrentData == <span class="hljs-string">"description"</span>:<br>            self.description += content<br><br>    <span class="hljs-comment"># 保存Md文件</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveFile</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">if</span> self.fileName != <span class="hljs-string">""</span>:<br>            md = html2text.html2text(self.description)<br>            <span class="hljs-keyword">with</span> open(self.fileName, mode=<span class="hljs-string">"w"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:<br>                s = <span class="hljs-string">"""---<br>title: &#123;0&#125;<br>date: &#123;1&#125;<br>categories:<br>- 笔记<br>- 博客园<br>tags:<br>- 博客园<br>- 搬家<br>- cnblogs<br>---<br># [这是👉&#123;0&#125;👈的摘要](&#123;3&#125;)<br>&lt;!--more--&gt;<br>&#123;2&#125;<br>"""</span>.format(self.title, self.date, md, self.url)<br>                f.write(s)<br>                self.description = <span class="hljs-string">""</span><br><br><br><span class="hljs-keyword">if</span> (__name__ == <span class="hljs-string">"__main__"</span>):<br>    <span class="hljs-comment"># 创建一个 XMLReader</span><br>    parser = xml.sax.make_parser()<br>    <span class="hljs-comment"># 关闭命名空间</span><br>    parser.setFeature(xml.sax.handler.feature_namespaces, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 重写 ContextHandler</span><br>    Handler = CNBlogsHandler()<br>    parser.setContentHandler(Handler)<br><br>    parser.parse(<span class="hljs-string">"CNBlogs_BlogBackup_131_201712_201906.xml"</span>)<br></code></pre></td></tr></table></figure><p><a href="/2019/06/10/cnblog_to_hexo/CNBlogs_BlogBackup_131_201712_201906.xml">博客园备份xml文件</a></p><p><a href="/2019/06/10/cnblog_to_hexo/cnblogToHexo.py">迁移脚本py文件</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
            <tag> Python </tag>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker安装宝塔管理面板</title>
      <link href="/2019/03/12/docker%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/"/>
      <url>/2019/03/12/docker%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>拉取centos基础镜像，用容器启动该基础镜像，直接在容器中部署宝塔管理面板<br><a id="more"></a><br>1.拉取纯净系统镜像<br><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">docker</span> <span class="hljs-selector-tag">pull</span> <span class="hljs-selector-tag">centos</span><span class="hljs-selector-pseudo">:7.2.1511</span><br></code></pre></td></tr></table></figure></p><p>2.启动镜像，映射主机与容器内8888端口<br><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker <span class="hljs-built_in">run</span> -d -<span class="hljs-keyword">it</span> -p <span class="hljs-number">8888</span>:<span class="hljs-number">8888</span> centos:<span class="hljs-number">7.2</span><span class="hljs-number">.1511</span><br></code></pre></td></tr></table></figure></p><p>如果映射多个端口<br><figure class="hljs highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker run -d -it -<span class="hljs-selector-tag">p</span> <span class="hljs-number">8888</span>:<span class="hljs-number">8888</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span>  centos:<span class="hljs-number">7.2</span>.<span class="hljs-number">1511</span><br></code></pre></td></tr></table></figure></p><p>一般我们再映射时候。都会把  8888  80 443  3306  21 等一些常用端口都映射过去。<br>注：<code>-p 80:80</code> 前面80是宿主机本机端口，后面的80是docker容器的。<br>3.<code>docker ps</code>查看容器id，并进入容器<br><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker exec -<span class="hljs-keyword">it</span> 容器ID bash<br></code></pre></td></tr></table></figure></p><p>4.执行宝塔面板Centos安装命令<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum <span class="hljs-keyword">install</span> -y wget &amp;&amp; wget -O <span class="hljs-keyword">install</span>.sh http://download.bt.cn/<span class="hljs-keyword">install</span>/<span class="hljs-keyword">install</span>.sh &amp;&amp; sh <span class="hljs-keyword">install</span>.sh<br></code></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于docker-compose构建数据库</title>
      <link href="/2019/02/19/%E5%9F%BA%E4%BA%8Edocker-compose%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/02/19/%E5%9F%BA%E4%BA%8Edocker-compose%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>在开发的过程中免不了要使用数据库。使用docker构建一些常用的数据库免去安装的繁琐。</p><a id="more"></a><h1 id="序🤫"><a href="#序🤫" class="headerlink" title="序🤫"></a>序🤫</h1><p>使用docker构建mysql、mongo、redis、postgresql、sqlserver数据库，可以直接使用，免去安装的繁琐。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.1'</span><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">  mysql:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-attr">mysql:5.7</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"3306:3306"</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">willson</span><br><span class="hljs-attr">      MYSQL_DATABASE:</span> <span class="hljs-string">willson</span><br><span class="hljs-attr">      MYSQL_USER:</span> <span class="hljs-string">willson</span><br><span class="hljs-attr">      MYSQL_PASSWORD:</span> <span class="hljs-string">willson</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"/mnt/data2/database/mysql:/var/lib/mysql"</span><br></code></pre></td></tr></table></figure><h2 id="mongo"><a href="#mongo" class="headerlink" title="mongo"></a>mongo</h2><p>mongo默认只能本机访问，开启外网访问必须添加<code>command: [&quot;mongod&quot;,&quot;--bind_ip&quot;,&quot;0.0.0.0&quot;]</code></p><figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.1'</span><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">  mongo:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-attr">mongo:4.0.4</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">mongo</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-number">27017</span><span class="hljs-string">:27017</span><br>    <span class="hljs-comment">#    environment:</span><br>    <span class="hljs-comment">#      MONGO_INITDB_ROOT_USERNAME: root</span><br>    <span class="hljs-comment">#      MONGO_INITDB_ROOT_PASSWORD: root</span><br>    <span class="hljs-comment">#      MONGO_INITDB_DATABASE_NAME: test</span><br><span class="hljs-attr">    command:</span> <span class="hljs-string">["mongod","--bind_ip","0.0.0.0"]</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"/mnt/data2/database/mongodb:/data/db"</span><br></code></pre></td></tr></table></figure><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>参数<code>--bind 0.0.0.0</code>开启外部访问<br>参数<code>--appendonly yes</code> 开启持久化</p><figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.1'</span><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">  image:</span> <span class="hljs-attr">redis:alpine</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"6379:6379"</span><br><span class="hljs-attr">    command:</span> <span class="hljs-string">["redis-server","--bind","0.0.0.0","--appendonly","yes"]</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"/mnt/data2/database/redis:/data"</span><br></code></pre></td></tr></table></figure><h2 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h2><p>使用ubuntu系统，其启动<code>postgresql</code>有个小坑。<br>在<code>postgresql</code>的<code>volumes</code>只能映射在本机系统文件夹下，不能映射到系统外置挂载的磁盘中。不然容器跑不起来。😥</p><figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.1'</span><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">  image:</span> <span class="hljs-string">postgres</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">postgresql</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"5432:5432"</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      POSTGRES_USER:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">      POSTGRES_PASSWORD:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">      POSTGRES_DB:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">    volumes:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">'/opt/docker/database/postgresql/data:/var/lib/postgresql/data:rw'</span><br></code></pre></td></tr></table></figure><h2 id="sqlServer"><a href="#sqlServer" class="headerlink" title="sqlServer"></a>sqlServer</h2><p>其中参数<code>MSSQL_SA_PASSWORD</code>的密码必须为8位不同的、高强度的，不然容器跑不起来。🤦‍</p><figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.1'</span><br><span class="hljs-attr">services:</span><br><span class="hljs-attr">  sqlServer:</span><br><span class="hljs-attr">    image:</span> <span class="hljs-string">mcr.microsoft.com/mssql/server:2017-latest</span><br><span class="hljs-attr">    container_name:</span> <span class="hljs-string">sqlServer</span><br><span class="hljs-attr">    restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">    ports:</span><br><span class="hljs-bullet">      -</span> <span class="hljs-string">"1433:1433"</span><br><span class="hljs-attr">    environment:</span><br><span class="hljs-attr">      ACCEPT_EULA:</span> <span class="hljs-string">Y</span><br><span class="hljs-attr">      MSSQL_SA_PASSWORD:</span> <span class="hljs-number">123</span><span class="hljs-string">qwe!@#</span><br><span class="hljs-comment">#      MSSQL_PID: Express</span><br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Flask-Migrate进行管理数据库升级</title>
      <link href="/2019/01/17/%E4%BD%BF%E7%94%A8Flask-Migrate%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/01/17/%E4%BD%BF%E7%94%A8Flask-Migrate%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>我们在升级系统的时候，经常碰到需要更新服务器端数据结构等操作，之前的方式是通过手工编写alter sql脚本处理，经常会发现遗漏，导致程序发布到服务器上后无法正常使用。<br>现在我们可以使用<a href="https://flask-migrate.readthedocs.org/en/latest/" target="_blank" rel="noopener">Flask-Migrate</a>插件来解决之，Flask-Migrate插件是基于<a href="http://alembic.readthedocs.org/en/latest/" target="_blank" rel="noopener">Alembic</a>，Alembic是由大名鼎鼎的<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>作者开发数据迁移工具。</p><a id="more"></a><h1 id="使用Flask-Migrate进行管理数据库升级"><a href="#使用Flask-Migrate进行管理数据库升级" class="headerlink" title="使用Flask-Migrate进行管理数据库升级"></a>使用Flask-Migrate进行管理数据库升级</h1><p>我们在升级系统的时候，经常碰到需要更新服务器端数据结构等操作，之前的方式是通过手工编写alter sql脚本处理，经常会发现遗漏，导致程序发布到服务器上后无法正常使用。<br>现在我们可以使用<a href="https://flask-migrate.readthedocs.org/en/latest/" target="_blank" rel="noopener">Flask-Migrate</a>插件来解决之，Flask-Migrate插件是基于<a href="http://alembic.readthedocs.org/en/latest/" target="_blank" rel="noopener">Alembic</a>，Alembic是由大名鼎鼎的<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>作者开发数据迁移工具。</p><p>具体操作如下：</p><ul><li>1.安装Flask-Migrate插件<br><code>$ pip install Flask-Migrate</code></li><li><p>2.修改Flask App部分的代码，以增加Migrate相关的Command</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">db = SQLAlchemy(app)<br>migrate = Migrate(app, db)<br><br>manager = Manager(app)<br>manager.add_command(&apos;db&apos;, MigrateCommand)<br></code></pre></td></tr></table></figure></li><li><p>3.初始化<br><code>$ python app.py db init</code></p></li><li>4.数据迁移，自动创建迁移代码<br><code>$ python app.py db migrate</code></li><li>5.更新数据库<br><code>$ python app.py db upgrade</code><br>后面如果有Model变更的话，在开发环境下只需要重复执行第4、5步即可。</li></ul><p>而在服务器端只需要执行第5步即可实现数据库的迁移工作。</p><p><a href="http://www.cnblogs.com/maplye/p/5351060.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>换电脑hexo源码迁移</title>
      <link href="/2019/01/15/%E6%8D%A2%E7%94%B5%E8%84%91hexo%E6%BA%90%E7%A0%81%E8%BF%81%E7%A7%BB/"/>
      <url>/2019/01/15/%E6%8D%A2%E7%94%B5%E8%84%91hexo%E6%BA%90%E7%A0%81%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>更换电脑后迁移hexo源代码😂<br><a id="more"></a></p><h1 id="备份必要文件"><a href="#备份必要文件" class="headerlink" title="备份必要文件"></a>备份必要文件</h1><p>进入原来电脑的 hexo 博客目录，只拷如下几个目录：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">scaffolds            文章模版                          必须备份<br>source               博客文章                          必须备份<br>themes               主题                             必须备份<br>.gitignore           限定在push时那些文件可以忽略         必须备份<br>_config.yml          站点配置文件                       必须备份<br>package.json         安装包的名称                       必须备份<br><br>.ssh                 密钥文件                          必须备份<br></code></pre></td></tr></table></figure></p><p><code>ps:上面的文件可以存U盘或者打包上传到xx网盘。</code></p><h1 id="安装配置-Hexo"><a href="#安装配置-Hexo" class="headerlink" title="安装配置 Hexo"></a>安装配置 Hexo</h1><p>用之前的套路安装 Node.js 环境  Git 环境</p><ul><li>打开 开始菜单 运行 cmd</li><li>新建 blog 文件夹<br><code>md d:\blog</code></li><li>进入 blog 文件夹<br><code>cd blog</code></li><li>安装 Hexo<br><code>npm install -g hexo</code></li><li>初始化 Hexo<br><code>hexo init</code></li><li>安装依赖包<br><code>npm install</code></li></ul><p>上面的命令执行完了，你的博客目录会生成新的 hexo 博客文件，我们把刚才拷贝过来的文件，替换掉新生成的 博客文件，然后在复制 密钥文件 到新的密钥文件夹<br>在blog文件夹中打开 <code>Git Bash Here</code></p><ul><li>初始化git本地仓库<br><code>git init</code></li><li>安装上传插件<br><code>npm install hexo-deployer-git --save</code></li><li>RSS插件<br><code>npm install hexo-generator-feed</code></li><li>字数统计 阅读时长 插件<br><code>npm i --save hexo-wordcount</code></li><li><p>搜索插件<br><code>npm install hexo-generator-searchdb --save</code><br>如果你使用了更多的插件，在这里安装就可以了。<br>配置Git 输入你自己的邮箱地址</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name<br>git config --global user.email<br></code></pre></td></tr></table></figure></li><li><p>生成新的 public 文件夹<br><code>hexo g</code></p></li><li>开始上传 hexo博客<br><code>hexo d</code></li></ul><hr><p>date: 2019-05-31 09:41:53</p><p>采用Onedrive备份hexo博客源码</p><ul><li><p>备份文件</p><p>简单方便，只要把blog文件目录放到Onedrive中，其会自动备份的。新电脑登录Onedrive拉取blog文件。</p></li><li><p>安装环境</p><ul><li>安装node.js</li><li>安装hexo <code>npm install -g hexo</code></li><li>预览blog <code>hexo s</code></li><li>生成blog <code>hexo g</code></li><li>上传blog <code>hexo d</code></li><li>搞定收工😁</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker镜像部署Flask</title>
      <link href="/2018/06/05/Docker%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2Flask/"/>
      <url>/2018/06/05/Docker%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2Flask/</url>
      <content type="html"><![CDATA[<p>入坑了，入了Docker的坑，了解了一下docker安装，<br>照着教程学着部署了一下Flask，<br>Docker使用uwsgi+nginx+python3.6镜像部署Flask<br><a id="more"></a></p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>占坑，因为我已经装过了<br><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo apt-<span class="hljs-builtin-name">get</span> install docker<br></code></pre></td></tr></table></figure></p><p>然后查看是否安装成功<br><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">sudo docker -v</span><br></code></pre></td></tr></table></figure></p><h1 id="Docker-镜像制作"><a href="#Docker-镜像制作" class="headerlink" title="Docker 镜像制作"></a>Docker 镜像制作</h1><p>编写Dockerfile 文件<br>因为我是用的flask项目是一个简单的demo没有使用第三方库<br>也就不用安装第三方库<br><figure class="hljs highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">FROM</span> tiangolo/uwsgi-nginx-flask:python3.<span class="hljs-number">6</span><br><span class="hljs-keyword">COPY</span><span class="bash"> ./app /app</span><br></code></pre></td></tr></table></figure></p><ul><li>第一句表示，该镜像由 tiangolo/uwsgi-nginx-flask:python3.6 继承而来</li><li>第二句 拷贝项目文件到镜像中</li></ul><p>我的项目结构<br><img src="/2018/06/05/Docker镜像部署Flask/33765843.jpg" alt="项目结构" title="项目结构" style="width:197px;height:213px"></p><p>uwsgi.ini 文件：<br><figure class="hljs highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><br><span class="hljs-attr">module</span> = main<br><span class="hljs-attr">callable</span> = app<br></code></pre></td></tr></table></figure></p><p>完成后，在跟目录，即 Dockerfile 所在目录运行以下命令：<br><figure class="hljs highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-symbol">sudo</span> docker <span class="hljs-keyword">build </span>-t myimage .<br></code></pre></td></tr></table></figure></p><p>构建镜像。（注意后面的 点 ）</p><h1 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h1><p>运行以下命令启动 容器：<br><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker container <span class="hljs-built_in">run</span> <span class="hljs-comment">--name mycon --rm -d -p 9001:80 -it myimage</span><br></code></pre></td></tr></table></figure></p><p>其中 –name 表示容器名， –rm 表示停止容器后删除容器， -p 9001:80 表示将当前宿主机 9001 端口对应到容器中 80 端口， -it myimage 表示使用 myimage 镜像（即上面生成的镜像）。</p><p><a href="https://blog.csdn.net/Bear_861110453/article/details/80356153" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一键创建blog文</title>
      <link href="/2018/06/04/%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAblog%E6%96%87/"/>
      <url>/2018/06/04/%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAblog%E6%96%87/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用hexo搭建静态博客确实方便,页面托管到github pages上<br>写博客只需编写md文件即可,markdown语法简单,使用方便<br>原来也用过wordpress建博客,也挺好的,相比较下hexo比wordpress要轻便<br><a id="more"></a></p><h1 id="使用hexo优点"><a href="#使用hexo优点" class="headerlink" title="使用hexo优点"></a>使用hexo优点</h1><ul><li>熟练git使用方法</li><li>掌握markdown语法</li><li>GitHub pages托管静态页面</li><li>可以加入最大同性交友社区(误)</li></ul><hr><h1 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h1><p>hexo具体安装自己google</p><p>生成页面<br><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure></p><p>创建博文<br><figure class="hljs highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo <span class="hljs-built_in">n</span> 博文名<br></code></pre></td></tr></table></figure></p><p>发布博文<br><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure></p><h1 id="改进创建博文的不便捷"><a href="#改进创建博文的不便捷" class="headerlink" title="改进创建博文的不便捷"></a>改进创建博文的不便捷</h1><p>创建博文需要到blog根目录打开powershell 运行<br><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo n <span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure></p><p>然后需要到_posts目录下打开刚才创建的name.md 进行编写博文<br>个人觉得比较繁琐,就想着改进一下</p><h2 id="一键创建blog文原理"><a href="#一键创建blog文原理" class="headerlink" title="一键创建blog文原理"></a>一键创建blog文原理</h2><p>就是把几个命令组合到一起,很简单<br>比如我的:<br><figure class="hljs highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cd D:<span class="hljs-symbol">\p</span>ython<span class="hljs-symbol">\W</span>ilsonBlog | hexo n &#123;query&#125; | notepad++.exe D:<span class="hljs-symbol">\p</span>ython<span class="hljs-symbol">\W</span>ilsonBlog<span class="hljs-symbol">\s</span>ource<span class="hljs-symbol">\_</span>posts<span class="hljs-symbol">\&#123;</span>query&#125;.md<br></code></pre></td></tr></table></figure></p><ul><li>先cd到博客目录</li><li>运行hexo n name 创建博文</li><li>调用notepad++打开刚创建的博文<br>这样就能在任何地方打开powershell就能创建博文了<br>但是这个还不够好,因为还需要手敲命令,麻烦!<h2 id="在改进一下"><a href="#在改进一下" class="headerlink" title="在改进一下"></a>在改进一下</h2>个人非常喜欢使用listary这个快速搜索工具<br>其支持自定义命令,每次启动只需双击ctrl就可以<br>具体如下图所示:<br><img src="/2018/06/04/一键创建blog文/82574636.jpg" alt="我的自定义命令"><br>这样在任何地方只需双击ctrl键输入关键字blog 博文名 即可创建博文<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><img src="/2018/06/04/一键创建blog文/46250370.jpg" alt="gif"></li></ul>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Win10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用阿里云OSS图床</title>
      <link href="/2018/06/02/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A/"/>
      <url>/2018/06/02/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A/</url>
      <content type="html"><![CDATA[<p>本Blog中所有文章图片都采用阿里云OSS对象存储作为图床<br>下面简单说一下如何使用oss作为图床</p><a id="more"></a><hr><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol><li><a href="https://shimo.im/docs/vbmdsh2LSwoo628P/" target="_blank" rel="noopener">开通阿里云OSS对象储存</a></li><li>使用<a href="https://jiantuku.com" target="_blank" rel="noopener">极简图床</a></li><li>下载谷歌插件<a href="https://chrome.google.com/webstore/detail/%E6%9E%81%E7%AE%80%E5%9B%BE%E5%BA%8A/heebflcbemenefckkgfnnklbhdbdkagg" target="_blank" rel="noopener">极简图床</a>方便采集上传图片</li><li>获取图片链接插入博客中即可</li></ol><p><img src="https://wevsmy.github.io/favicons/android-chrome-96x96.png" alt="就是这么简单，讲完了" title="end" style="width:96px;height:96px"></p><hr><p>date: 2019-01-17 13:41:57</p><p>换成静态资源了，怕图床挂了 🌚</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于本Blog的评论系统</title>
      <link href="/2018/06/02/%E5%85%B3%E4%BA%8E%E6%9C%ACBlog%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/06/02/%E5%85%B3%E4%BA%8E%E6%9C%ACBlog%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>本博客采用的是Disqus评论系统，国内加载不出来<br><a id="more"></a></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>评论系统Disqus需使用google账号登陆，并FQ才能评论，<br>哈哈，并不是没个人都能评论的！！！<br>(整的好像有人会评论似的😂)<br>换句话说，留下的评论的都会FQ，开门社区送温暖！！！</p>]]></content>
      
      
        <tags>
            
            <tag> Disqus </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>test</title>
      <link href="/2018/06/02/test/"/>
      <url>/2018/06/02/test/</url>
      <content type="html"><![CDATA[<p>这是一篇测试文章，用于测试Hexo搭建的github静态网站<br><a id="more"></a></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>添加分类</li><li>添加标签<h1 id="hexo添加分类and标签的方法"><a href="#hexo添加分类and标签的方法" class="headerlink" title="hexo添加分类and标签的方法"></a>hexo添加分类and标签的方法</h1>只需要在文章分类中加入以下代码即可：<figure class="hljs highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2018</span><span class="hljs-bullet">-06</span><span class="hljs-bullet">-02</span> <span class="hljs-number">20</span><span class="hljs-string">:16:09</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">计算机</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Linux</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Docker</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Python</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Docker</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">HTML</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li></ul><p>上述代码即是本片文章的分类and标签</p><h1 id="测试插入图片"><a href="#测试插入图片" class="headerlink" title="测试插入图片"></a>测试插入图片</h1><ol><li>markdown语法不支持指定宽高<br>代码<figure class="hljs highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">![<span class="hljs-string">Dog</span>](<span class="hljs-link">test/63035737.jpg </span>)<br></code></pre></td></tr></table></figure></li></ol><p><img src="/2018/06/02/test/63035737.jpg" alt="Dog"></p><ol start="2"><li>使用img标签指定宽高<figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">"test/63035737.jpg"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">"Dog"</span> <span class="hljs-attribute">title</span>=<span class="hljs-string">"神烦狗"</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">"width:100px;height:100px"</span>&gt;<br></code></pre></td></tr></table></figure></li></ol><p><img src="/2018/06/02/test/63035737.jpg" alt="Dog" title="神烦狗" style="width:100px;height:100px"></p>]]></content>
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Python </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django基础01</title>
      <link href="/2018/03/22/cnblog_8621513/"/>
      <url>/2018/03/22/cnblog_8621513/</url>
      <content type="html"><![CDATA[<h1 id="这是👉Django基础01👈的摘要"><a href="#这是👉Django基础01👈的摘要" class="headerlink" title="这是👉Django基础01👈的摘要"></a><a href="/2018/03/22/cnblog_8621513/">这是👉Django基础01👈的摘要</a></h1><a id="more"></a><h1 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h1><p>我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端。 这样我们就可以自己实现Web框架了。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>   sk = socket.socket()<br>   sk.bind((<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">80</span>))<br>   sk.listen(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:<br>conn, addr = sk.accept()<br>data = conn.recv(<span class="hljs-number">8096</span>)<br>conn.send(<span class="hljs-string">b"OK"</span>)<br>conn.close()<br></code></pre></td></tr></table></figure><p>可以说Web服务本质上都是在这十几行代码基础上扩展出来的。这段代码就是它们的祖宗。</p><p>用户的浏览器一输入网址，会给服务端发送数据，那浏览器会发送什么数据？怎么发？这个谁来定？ 你这个网站是这个规定，他那个网站按照他那个规定，这互联网还能玩么？</p><p>所以，必须有一个统一的规则，让大家发送消息、接收消息的时候有个格式依据，不能随便写。</p><p>这个规则就是HTTP协议，以后浏览器发送请求信息也好，服务器回复响应信息也罢，都要按照这个规则来。</p><p>HTTP协议主要规定了客户端和服务器之间的通信格式，那HTTP协议是怎么规定消息格式的呢？</p><p>让我们首先看下我们在服务端接收到的消息是什么。</p><p>然后再看下我们浏览器收到的响应信息是什么。</p><p>响应头在浏览器的network窗口可以看到，我们看到的HTML页面内容就是响应体。本质上还是字符串，因为浏览器认识HTML，所以才会渲染出页面。</p><p><a href="http://www.cnblogs.com/liwenzhou/articles/8620663.html" target="_blank" rel="noopener">HTTP协议介绍</a></p><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。 HTTP响应的Header中有一个<br><code>Content-Type</code>表明响应的内容格式。如 <code>text/html</code>表示HTML网页。</p><p>HTTP GET请求的格式：</p><p>​<br>​    GET /path HTTP/1.1<br>​    header1:v1\r\n<br>​    header2:v2\r\n</p><p>使用 <code>\r\n</code>分隔多个header</p><p>HTTP POST请求格式：</p><p>​<br>​    POST /path HTTP/1.1<br>​    header1:v1\r\n<br>​    header2:v2\r\n<br>​    \r\n\r\n<br>​    请求体…</p><p>当遇到连续两个 <code>\r\n\r\n</code>时，表示Header部分结束了，后面的数据是Body。</p><p>HTTP响应的格式：</p><p>​<br>​    200 OK<br>​    Header1:v1\r\n<br>​    Header2:v2\r\n<br>​    \r\n\r\n<br>​    响应体…</p><p>让我们的Web框架在给客户端回复响应的时候按照HTTP协议的规则加上响应头，这样我们就实现了一个正经的Web框架了。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>sock.bind((<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">8000</span>))<br>sock.listen(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:<br>conn, addr = sock.accept()<br>data = conn.recv(<span class="hljs-number">8096</span>)<br>conn.send(<span class="hljs-string">b"HTTP/1.1 200 OK\r\n\r\n"</span>)<br>conn.send(<span class="hljs-string">b"OK"</span>)<br>conn.close()<br></code></pre></td></tr></table></figure><p>上述通过socket来实现了其本质。</p><p>对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。</p><p>服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。</p><p>应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py<br>等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。</p><p>这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。</p><p>这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。</p><p>WSGI（Web Server Gateway<br>Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。</p><p>常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。</p><p>​<br>​    from wsgiref.simple_server import make_server</p><p>​<br>​    def run_server(environ, start_response):<br>​        start_response(‘200 OK’, [(‘Content-Type’, ‘text/html;charset=utf8’)])  # 设置HTTP响应的状态码和头信息<br>​        return [bytes(“</p><h1>Hello world!</h1>“, encoding=”utf8”),]<p></p><p>​<br>​    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>​        httpd = make_server(‘’, 8000, run_server)<br>​        print(“Serving HTTP on port 8000…”)<br>​        httpd.serve_forever()</p><p>这样就结束了吗？ 如何让我们的Web服务根据用户请求的URL不同而返回不同的内容呢？</p><p>小事一桩，我们可以从请求相关数据里面拿到请求的URL，然后做一个判断。</p><p>​<br>​    from wsgiref.simple_server import make_server</p><p>​<br>​    def run_server(environ, start_response):<br>​        start_response(‘200 OK’, [(‘Content-Type’, ‘text/html;charset=utf8’), ])  # 设置HTTP响应的状态码和头信息<br>​        url = environ[‘PATH_INFO’]  # 取到用户输入的url<br>​        if url == “/index/“:<br>​            return [bytes(“</p><h1>这是index页面</h1>“, encoding=”utf8”), ]<br>​        elif url == “/home/“:<br>​            return [bytes(“<h1>这是home页面</h1>“, encoding=”utf8”), ]<br>​        else:<br>​            return [bytes(“404没有该页面”, encoding=”utf8”), ]<p></p><p>​<br>​    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>​        httpd = make_server(‘’, 8000, run_server)<br>​        print(“Serving HTTP on port 8000…”)<br>​        httpd.serve_forever()</p><p>解决了不同URL返回不同内容的需求。 但是问题又来了，如果有很多很多页面怎么办？难道要挨个判断？ 当然不用，我们有更聪明的办法。</p><p>​<br>​    from wsgiref.simple_server import make_server</p><p>​<br>​    def index():<br>​        return [bytes(“</p><h1>这是index页面</h1>“, encoding=”utf8”), ]<p></p><p>​<br>​    def home():<br>​        return [bytes(“</p><h1>这是home页面</h1>“, encoding=”utf8”), ]<p></p><p>​<br>​    # 定义一个url和函数的对应关系<br>​    URL_LIST = [<br>​        (“/index/“, index),<br>​        (“/home/“, home),<br>​    ]</p><p>​<br>​    def run_server(environ, start_response):<br>​        start_response(‘200 OK’, [(‘Content-Type’, ‘text/html;charset=utf8’), ])  # 设置HTTP响应的状态码和头信息<br>​        url = environ[‘PATH_INFO’]  # 取到用户输入的url<br>​        func = None  # 将要执行的函数<br>​        for i in URL_LIST:<br>​            if i[0] == url:<br>​                func = i[1]  # 去之前定义好的url列表里找url应该执行的函数<br>​                break<br>​        if func:  # 如果能找到要执行的函数<br>​            return func()  # 返回函数的执行结果<br>​        else:<br>​            return [bytes(“404没有该页面”, encoding=”utf8”), ]</p><p>​<br>​    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>​        httpd = make_server(‘’, 8000, run_server)<br>​        print(“Serving HTTP on port 8000…”)<br>​        httpd.serve_forever()</p><p>完美解决了不同URL返回不同内容的问题。 但是我不想仅仅返回几个字符串，我想给浏览器返回完整的HTML内容，这又该怎么办呢？</p><p>没问题，不管是什么内容，最后都是转换成字节数据发送出去的。 我可以打开HTML文件，读取出它内部的二进制数据，然后发送给浏览器。</p><p>​<br>​    from wsgiref.simple_server import make_server</p><p>​<br>​    def index():<br>​        with open(“index.html”, “rb”) as f:<br>​            data = f.read()<br>​        return [data, ]</p><p>​<br>​    def home():<br>​        with open(“home.html”, “rb”) as f:<br>​            data = f.read()<br>​        return [data, ]</p><p>​<br>​    # 定义一个url和函数的对应关系<br>​    URL_LIST = [<br>​        (“/index/“, index),<br>​        (“/home/“, home),<br>​    ]</p><p>​<br>​    def run_server(environ, start_response):<br>​        start_response(‘200 OK’, [(‘Content-Type’, ‘text/html;charset=utf8’), ])  # 设置HTTP响应的状态码和头信息<br>​        url = environ[‘PATH_INFO’]  # 取到用户输入的url<br>​        func = None  # 将要执行的函数<br>​        for i in URL_LIST:<br>​            if i[0] == url:<br>​                func = i[1]  # 去之前定义好的url列表里找url应该执行的函数<br>​                break<br>​        if func:  # 如果能找到要执行的函数<br>​            return func()  # 返回函数的执行结果<br>​        else:<br>​            return [bytes(“404没有该页面”, encoding=”utf8”), ]</p><p>​<br>​    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>​        httpd = make_server(‘’, 8000, run_server)<br>​        print(“Serving HTTP on port 8000…”)<br>​        httpd.serve_forever()</p><p>这网页能够显示出来了，但是都是静态的啊。页面的内容都不会变化的，我想要的是动态网站。</p><p>没问题，我也有办法解决。我选择使用字符串替换来实现这个需求。</p><p>​<br>​    from wsgiref.simple_server import make_server</p><p>​<br>​    def index():<br>​        with open(“index.html”, “rb”) as f:<br>​            data = f.read()<br>​        import time<br>​        time_str = str(time.time())<br>​        data_str = str(data, encoding=”utf8”)<br>​        data_str = data_str.replace(“@@a@@”, time_str)<br>​        return [bytes(data_str, encoding=”utf8”), ]</p><p>​<br>​    def home():<br>​        with open(“home.html”, “rb”) as f:<br>​            data = f.read()<br>​        return [data, ]</p><p>​<br>​    # 定义一个url和函数的对应关系<br>​    URL_LIST = [<br>​        (“/index/“, index),<br>​        (“/home/“, home),<br>​    ]</p><p>​<br>​    def run_server(environ, start_response):<br>​        start_response(‘200 OK’, [(‘Content-Type’, ‘text/html;charset=utf8’), ])  # 设置HTTP响应的状态码和头信息<br>​        url = environ[‘PATH_INFO’]  # 取到用户输入的url<br>​        func = None  # 将要执行的函数<br>​        for i in URL_LIST:<br>​            if i[0] == url:<br>​                func = i[1]  # 去之前定义好的url列表里找url应该执行的函数<br>​                break<br>​        if func:  # 如果能找到要执行的函数<br>​            return func()  # 返回函数的执行结果<br>​        else:<br>​            return [bytes(“404没有该页面”, encoding=”utf8”), ]</p><p>​<br>​    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>​        httpd = make_server(‘’, 8000, run_server)<br>​        print(“Serving HTTP on port 8000…”)<br>​        httpd.serve_forever()</p><p>这是一个简单的动态，我完全可以从数据库中查询数据，然后去替换我html中的对应内容，然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。<br>本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： <code>jinja2</code></p><p>下载jinja2:</p><p>​<br>​    pip install jinja2</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><p>​<br>​    &lt;!DOCTYPE html&gt;<br>​    <html lang="zh-CN"><br>​    <head><br>​      <meta charset="UTF-8"><br>​      <meta http-equiv="x-ua-compatible" content="IE=edge"><br>​      <meta name="viewport" content="width=device-width, initial-scale=1"><br>​      <title>Title</title><br>​    </head><br>​    <body><br>​        <h1>姓名：</h1><br>​        <h1>爱好：</h1><br>​        <ul><br>​            <br>​        </ul><br>​    </body><br>​    </html></p><p>index2.html文件</p><p>使用jinja2渲染index2.html文件：</p><p>​<br>​    from wsgiref.simple_server import make_server<br>​    from jinja2 import Template</p><p>​<br>​    def index():<br>​        with open(“index2.html”, “r”) as f:<br>​            data = f.read()<br>​        template = Template(data)  # 生成模板文件<br>​        ret = template.render({“name”: “Alex”, “hobby_list”: [“烫头”, “泡吧”]})  # 把数据填充到模板里面<br>​        return [bytes(ret, encoding=”utf8”), ]</p><p>​<br>​    def home():<br>​        with open(“home.html”, “rb”) as f:<br>​            data = f.read()<br>​        return [data, ]</p><p>​<br>​    # 定义一个url和函数的对应关系<br>​    URL_LIST = [<br>​        (“/index/“, index),<br>​        (“/home/“, home),<br>​    ]</p><p>​<br>​    def run_server(environ, start_response):<br>​        start_response(‘200 OK’, [(‘Content-Type’, ‘text/html;charset=utf8’), ])  # 设置HTTP响应的状态码和头信息<br>​        url = environ[‘PATH_INFO’]  # 取到用户输入的url<br>​        func = None  # 将要执行的函数<br>​        for i in URL_LIST:<br>​            if i[0] == url:<br>​                func = i[1]  # 去之前定义好的url列表里找url应该执行的函数<br>​                break<br>​        if func:  # 如果能找到要执行的函数<br>​            return func()  # 返回函数的执行结果<br>​        else:<br>​            return [bytes(“404没有该页面”, encoding=”utf8”), ]</p><p>​<br>​    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>​        httpd = make_server(‘’, 8000, run_server)<br>​        print(“Serving HTTP on port 8000…”)<br>​        httpd.serve_forever()</p><p>现在的数据是我们自己手写的，那可不可以从数据库中查询数据，来填充页面呢？</p><p>使用pymysql连接数据库：</p><p>​<br>​    conn = pymysql.connect(host=”127.0.0.1”, port=3306, user=”root”, passwd=”xxx”, db=”xxx”, charset=”utf8”)<br>​    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)<br>​    cursor.execute(“select name, age, department_id from userinfo”)<br>​    user_list = cursor.fetchall()<br>​    cursor.close()<br>​    conn.close()</p><p>创建一个测试的user表：</p><p>​<br>​    CREATE TABLE user(<br>​      id int auto_increment PRIMARY KEY,<br>​      name CHAR(10) NOT NULL,<br>​      hobby CHAR(20) NOT NULL<br>​    )engine=innodb DEFAULT charset=UTF8;</p><p>模板的原理就是字符串替换，我们只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容。</p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p><a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">Django官网下载页面</a></p><h3 id="安装（安装最新LTS版）："><a href="#安装（安装最新LTS版）：" class="headerlink" title="安装（安装最新LTS版）："></a>安装（安装最新LTS版）：</h3><p>​<br>​    pip3 install django==1.11.9</p><h3 id="创建一个django项目："><a href="#创建一个django项目：" class="headerlink" title="创建一个django项目："></a>创建一个django项目：</h3><p>下面的命令创建了一个名为”mysite”的Django 项目：</p><p>​<br>​    django-admin startproject mysite</p><h3 id="目录介绍："><a href="#目录介绍：" class="headerlink" title="目录介绍："></a>目录介绍：</h3><p>​<br>​    mysite/<br>​    ├── manage.py  # 管理文件<br>​    └── mysite  # 项目目录<br>​        ├── <strong>init</strong>.py<br>​        ├── settings.py  # 配置<br>​        ├── urls.py  # 路由 –&gt; URL和函数的对应关系<br>​        └── wsgi.py  # runserver命令就使用wsgiref模块做简单的web server</p><h3 id="运行Django项目："><a href="#运行Django项目：" class="headerlink" title="运行Django项目："></a>运行Django项目：</h3><p>​<br>​    python manage.py runserver 127.0.0.1:8000</p><h3 id="模板文件配置："><a href="#模板文件配置：" class="headerlink" title="模板文件配置："></a>模板文件配置：</h3><p>​<br>​    TEMPLATES = [<br>​        {<br>​            ‘BACKEND’: ‘django.template.backends.django.DjangoTemplates’,<br>​            ‘DIRS’: [os.path.join(BASE_DIR, “template”)],  # template文件夹位置<br>​            ‘APP_DIRS’: True,<br>​            ‘OPTIONS’: {<br>​                ‘context_processors’: [<br>​                    ‘django.template.context_processors.debug’,<br>​                    ‘django.template.context_processors.request’,<br>​                    ‘django.contrib.auth.context_processors.auth’,<br>​                    ‘django.contrib.messages.context_processors.messages’,<br>​                ],<br>​            },<br>​        },<br>​    ]</p><h3 id="静态文件配置："><a href="#静态文件配置：" class="headerlink" title="静态文件配置："></a>静态文件配置：</h3><p>​<br>​    STATIC_URL = ‘/static/‘  # HTML中使用的静态文件夹前缀<br>​    STATICFILES_DIRS = [<br>​        os.path.join(BASE_DIR, “static”),  # 静态文件存放位置<br>​    ]</p><p><strong>看不明白？有图有真相：</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/867021/201801/867021-20180110190001816-1349372864.png" alt=""></strong></p><p><strong>刚开始学习时可在配置文件中暂时禁用csrf中间件，方便表单提交测试。</strong></p><p>​<br>​    MIDDLEWARE = [<br>​         ‘django.middleware.security.SecurityMiddleware’,<br>​        ‘django.contrib.sessions.middleware.SessionMiddleware’,<br>​        ‘django.middleware.common.CommonMiddleware’,<br>​        # ‘django.middleware.csrf.CsrfViewMiddleware’,<br>​        ‘django.contrib.auth.middleware.AuthenticationMiddleware’,<br>​        ‘django.contrib.messages.middleware.MessageMiddleware’,<br>​        ‘django.middleware.clickjacking.XFrameOptionsMiddleware’,<br>​    ]</p><h2 id="Django基础必备三件套："><a href="#Django基础必备三件套：" class="headerlink" title="Django基础必备三件套："></a>Django基础必备三件套：</h2><p>​<br>​    from django.shortcuts import HttpResponse, render, redirect</p><h3 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h3><p>内部传入一个字符串参数，返回给浏览器。</p><p>例如：</p><p>​<br>​    def index(request):<br>​        # 业务逻辑代码<br>​        return HttpResponse(“OK”)</p><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>除request参数外还接受一个待渲染的模板文件和一个保存具体数据的字典参数。</p><p>将数据填充进模板文件，最后把结果返回给浏览器。（类似于我们上面用到的jinja2）</p><p>例如：</p><p>​<br>​    def index(request):<br>​        # 业务逻辑代码<br>​        return render(request, “index.html”, {“name”: “alex”, “hobby”: [“烫头”, “泡吧”]})</p><h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><p>接受一个URL参数，表示跳转到指定的URL。</p><p>例如：</p><p>​<br>​    def index(request):<br>​        # 业务逻辑代码<br>​        return redirect(“/home/“)</p><h2 id="课后练习："><a href="#课后练习：" class="headerlink" title="课后练习："></a>课后练习：</h2><p>Django版登录</p><h2 id="启动Django报错："><a href="#启动Django报错：" class="headerlink" title="启动Django报错："></a>启动Django报错：</h2><p>Django 启动时报错 UnicodeEncodeError …</p><p>报这个错误通常是因为计算机名为中文，改成英文的计算机名重启下电脑就可以了。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python连接MySQL数据库之pymysql模块使用</title>
      <link href="/2018/03/21/cnblog_8616189/"/>
      <url>/2018/03/21/cnblog_8616189/</url>
      <content type="html"><![CDATA[<h1 id="这是👉Python连接MySQL数据库之pymysql模块使用👈的摘要"><a href="#这是👉Python连接MySQL数据库之pymysql模块使用👈的摘要" class="headerlink" title="这是👉Python连接MySQL数据库之pymysql模块使用👈的摘要"></a><a href="/2018/03/21/cnblog_8616189/">这是👉Python连接MySQL数据库之pymysql模块使用👈的摘要</a></h1><a id="more"></a><h1 id="Python3连接MySQL"><a href="#Python3连接MySQL" class="headerlink" title="Python3连接MySQL"></a>Python3连接MySQL</h1><p>本文介绍Python3连接MySQL的第三方库–PyMySQL的基本使用。</p><h2 id="PyMySQL介绍"><a href="#PyMySQL介绍" class="headerlink" title="PyMySQL介绍"></a>PyMySQL介绍</h2><p>PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。</p><p>Django中也可以使用PyMySQL连接MySQL数据库。</p><h2 id="PyMySQL安装"><a href="#PyMySQL安装" class="headerlink" title="PyMySQL安装"></a>PyMySQL安装</h2><pre><code>pip install pymysql</code></pre><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在进行本文以下内容之前需要注意：</p><ul><li>你有一个MySQL数据库，并且已经启动。</li><li>你有可以连接该数据库的用户名和密码</li><li>你有一个有权限操作的database</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 定义要执行的SQL语句sql = &quot;&quot;&quot;CREATE TABLE USER1 (id INT auto_increment PRIMARY KEY ,name CHAR(10) NOT NULL UNIQUE,age TINYINT NOT NULL)ENGINE=innodb DEFAULT CHARSET=utf8;&quot;&quot;&quot;# 执行SQL语句cursor.execute(sql)# 关闭光标对象cursor.close()# 关闭数据库连接conn.close()</code></pre><p>返回字典格式数据：</p><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句并且将结果作为字典返回的游标cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)# 定义要执行的SQL语句sql = &quot;&quot;&quot;CREATE TABLE USER1 (id INT auto_increment PRIMARY KEY ,name CHAR(10) NOT NULL UNIQUE,age TINYINT NOT NULL)ENGINE=innodb DEFAULT CHARSET=utf8;&quot;&quot;&quot;# 执行SQL语句cursor.execute(sql)# 关闭光标对象cursor.close()# 关闭数据库连接conn.close()</code></pre><p>注意：</p><p>charset=”utf8”，编码不要写成”utf-8”</p><h2 id="增删改查操作"><a href="#增删改查操作" class="headerlink" title="增删改查操作"></a>增删改查操作</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;username = &quot;Alex&quot;age = 18# 执行SQL语句cursor.execute(sql, [username, age])# 提交事务conn.commit()cursor.close()conn.close()</code></pre><p><strong>插入数据失败回滚</strong></p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;username = &quot;Alex&quot;age = 18try:    # 执行SQL语句    cursor.execute(sql, [username, age])    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><p><strong>获取插入数据的ID(关联操作时会用到)</strong></p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;username = &quot;Alex&quot;age = 18try:    # 执行SQL语句    cursor.execute(sql, [username, age])    # 提交事务    conn.commit()    # 提交之后，获取刚插入的数据的ID    last_id = cursor.lastrowidexcept Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><p><strong>批量执行</strong></p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;INSERT INTO USER1(name, age) VALUES (%s, %s);&quot;data = [(&quot;Alex&quot;, 18), (&quot;Egon&quot;, 20), (&quot;Yuan&quot;, 21)]try:    # 批量执行多条插入SQL语句    cursor.executemany(sql, data)    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()sql = &quot;DELETE FROM USER1 WHERE id=%s;&quot;try:    cursor.execute(sql, [4])    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code># 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 修改数据的SQL语句sql = &quot;UPDATE USER1 SET age=%s WHERE name=%s;&quot;username = &quot;Alex&quot;age = 80try:    # 执行SQL语句    cursor.execute(sql, [age, username])    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><strong>查询单条数据</strong></p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 查询数据的SQL语句sql = &quot;SELECT id,name,age from USER1 WHERE id=1;&quot;# 执行SQL语句cursor.execute(sql)# 获取单条查询数据ret = cursor.fetchone()cursor.close()conn.close()# 打印下查询结果print(ret)</code></pre><p><strong>查询多条数据</strong></p><pre><code> # 导入pymysql模块import pymysql# 连接databaseconn = pymysql.connect(host=&quot;你的数据库地址&quot;, user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)# 得到一个可以执行SQL语句的光标对象cursor = conn.cursor()# 查询数据的SQL语句sql = &quot;SELECT id,name,age from USER1;&quot;# 执行SQL语句cursor.execute(sql)# 获取多条查询数据ret = cursor.fetchall()cursor.close()conn.close()# 打印下查询结果print(ret)</code></pre><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><pre><code># 可以获取指定数量的数据cursor.fetchmany(3)# 光标按绝对位置移动1cursor.scroll(1, mode=&quot;absolute&quot;)# 光标按照相对位置(当前位置)移动1cursor.scroll(1, mode=&quot;relative&quot;)</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown 语法</title>
      <link href="/2018/03/14/cnblog_8565323/"/>
      <url>/2018/03/14/cnblog_8565323/</url>
      <content type="html"><![CDATA[<h1 id="这是👉Markdown-语法👈的摘要"><a href="#这是👉Markdown-语法👈的摘要" class="headerlink" title="这是👉Markdown 语法👈的摘要"></a><a href="/2018/03/14/cnblog_8565323/">这是👉Markdown 语法👈的摘要</a></h1><a id="more"></a><hr><h1 id="Markdown-语法说明-简体中文版"><a href="#Markdown-语法说明-简体中文版" class="headerlink" title="Markdown 语法说明 (简体中文版)"></a>Markdown 语法说明 (简体中文版)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p><p>可读性，无论如何，都是最重要的。一份使用 Markdown格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML格式的影响，包括<a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener">Grutatext</a>和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p><p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像<em>强调</em>。Markdown的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p><h3 id="兼容-HTML"><a href="#兼容-HTML" class="headerlink" title="兼容 HTML"></a>兼容 HTML</h3><p>Markdown 语法的目标是：成为一种适用于网络的 _书写_ 语言。</p><p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种 _书写_ 的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML或是Markdown；只要直接加标签就可以了。</p><p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code>等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p><p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p><p>​    这是一个普通段落。</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​    </p><pre><code>这是另一个普通段落。</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown样式的<code>*强调*</code>会没有效果。</p><p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown<br>的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的<code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p><p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p><h3 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。<code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code>字符也要转换。比如你要链接到：<code>http://images.google.com/images?num=30&amp;q=larry+bird</code>你必须要把网址转换写为：<code>http://images.google.com/images?num=30&amp;amp;q=larry+bird</code>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p><p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成<br><code>&amp;amp;</code>。</p><p>所以你如果要在文档中插入一个版权符号 <code>(C)</code>，你可以这样写：<code>&amp;copy;</code>Markdown 会保留它不动。而若你写<code>AT&amp;T</code>Markdown 就会将它转为：<code>AT&amp;amp;T</code></p><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那Markdown 也不会对它做任何转换，但是如果你写：<code>4&lt;5</code>Markdown 将会把它转换为：<code>4&amp;lt;5</code></p><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在HTML 文件里面写出 HTML code。）</p><hr><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>一个 Markdown段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p><p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br/&gt;</code> 标签。</p><p>如果你确实想要依赖 Markdown 来插入 <code>&lt;br/&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p><p>的确，需要多费点事（多加空格）来产生 <code>&lt;br/&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br/&gt;</code>」的方法在 Markdown 中并不适合，Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题的语法，类<a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 和类<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a> 形式。</p><p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><p>​    This is an H1<br>​    =============<br>​<br>​    This is an H2<br>​    ————-</p><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p><p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p><p>​    # 这是 H1<br>​<br>​    ## 这是 H2<br>​<br>​    ###### 这是 H6</p><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code><br>数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p><p>​    # 这是 H1 #<br>​<br>​    ## 这是 H2 ##<br>​<br>​    ### 这是 H3 ######</p><h3 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h3><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在<br>Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p><p>​    &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>​    &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>​    &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.<br>​    &gt;<br>​    &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>​    &gt; id sem consectetuer libero luctus adipiscing.</p><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p><p>​    &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>​    consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>​    Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.<br>​<br>​    &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>​    id sem consectetuer libero luctus adipiscing.</p><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p><p>​    &gt; This is the first level of quoting.<br>​    &gt;<br>​    &gt; &gt; This is nested blockquote.<br>​    &gt;<br>​    &gt; Back to the first level.</p><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><p>​    &gt; ## 这是一个标题。<br>​    &gt;<br>​    &gt; 1.   这是第一行列表项。<br>​    &gt; 2.   这是第二行列表项。<br>​    &gt;<br>​    &gt; 给出一些例子代码：<br>​    &gt;<br>​    &gt;     return shell_exec(“echo $input | $markdown_script”);</p><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择 <em>增加引用阶层</em> 。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号、加号或是减号作为列表标记：</p><p>​    <em>   Red<br>​    </em>   Green<br>​    *   Blue</p><p>等同于：</p><p>​    +   Red<br>​    +   Green<br>​    +   Blue</p><p>也等同于：</p><p>​    -   Red<br>​    -   Green<br>​    -   Blue</p><p>有序列表则使用数字接着一个英文句点：</p><p>​    1.  Bird<br>​    2.  McHale<br>​    3.  Parish</p><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p><p>​    <ol><br>​    <li>Bird</li><br>​    <li>McHale</li><br>​    <li>Parish</li><br>​    </ol></p><p>如果你的列表标记写成：</p><p>​    1.  Bird<br>​    1.  McHale<br>​    1.  Parish</p><p>或甚至是：</p><p>​    3. Bird<br>​    1. McHale<br>​    8. Parish</p><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p><p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p><p>​    <em>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>​        Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>​        viverra nec, fringilla in, laoreet vitae, risus.<br>​    </em>   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>​        Suspendisse id sem consectetuer libero luctus adipiscing.</p><p>但是如果你懒，那也行：</p><p>​    <em>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>​    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>​    viverra nec, fringilla in, laoreet vitae, risus.<br>​    </em>   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>​    Suspendisse id sem consectetuer libero luctus adipiscing.</p><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code> 标签包起来，举例来说：</p><p>​    <em>   Bird<br>​    </em>   Magic</p><p>会被转换为：</p><p>​    <ul><br>​    <li>Bird</li><br>​    <li>Magic</li><br>​    </ul></p><p>但是这个：</p><p>​    <em>   Bird<br>​<br>​    </em>   Magic</p><p>会被转换为：</p><p>​    <ul><br>​    <li><p>Bird</p></li><br>​    <li><p>Magic</p></li><br>​    </ul></p><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p><p>​    1.  This is a list item with two paragraphs. Lorem ipsum dolor<br>​        sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>​        mi posuere lectus.<br>​<br>​        Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>​        vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>​        sit amet velit.<br>​<br>​    2.  Suspendisse id sem consectetuer libero luctus adipiscing.</p><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><p>​    <em>   This is a list item with two paragraphs.<br>​<br>​        This is the second paragraph in the list item. You’re<br>​    only required to indent the first line. Lorem ipsum dolor<br>​    sit amet, consectetuer adipiscing elit.<br>​<br>​    </em>   Another item in the same list.</p><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p><p>​    *   A list item with a blockquote:<br>​<br>​        &gt; This is a blockquote<br>​        &gt; inside a list item.</p><p>如果要放代码区块的话，该区块就需要缩进 _两次_ ，也就是 8 个空格或是 2 个制表符：</p><p>​    *   一列表项包含一个列表区块：<br>​<br>​            &lt;代码写在这&gt;</p><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p><p>​    1986. What a great season.</p><p>换句话说，也就是在行首出现 数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。</p><p>​    1986. What a great season.</p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown<br>会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p><p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p><p>​    这是一个普通段落：<br>​<br>​        这是一个代码区块。</p><p>Markdown 会转换成：</p><p>​    </p><p>这是一个普通段落：</p><br>​<br>​    <pre><code>这是一个代码区块。</code></pre><p></p><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p><p>​    Here is an example of AppleScript:<br>​<br>​        tell application “Foo”<br>​            beep<br>​        end tell</p><p>会被转换为：</p><p>​    </p><p>Here is an example of AppleScript:</p><br>​<br>​    <pre><code>tell application “Foo”beepend tell</code></pre><p></p><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML原始码，只需要复制贴上，再加上缩进就可以了，剩下的Markdown 都会帮你处理，例如：</p><p>​        <div class="footer"><br>​            &copy; 2004 Foo Corporation<br>​        </div></p><p>会被转换为：</p><p>​    <pre><code>&lt;div class=”footer”&gt;<br>​        &amp;copy; 2004 Foo Corporation<br>​    &lt;/div&gt;<br>​    </code></pre></p><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown语法相关的文件。</p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><p>​    <em> </em> <em><br>​<br>​    **</em><br>​<br>​    <strong>*</strong><br>​<br>​    - - -<br>​<br>​    —————————————</p><hr><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支持两种形式的链接语法：行内式和参考式两种形式。</p><p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把title 文字包起来即可，例如：</p><p>​    This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a> inline link.<br>​<br>​    <a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no title attribute.</p><p>会产生：</p><p>​    </p><p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener"><br>​    an example</a> inline link.</p><br>​<br>​    <p><a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no<br>​    title attribute.</p><p></p><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p><p>​    See my <a href="/about/">About</a> page for details.</p><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><p>​    This is [an example][id] reference-style link.</p><p>你也可以选择性地在两个方括号中间加上一个空格：</p><p>​    This is [an example] [id] reference-style link.</p><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p><p>​    [id]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>  “Optional Title Here”</p><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同：</p><p>​    [foo]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>  “Optional Title Here”<br>​    [foo]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>  ‘Optional Title Here’<br>​    [foo]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>  (Optional Title Here)</p><p><strong>请注意：</strong> 有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p><p>链接网址也可以用尖括号包起来：</p><p>​    [id]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>  “Optional Title Here”</p><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p><p>​    [id]: <a href="http://example.com/longish/path/to/resource/here" target="_blank" rel="noopener">http://example.com/longish/path/to/resource/here</a><br>​        “Optional Title Here”</p><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p><p>链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：</p><p>​    [link text][a]<br>​    [link text][A]</p><p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让<br>“Google” 链接到 google.com，你可以简化成：</p><p>​    [Google][]</p><p>然后定义链接内容：</p><p>​    [Google]: <a href="http://google.com/" target="_blank" rel="noopener">http://google.com/</a></p><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p><p>​    Visit [Daring Fireball][] for more information.</p><p>然后接着定义链接：</p><p>​    [Daring Fireball]: <a href="http://daringfireball.net/" target="_blank" rel="noopener">http://daringfireball.net/</a></p><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>下面是一个参考式链接的范例：</p><p>​    I get 10 times more traffic from [Google] [1] than from<br>​    [Yahoo] [2] or [MSN] [3].<br>​<br>​      [1]: <a href="http://google.com/" target="_blank" rel="noopener">http://google.com/</a>        “Google”<br>​      [2]: <a href="http://search.yahoo.com/" target="_blank" rel="noopener">http://search.yahoo.com/</a>  “Yahoo Search”<br>​      [3]: <a href="http://search.msn.com/" target="_blank" rel="noopener">http://search.msn.com/</a>    “MSN Search”</p><p>如果改成用链接名称的方式写：</p><p>​    I get 10 times more traffic from [Google][] than from<br>​    [Yahoo][] or [MSN][].<br>​<br>​      [google]: <a href="http://google.com/" target="_blank" rel="noopener">http://google.com/</a>        “Google”<br>​      [yahoo]:  <a href="http://search.yahoo.com/" target="_blank" rel="noopener">http://search.yahoo.com/</a>  “Yahoo Search”<br>​      [msn]:    <a href="http://search.msn.com/" target="_blank" rel="noopener">http://search.msn.com/</a>    “MSN Search”</p><p>上面两种写法都会产生下面的 HTML。</p><p>​    </p><p>I get 10 times more traffic from <a href="http://google.com/" ​="" title="Google" target="_blank" rel="noopener">Google</a> than from<br>​    <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a><br>​    or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><p></p><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p><p>​    I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a><br>​    than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or<br>​    <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p><p>使用 Markdown的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个<code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p><p>​    <em>single asterisks</em><br>​<br>​    <em>single underscores</em><br>​<br>​    <strong>double asterisks</strong><br>​<br>​    <strong>double underscores</strong></p><p>会转成：</p><p>​    <em>single asterisks</em><br>​<br>​    <em>single underscores</em><br>​<br>​    <strong>double asterisks</strong><br>​<br>​    <strong>double underscores</strong></p><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p><p>强调也可以直接插在文字中间：</p><p>​    un<em>frigging</em>believable</p><p>但是 <strong>如果你的<code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong> 。</p><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p><p>​    *this text is surrounded by literal asterisks*</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果要标记一小段行内代码，你可以用反引号把它包起来，例如：</p><p>​    Use the <code>printf()</code> function.</p><p>会产生：</p><p>​    </p><p>Use the <code>printf()</code> function.</p><p></p><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><p>​    <code>There is a literal backtick (`) here.</code></p><p>这段语法会产生：</p><p>​    <code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;</code></p><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p><p>​    A single backtick in a code span: <code>`</code><br>​<br>​    A backtick-delimited string in a code span: <code>`foo`</code></p><p>会产生：</p><p>​    </p><p>A single backtick in a code span: <code><code>&lt;/code&gt;&lt;/p&gt;​    ​    &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;</code>foo`</code></p><p></p><p>在代码区段内，<code>&amp;</code> 和尖括号 <strong>都</strong> 会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p><p>​    Please don’t use any <code>&lt;blink&gt;</code> tags.</p><p>转为：</p><p>​    </p><p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p><p></p><p>你也可以这样写：</p><p>​    <code>&amp;#8212;</code> is the decimal-encoded equivalent of <code>&amp;mdash;</code>.</p><p>以产生：</p><p>​    </p><p><code>&amp;#8212;</code> is the decimal-encoded<br>​    equivalent of <code>&amp;mdash;</code>.</p><p></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em> 和 <em>参考式</em> 。</p><p>行内式的图片语法看起来像是：</p><figure class="hljs highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">![<span class="hljs-string">Alt text</span>](<span class="hljs-link">/path/to/img.jpg</span>)<br>![<span class="hljs-string">Alt text</span>](<span class="hljs-link">/path/to/img.jpg "Optional title"</span>)<br></code></pre></td></tr></table></figure><p>详细叙述如下：</p><ul><li>一个惊叹号 <code>!</code></li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li></ul><p>参考式的图片语法则长得像这样：</p><figure class="hljs highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">![<span class="hljs-string">Alt text</span>][<span class="hljs-symbol">id</span>]<br></code></pre></td></tr></table></figure><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">[<span class="hljs-built_in">id</span>]: url/<span class="hljs-keyword">to</span>/image  <span class="hljs-string">"Optional title attribute"</span><br></code></pre></td></tr></table></figure><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><p>​    <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a></p><p>Markdown 会转为：</p><p>​    <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a></p><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p><p>​    <a href="mailto:&#97;&#100;&#x64;&#114;&#x65;&#115;&#x73;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#97;&#100;&#x64;&#114;&#x65;&#115;&#x73;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;</a></p><p>Markdown 会转成：</p><p>​    <a href="&#x6D;&#x61;i&#x6C;&#x74;&#x6F;:&#x61;&#x64;&#x64;&#x72;&#x65;​    &#115;&#115;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6C;e&#x2E;&#99;&#111;​    &#109;">&#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61;<br>​    &#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109;</a></p><p>在浏览器里面，这段字串（其实是 <code>&lt;ahref=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「<a href="mailto:address@example.com" target="_blank" rel="noopener">address@example.com</a>」链接。</p><p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code><br>标签），你可以在星号的前面加上反斜杠：</p><p>​    *literal asterisks*</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><p>​    \   反斜线<br>​    `   反引号<br>​    *   星号<br>​    _   底线<br>​    {}  花括号<br>​    []  方括号<br>​    ()  括弧<br>​    #   井字号<br>​    +   加号<br>​    -   减号<br>​    .   英文句点<br>​    !   惊叹号</p><p><a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="noopener">转载之wowubuntu</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jQuery</title>
      <link href="/2018/03/14/cnblog_8565153/"/>
      <url>/2018/03/14/cnblog_8565153/</url>
      <content type="html"><![CDATA[<h1 id="这是👉jQuery👈的摘要"><a href="#这是👉jQuery👈的摘要" class="headerlink" title="这是👉jQuery👈的摘要"></a><a href="/2018/03/14/cnblog_8565153/">这是👉jQuery👈的摘要</a></h1><a id="more"></a><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h2><ol><li>jQuery是一个轻量级的、兼容多浏览器的JavaScript库。</li><li>jQuery使用户能够更方便地处理HTML Document、Events、实现动画效果、方便地进行Ajax交互，能够极大地简化JavaScript编程。它的宗旨就是：”Write less, do more.”</li></ol><h2 id="jQuery的优势"><a href="#jQuery的优势" class="headerlink" title="jQuery的优势"></a>jQuery的优势</h2><ol><li>一款轻量级的JS框架。jQuery核心js文件才几十kb，不会影响页面加载速度。</li><li>丰富的DOM选择器,jQuery的选择器用起来很方便，比如要找到某个DOM对象的相邻元素，JS可能要写好几行代码，而jQuery一行代码就搞定了，再比如要将一个表格的隔行变色，jQuery也是一行代码搞定。</li><li>链式表达式。jQuery的链式操作可以把多个操作写在一行代码里，更加简洁。</li><li>事件、样式、动画支持。jQuery还简化了js操作css的代码，并且代码的可读性也比js要强。</li><li>Ajax操作支持。jQuery简化了AJAX操作，后端只需返回一个JSON格式的字符串就能完成与前端的通信。</li><li>跨浏览器兼容。jQuery基本兼容了现在主流的浏览器，不用再为浏览器的兼容问题而伤透脑筋。</li><li>插件扩展开发。jQuery有着丰富的第三方的插件，例如：树形菜单、日期控件、图片切换插件、弹出窗口等等基本前端页面上的组件都有对应插件，并且用jQuery插件做出来的效果很炫，并且可以根据自己需要去改写和封装插件，简单实用。</li></ol><h2 id="jQuery内容："><a href="#jQuery内容：" class="headerlink" title="jQuery内容："></a>jQuery内容：</h2><ol><li>选择器</li><li>筛选器</li><li>样式操作</li><li>文本操作</li><li>属性操作</li><li>文档处理</li><li>事件</li><li>动画效果</li><li>插件</li><li>each、data、Ajax</li></ol><p>下载链接：<a href="https://jquery.com/" target="_blank" rel="noopener">jQuery官网</a></p><h2 id="jQuery版本"><a href="#jQuery版本" class="headerlink" title="jQuery版本"></a>jQuery版本</h2><ul><li>1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</li><li>2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</li><li>3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本。</li></ul><p><em>维护IE678是一件让人头疼的事情，一般我们都会额外加载一个CSS和JS单独处理。值得庆幸的是使用这些浏览器的人也逐步减少，PC端用户已经逐步被移动端用户所取代，如果没有特殊要求的话，一般都会选择放弃对678的支持。</em></p><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p><strong>jQuery对象</strong> 就是通过jQuery包装DOM对象后产生的对象。 <strong>jQuery对象</strong> 是 jQuery独有的。如果一个对象是<br><strong>jQuery对象</strong> ，那么它就可以使用 <strong>jQuery</strong> 里的方法：例如$(“#i1”).html()。</p><p><code>$(&quot;#i1&quot;).html()</code>的意思是：获取id值为 <code>i1</code>的元素的html代码。其中 <code>html()</code>是jQuery里的方法。</p><p>相当于： <code>document.getElementById(&quot;i1&quot;).innerHTML;</code></p><p>虽然 <code>jQuery对象</code>是包装 <code>DOM对象</code>后产生的，但是 <code>jQuery对象</code>无法使用 <code>DOM对象</code>的任何方法，同理 <code>DOM对象</code>也没不能使用<br><code>jQuery</code>里的方法。</p><p>一个约定，我们在声明一个jQuery对象变量的时候在变量名前面加上$：</p><pre><code>var $variable = jQuery对像var variable = DOM对象$variable[0]//jQuery对象转成DOM对象</code></pre><p>拿上面那个例子举例，jQuery对象和DOM对象的使用：</p><pre><code>$(&quot;#i1&quot;).html();//jQuery对象可以使用jQuery的方法$(&quot;#i1&quot;)[0].innerHTML;// DOM对象使用DOM的方法</code></pre><h2 id="jQuery基础语法"><a href="#jQuery基础语法" class="headerlink" title="jQuery基础语法"></a>jQuery基础语法</h2><p><code>$(selector).action()</code></p><h2 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p><strong>id选择器：</strong></p><pre><code>$(&quot;#id&quot;)</code></pre><p><strong>标签选择器：</strong></p><pre><code>$(&quot;tagName&quot;)</code></pre><p><strong>class选择器：</strong></p><pre><code>$(&quot;.className&quot;)</code></pre><p><strong>配合使用：</strong></p><pre><code>$(&quot;div.c1&quot;)   // 找到有c1 class类的div标签</code></pre><p><strong>所有元素选择器：</strong></p><pre><code>$(&quot;*&quot;)</code></pre><p><strong>组合选择器：</strong></p><pre><code>$(&quot;#id, .className, tagName&quot;)</code></pre><p><strong>层级选择器：</strong></p><p><em>x和y可以为任意选择器</em></p><pre><code>$(&quot;x y&quot;); // x的所有后代y（子子孙孙）$(&quot;x &gt; y&quot;);// x的所有儿子y（儿子）$(&quot;x + y&quot;)// 找到所有紧挨在x后面的y$(&quot;x ~ y&quot;)// x之后所有的兄弟y</code></pre><p><strong>基本筛选器：</strong></p><pre><code>:first  // 第一个:last // 最后一个:eq(index)// 索引等于index的那个元素:even // 匹配所有索引值为偶数的元素，从 0 开始计数:odd // 匹配所有索引值为奇数的元素，从 0 开始计数:gt(index)// 匹配所有大于给定索引值的元素:lt(index)// 匹配所有小于给定索引值的元素:not(元素选择器)// 移除所有满足not条件的标签:has(元素选择器)// 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找)</code></pre><p><strong>例子：</strong></p><pre><code>$(&quot;div:has(h1)&quot;) // 找到所有后代中有h1标签的div标签$(&quot;div:has(.c1)&quot;)// 找到所有后代中有c1样式类的div标签$(&quot;li:not(.c1)&quot;)// 找到所有不包含c1样式类的li标签$(&quot;li:not(:has(a))&quot;)// 找到所有后代中不含a标签的li标签</code></pre><p>练习：</p><p>自定义模态框，使用jQuery实现弹出和隐藏功能。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;自定义模态框&lt;/title&gt;  &lt;style&gt;    .cover {      position: fixed;      left: 0;      right: 0;      top: 0;      bottom: 0;      background-color: darkgrey;      z-index: 999;    }    .modal {      width: 600px;      height: 400px;      background-color: white;      position: fixed;      left: 50%;      top: 50%;      margin-left: -300px;      margin-top: -200px;      z-index: 1000;    }    .hide {      display: none;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;弹&quot; id=&quot;i0&quot;&gt;&lt;div class=&quot;cover hide&quot;&gt;&lt;/div&gt;&lt;div class=&quot;modal hide&quot;&gt;  &lt;label for=&quot;i1&quot;&gt;姓名&lt;/label&gt;  &lt;input id=&quot;i1&quot; type=&quot;text&quot;&gt;   &lt;label for=&quot;i2&quot;&gt;爱好&lt;/label&gt;  &lt;input id=&quot;i2&quot; type=&quot;text&quot;&gt;  &lt;input type=&quot;button&quot; id=&quot;i3&quot; value=&quot;关闭&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  var tButton = $(&quot;#i0&quot;)[0];  tButton.onclick=function () {    var coverEle = $(&quot;.cover&quot;)[0];    var modalEle = $(&quot;.modal&quot;)[0];    $(coverEle).removeClass(&quot;hide&quot;);    $(modalEle).removeClass(&quot;hide&quot;);  };  var cButton = $(&quot;#i3&quot;)[0];  cButton.onclick=function () {    var coverEle = $(&quot;.cover&quot;)[0];    var modalEle = $(&quot;.modal&quot;)[0];    $(coverEle).addClass(&quot;hide&quot;);    $(modalEle).addClass(&quot;hide&quot;);  }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>jQuery版自定义模态框</p><p><strong>属性选择器：</strong></p><pre><code> [attribute][attribute=value]// 属性等于[attribute!=value]// 属性不等于  </code></pre><p><strong>例子：</strong></p><pre><code> // 示例&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;$(&quot;input[type=&apos;checkbox&apos;]&quot;);// 取到checkbox类型的input标签$(&quot;input[type!=&apos;text&apos;]&quot;);// 取到类型不是text的input标签</code></pre><p><strong>表单常用筛选</strong> ：</p><pre><code>:text:password  :file:radio:checkbox  :submit:reset:button  </code></pre><p><strong>例子：</strong></p><pre><code>$(&quot;:checkbox&quot;)   // 找到所有的checkbox</code></pre><p>表单对象属性:</p><pre><code>:enabled:disabled:checked:selected</code></pre><p><strong>例子：</strong></p><pre><code>&lt;form&gt;  &lt;input name=&quot;email&quot; disabled=&quot;disabled&quot; /&gt;  &lt;input name=&quot;id&quot; /&gt;&lt;/form&gt;$( &quot;input:enabled&quot;)  // 找到可用的input标签&lt;select id=&quot;s1&quot;&gt;  &lt;option value=&quot;beijing&quot;&gt;北京市&lt;/option&gt;  &lt;option value=&quot;shanghai&quot;&gt;上海市&lt;/option&gt;  &lt;option selected value=&quot;guangzhou&quot;&gt;广州市&lt;/option&gt;  &lt;option value=&quot;shenzhen&quot;&gt;深圳市&lt;/option&gt;&lt;/select&gt;$(&quot;:selected&quot;)  // 找到所有被选中的option</code></pre><h3 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h3><p>下一个元素：</p><pre><code>$(&quot;#id&quot;).next()$(&quot;#id&quot;).nextAll()$(&quot;#id&quot;).nextUntil(&quot;#i2&quot;)</code></pre><p>上一个元素：</p><pre><code>$(&quot;#id&quot;).prev()$(&quot;#id&quot;).prevAll()$(&quot;#id&quot;).prevUntil(&quot;#i2&quot;)</code></pre><p>父亲元素：</p><pre><code>$(&quot;#id&quot;).parent()$(&quot;#id&quot;).parents()  // 查找当前元素的所有的父辈元素  $(&quot;#id&quot;).parentsUntil() // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。</code></pre><p>儿子和兄弟元素：</p><pre><code>$(&quot;#id&quot;).children();// 儿子们$(&quot;#id&quot;).siblings();// 兄弟们</code></pre><p>查找元素：</p><pre><code>$(&quot;#id&quot;).find()// 搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</code></pre><p>补充：</p><pre><code>.first()// 获取匹配的第一个元素.last()// 获取匹配的最后一个元素.not()// 从匹配元素的集合中删除与指定表达式匹配的元素.has()// 保留包含特定后代的元素，去掉那些不含有指定后代的元素。</code></pre><p>示例：左侧菜单</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;左侧菜单示例&lt;/title&gt;  &lt;style&gt;    .left {      position: fixed;      left: 0;      top: 0;      width: 20%;      height: 100%;      background-color: rgb(47, 53, 61);    }    .right {      width: 80%;      height: 100%;    }    .menu {      color: white;    }    .title {      text-align: center;      padding: 10px 15px;      border-bottom: 1px solid #23282e;    }    .items {      background-color: #181c20;    }    .item {      padding: 5px 10px;      border-bottom: 1px solid #23282e;    }    .hide {      display: none;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;left&quot;&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;菜单一&lt;/div&gt;    &lt;div class=&quot;items&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;title&quot;&gt;菜单二&lt;/div&gt;    &lt;div class=&quot;items hide&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;title&quot;&gt;菜单三&lt;/div&gt;    &lt;div class=&quot;items hide&quot;&gt;      &lt;div class=&quot;item&quot;&gt;111&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;222&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;333&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;.title&quot;).click(function (){  // jQuery绑定事件    // 隐藏所有class里有.items的标签    $(&quot;.items&quot;).addClass(&quot;hide&quot;);  //批量操作    $(this).next().removeClass(&quot;hide&quot;);  });&lt;/script&gt;</code></pre><p>左侧菜单示例</p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p>样式类</p><pre><code>addClass();// 添加指定的CSS类名。removeClass();// 移除指定的CSS类名。hasClass();// 判断样式存不存在toggleClass();// 切换CSS类名，如果有就移除，如果没有就添加。</code></pre><p>示例：开关灯和模态框</p><p>CSS</p><pre><code>css(&quot;color&quot;,&quot;red&quot;)//DOM操作：tag.style.color=&quot;red&quot;</code></pre><p>示例：</p><pre><code>$(&quot;p&quot;).css(&quot;color&quot;, &quot;red&quot;); //将所有p标签的字体设置为红色</code></pre><p>位置：</p><pre><code>offset()// 获取匹配元素在当前窗口的相对偏移或设置元素位置position()// 获取匹配元素相对父元素的偏移scrollTop()// 获取匹配元素相对滚动条顶部的偏移scrollLeft()// 获取匹配元素相对滚动条左侧的偏移</code></pre><p><code>.offset()</code>方法允许我们检索一个元素相对于文档（document）的当前位置。</p><p>和 <code>.position()</code>的差别在于： <code>.position()</code>是相对于相对于父级元素的位移。</p><p>示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;位置相关示例之返回顶部&lt;/title&gt;  &lt;style&gt;    .c1 {      width: 100px;      height: 200px;      background-color: red;    }    .c2 {      height: 50px;      width: 50px;      position: fixed;      bottom: 15px;      right: 15px;      background-color: #2b669a;    }    .hide {      display: none;    }    .c3 {      height: 100px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;b1&quot; class=&quot;btn btn-default&quot;&gt;点我&lt;/button&gt;&lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;95&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;96&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;97&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;98&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;99&lt;/div&gt;&lt;div class=&quot;c3&quot;&gt;100&lt;/div&gt;&lt;button id=&quot;b2&quot; class=&quot;btn btn-default c2 hide&quot;&gt;返回顶部&lt;/button&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;#b1&quot;).on(&quot;click&quot;, function () {    $(&quot;.c1&quot;).offset({left: 200, top:200});  });  $(window).scroll(function () {    if ($(window).scrollTop() &gt; 100) {      $(&quot;#b2&quot;).removeClass(&quot;hide&quot;);    }else {      $(&quot;#b2&quot;).addClass(&quot;hide&quot;);    }  });  $(&quot;#b2&quot;).on(&quot;click&quot;, function () {    $(window).scrollTop(0);  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>返回顶部示例</p><p>尺寸：</p><pre><code>height()width()innerHeight()innerWidth()outerHeight()outerWidth()</code></pre><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><p>HTML代码：</p><pre><code>html()// 取得第一个匹配元素的html内容html(val)// 设置所有匹配元素的html内容</code></pre><p>文本值：</p><pre><code>text()// 取得所有匹配元素的内容text(val)// 设置所有匹配元素的内容</code></pre><p>值：</p><pre><code>val()// 取得第一个匹配元素的当前值val(val)// 设置所有匹配元素的值val([val1, val2])// 设置checkbox、select的值</code></pre><p>示例：</p><p>获取被选中的checkbox或radio的值：</p><pre><code>&lt;label for=&quot;c1&quot;&gt;女&lt;/label&gt;&lt;input name=&quot;gender&quot; id=&quot;c1&quot; type=&quot;radio&quot; value=&quot;0&quot;&gt;&lt;label for=&quot;c2&quot;&gt;男&lt;/label&gt;&lt;input name=&quot;gender&quot; id=&quot;c2&quot; type=&quot;radio&quot; value=&quot;1&quot;&gt;</code></pre><p>可以使用：</p><pre><code>$(&quot;input[name=&apos;gender&apos;]:checked&quot;).val()</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;jQuery val示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;label for=&quot;s1&quot;&gt;城市&lt;/label&gt;&lt;select id=&quot;s1&quot;&gt;  &lt;option value=&quot;beijing&quot;&gt;北京市&lt;/option&gt;  &lt;option value=&quot;shanghai&quot;&gt;上海市&lt;/option&gt;  &lt;option selected value=&quot;guangzhou&quot;&gt;广州市&lt;/option&gt;  &lt;option value=&quot;shenzhen&quot;&gt;深圳市&lt;/option&gt;&lt;/select&gt;&lt;hr&gt;&lt;label for=&quot;s2&quot;&gt;爱好&lt;/label&gt;&lt;select id=&quot;s2&quot; multiple=&quot;multiple&quot;&gt;  &lt;option value=&quot;basketball&quot; selected&gt;篮球&lt;/option&gt;  &lt;option value=&quot;football&quot;&gt;足球&lt;/option&gt;  &lt;option value=&quot;doublecolorball&quot; selected&gt;双色球&lt;/option&gt;&lt;/select&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // 单选下拉框  $(&quot;#s1&quot;).val(&quot;shanghai&quot;);  // 多选下拉框   $(&quot;#s2&quot;).val([&quot;basketball&quot;, &quot;football&quot;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>jQuery val赋值示例</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;文本操作之登录验证&lt;/title&gt;  &lt;style&gt;    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt;  &lt;div&gt;    &lt;label for=&quot;input-name&quot;&gt;用户名&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;input-name&quot; name=&quot;name&quot;&gt;    &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;label for=&quot;input-password&quot;&gt;密码&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;input-password&quot; name=&quot;password&quot;&gt;    &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  &lt;/div&gt;&lt;/form&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;#btn&quot;).click(function () {    var username = $(&quot;#input-name&quot;).val();    var password = $(&quot;#input-password&quot;).val();    if (username.length === 0) {      $(&quot;#input-name&quot;).siblings(&quot;.error&quot;).text(&quot;用户名不能为空&quot;);    }    if (password.length === 0) {      $(&quot;#input-password&quot;).siblings(&quot;.error&quot;).text(&quot;密码不能为空&quot;);    }  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>自定义登录校验示例</p><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>用于ID等或自定义属性：</p><pre><code>attr(attrName)// 返回第一个匹配元素的属性值attr(attrName, attrValue)// 为所有匹配元素设置一个属性值attr({k1: v1, k2:v2})// 为所有匹配元素设置多个属性值removeAttr()// 从每一个匹配的元素中删除一个属性</code></pre><p>用于checkbox和radio</p><pre><code>prop() // 获取属性removeProp() // 移除属性</code></pre><p><strong>注意：</strong></p><p>在1.x及2.x版本的jQuery中使用attr对checkbox进行复制操作时会出bug，在3.x版本的jQuery中则没有这个问题。为了兼容性，我们在处理checkbox和radio的时候尽量使用特定的prop()，不要使用attr(“checked”,<br>“checked”)。</p><pre><code>&lt;input type=&quot;checkbox&quot; value=&quot;1&quot;&gt;&lt;input type=&quot;radio&quot; value=&quot;2&quot;&gt;&lt;script&gt;  $(&quot;:checkbox[value=&apos;1&apos;]&quot;).prop(&quot;checked&quot;, true);  $(&quot;:radio[value=&apos;2&apos;]&quot;).prop(&quot;checked&quot;, true);&lt;/script&gt;</code></pre><p>示例：全选、反选、取消</p><h3 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h3><p>添加到指定元素 <strong>内部</strong> 的后面</p><pre><code>$(A).append(B)// 把B追加到A$(A).appendTo(B)// 把A追加到B</code></pre><p>添加到指定元素 <strong>内部</strong> 的前面</p><pre><code>$(A).prepend(B)// 把B前置到A$(A).prependTo(B)// 把A前置到B</code></pre><p>添加到指定元素 <strong>外部</strong> 的后面</p><pre><code>$(A).after(B)// 把B放到A的后面$(A).insertAfter(B)// 把A放到B的后面</code></pre><p>添加到指定元素 <strong>外部</strong> 的前面</p><pre><code>$(A).before(B)// 把B放到A的前面$(A).insertBefore(B)// 把A放到B的前面</code></pre><p>移除和清空元素</p><pre><code>remove()// 从DOM中删除所有匹配的元素。empty()// 删除匹配的元素集合中所有的子节点。</code></pre><p>例子：</p><p>点击按钮在表格添加一行数据。</p><p>点击每一行的删除按钮删除当前行数据。</p><p>替换</p><pre><code>replaceWith()replaceAll()</code></pre><p>克隆</p><pre><code>clone()// 参数</code></pre><p>克隆示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;克隆&lt;/title&gt;  &lt;style&gt;    #b1 {      background-color: deeppink;      padding: 5px;      color: white;      margin: 5px;    }    #b2 {      background-color: dodgerblue;      padding: 5px;      color: white;      margin: 5px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;b1&quot;&gt;屠龙宝刀，点击就送&lt;/button&gt;&lt;hr&gt;&lt;button id=&quot;b2&quot;&gt;屠龙宝刀，点击就送&lt;/button&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // clone方法不加参数true，克隆标签但不克隆标签带的事件  $(&quot;#b1&quot;).on(&quot;click&quot;, function () {    $(this).clone().insertAfter(this);  });  // clone方法加参数true，克隆标签并且克隆标签带的事件  $(&quot;#b2&quot;).on(&quot;click&quot;, function () {    $(this).clone(true).insertAfter(this);  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>点击复制按钮</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><pre><code>click(function(){...})hover(function(){...})blur(function(){...})focus(function(){...})change(function(){...})keyup(function(){...})</code></pre><p>keydown和keyup事件组合示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;键盘事件示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;  &lt;thead&gt;  &lt;tr&gt;    &lt;th&gt;#&lt;/th&gt;    &lt;th&gt;姓名&lt;/th&gt;    &lt;th&gt;操作&lt;/th&gt;  &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Egon&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Alex&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Yuan&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;EvaJ&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt;    &lt;td&gt;Gold&lt;/td&gt;    &lt;td&gt;      &lt;select&gt;        &lt;option value=&quot;1&quot;&gt;上线&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;下线&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;停职&lt;/option&gt;      &lt;/select&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;&lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;全选&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;取消&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;b3&quot; value=&quot;反选&quot;&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // 全选  $(&quot;#b1&quot;).on(&quot;click&quot;, function () {    $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, true);  });  // 取消  $(&quot;#b2&quot;).on(&quot;click&quot;, function () {    $(&quot;:checkbox&quot;).prop(&quot;checked&quot;, false);  });  // 反选  $(&quot;#b3&quot;).on(&quot;click&quot;, function () {    $(&quot;:checkbox&quot;).each(function () {      var flag = $(this).prop(&quot;checked&quot;);      $(this).prop(&quot;checked&quot;, !flag);    })  });  // 按住shift键，批量操作  // 定义全局变量  var flag = false;  // 全局事件，监听键盘shift按键是否被按下  $(window).on(&quot;keydown&quot;, function (e) {//    alert(e.keyCode);    if (e.keyCode === 16){      flag = true;    }  });  // 全局事件,shift按键抬起时将全局变量置为false  $(window).on(&quot;keyup&quot;, function (e) {    if (e.keyCode === 16){      flag = false;    }  });  // select绑定change事件  $(&quot;table select&quot;).on(&quot;change&quot;, function () {    // 是否为批量操作模式    if (flag) {      var selectValue = $(this).val();      // 找到所有被选中的那一行的select，选中指定值      $(&quot;input:checked&quot;).parent().parent().find(&quot;select&quot;).val(selectValue);    }  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>按住shift键批量操作</p><p>实时监听input输入值变化示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;实时监听input输入值变化&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;i1&quot;&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  /*  * oninput是HTML5的标准事件  * 能够检测textarea,input:text,input:password和input:search这几个元素的内容变化，  * 在内容修改后立即被触发，不像onchange事件需要失去焦点才触发  * oninput事件在IE9以下版本不支持，需要使用IE特有的onpropertychange事件替代  * 使用jQuery库的话直接使用on同时绑定这两个事件即可。  * */  $(&quot;#i1&quot;).on(&quot;input propertychange&quot;, function () {    alert($(this).val());  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>input值变化事件</p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ol><li><code>.on( events [, selector ],function(){})</code></li></ol><ul><li>events： 事件</li><li>selector: 选择器（可选的）</li><li>function: 事件处理函数</li></ul><h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><ol><li><code>.off( events [, selector ][,function(){}])</code></li></ol><p><code>off()</code> 方法移除用 <code>.on()</code>绑定的事件处理程序。</p><ul><li>events： 事件</li><li>selector: 选择器（可选的）</li><li>function: 事件处理函数</li></ul><h3 id="阻止后续事件执行"><a href="#阻止后续事件执行" class="headerlink" title="阻止后续事件执行"></a>阻止后续事件执行</h3><ol><li><code>return false; // 常见阻止表单提交等</code></li></ol><p>注意：</p><p>像click、keydown等DOM中定义的事件，我们都可以使用<code>.on()</code>方法来绑定事件，但是<code>hover</code>这种jQuery中定义的事件就不能用<code>.on()</code>方法来绑定了。</p><p>想使用事件委托的方式绑定hover事件处理函数，可以参照如下代码分两步绑定事件：</p><pre><code>$(&apos;ul&apos;).on(&apos;mouseenter&apos;, &apos;li&apos;, function() {//绑定鼠标进入事件    $(this).addClass(&apos;hover&apos;);});$(&apos;ul&apos;).on(&apos;mouseleave&apos;, &apos;li&apos;, function() {//绑定鼠标划出事件    $(this).removeClass(&apos;hover&apos;);});</code></pre><h3 id="页面载入"><a href="#页面载入" class="headerlink" title="页面载入"></a>页面载入</h3><p>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。</p><p>两种写法：</p><pre><code>$(document).ready(function(){// 在这里写你的JS代码...})</code></pre><p>简写：</p><pre><code>$(function(){// 你在这里写你的代码})</code></pre><p>文档加载完绑定事件，并且阻止默认事件发生：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;登录注册示例&lt;/title&gt;  &lt;style&gt;    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&quot;myForm&quot;&gt;  &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;  &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;  &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;label for=&quot;passwd&quot;&gt;密码&lt;/label&gt;  &lt;input type=&quot;password&quot; id=&quot;passwd&quot;&gt;  &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;  &lt;input type=&quot;submit&quot; id=&quot;modal-submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;s7validate.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  function myValidation() {    // 多次用到的jQuery对象存储到一个变量，避免重复查询文档树    var $myForm = $(&quot;#myForm&quot;);    $myForm.find(&quot;:submit&quot;).on(&quot;click&quot;, function () {      // 定义一个标志位，记录表单填写是否正常      var flag = true;      $myForm.find(&quot;:text, :password&quot;).each(function () {        var val = $(this).val();        if (val.length &lt;= 0 ){          var labelName = $(this).prev(&quot;label&quot;).text();          $(this).next(&quot;span&quot;).text(labelName + &quot;不能为空&quot;);          flag = false;        }      });      // 表单填写有误就会返回false，阻止submit按钮默认的提交表单事件      return flag;    });    // input输入框获取焦点后移除之前的错误提示信息    $myForm.find(&quot;input[type!=&apos;submit&apos;]&quot;).on(&quot;focus&quot;, function () {      $(this).next(&quot;.error&quot;).text(&quot;&quot;);    })  }  // 文档树就绪后执行  $(document).ready(function () {    myValidation();  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>登录校验示例</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是通过事件冒泡的原理，利用父标签去捕获子标签的事件。</p><p>示例：</p><p>表格中每一行的编辑和删除按钮都能触发相应的事件。</p><pre><code>$(&quot;table&quot;).on(&quot;click&quot;, &quot;.delete&quot;, function () {  // 删除按钮绑定的事件})</code></pre><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><pre><code>// 基本show([s,[e],[fn]])hide([s,[e],[fn]])toggle([s],[e],[fn])// 滑动slideDown([s],[e],[fn])slideUp([s,[e],[fn]])slideToggle([s],[e],[fn])// 淡入淡出fadeIn([s],[e],[fn])fadeOut([s],[e],[fn])fadeTo([[s],o,[e],[fn]])fadeToggle([s,[e],[fn]])// 自定义（了解即可）animate(p,[s],[e],[fn])</code></pre><p>自定义动画示例：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;点赞动画示例&lt;/title&gt;  &lt;style&gt;    div {      position: relative;      display: inline-block;    }    div&gt;i {      display: inline-block;      color: red;      position: absolute;      right: -16px;      top: -5px;      opacity: 1;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;d1&quot;&gt;点赞&lt;/div&gt;&lt;script src=&quot;jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $(&quot;#d1&quot;).on(&quot;click&quot;, function () {    var newI = document.createElement(&quot;i&quot;);    newI.innerText = &quot;+1&quot;;    $(this).append(newI);    $(this).children(&quot;i&quot;).animate({      opacity: 0    }, 1000)  })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>点赞特效简单示例</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p><strong>jQuery.each(collection, callback(indexInArray, valueOfElement))：</strong></p><p>描述：一个通用的迭代函数，它可以用来无缝迭代对象和数组。数组和类似数组的对象通过一个长度属性（如一个函数的参数对象）来迭代数字索引，从0到length -<br>1。其他对象通过其属性名进行迭代。</p><pre><code>li =[10,20,30,40]$.each(li,function(i, v){  console.log(i, v);//index是索引，ele是每次循环的具体元素。})</code></pre><p>输出：</p><pre><code>010120230340</code></pre><p><strong>.each(function(index, Element))：</strong></p><p>描述：遍历一个jQuery对象，为每个匹配元素执行一个函数。</p><p><code>.each()</code><br>方法用来迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。由于回调函数是在当前DOM元素为上下文的语境中触发的，所以关键字<br><code>this</code> 总是指向这个元素。</p><pre><code>// 为每一个li标签添加foo$(&quot;li&quot;).each(function(){  $(this).addClass(&quot;c1&quot;);});</code></pre><p>注意: jQuery的方法返回一个jQuery对象，遍历jQuery集合中的元素 - 被称为隐式 _迭代_<br>的过程。当这种情况发生时，它通常不需要显式地循环的 <code>.each()</code>方法：</p><p>也就是说，上面的例子没有必要使用each()方法，直接像下面这样写就可以了：</p><pre><code>$(&quot;li&quot;).addClass(&quot;c1&quot;);  // 对所有标签做统一操作</code></pre><p><strong>注意：</strong></p><p>在遍历过程中可以使用 <code>return false</code>提前结束each循环。</p><p><strong>终止each循环</strong></p><pre><code>return false；</code></pre><p>伏笔…</p><h3 id="data"><a href="#data" class="headerlink" title=".data()"></a>.data()</h3><p>在匹配的元素集合中的所有元素上存储任意相关数据或返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p><p><strong>.data(key, value):</strong></p><p>描述：在匹配的元素上存储任意相关数据。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;,100);//给所有div标签都保存一个名为k，值为100</code></pre><p><strong>.data(key):</strong></p><p>描述: 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值–通过 <code>.data(name, value)</code>或 <code>HTML5 data-*</code>属性设置。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;);//返回第一个div标签中保存的&quot;k&quot;的值</code></pre><p>.removeData(key):</p><p>描述：移除存放在元素上的数据，不加key参数表示移除所有保存的数据。</p><pre><code>$(&quot;div&quot;).removeData(&quot;k&quot;);  //移除元素上存放k对应的数据</code></pre><p>示例：</p><p>模态框编辑的数据回填表格</p><h3 id="插件-了解即可"><a href="#插件-了解即可" class="headerlink" title="插件(了解即可)"></a>插件(了解即可)</h3><p>jQuery.extend(object)</p><p>jQuery的命名空间下添加新的功能。多用于插件开发者向 jQuery 中添加新函数时使用。</p><p>示例：</p><pre><code>&lt;script&gt;jQuery.extend({  min:function(a, b){return a &lt; b ? a : b;},  max:function(a, b){return a &gt; b ? a : b;}});jQuery.min(2,3);// =&gt; 2jQuery.max(4,5);// =&gt; 5&lt;/script&gt;</code></pre><p>jQuery.fn.extend(object)</p><p>一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。</p><pre><code>&lt;script&gt;  jQuery.fn.extend({    check:function(){      return this.each(function(){this.checked =true;});    },    uncheck:function(){      return this.each(function(){this.checked =false;});    }  });// jQuery对象可以使用新添加的check()方法了。$(&quot;input[type=&apos;checkbox&apos;]&quot;).check();&lt;/script&gt;</code></pre><p>单独写在文件中的扩展：</p><pre><code>(function(jq){  jq.extend({    funcName:function(){    ...    },  });})(jQuery);</code></pre><p>例子：</p><p>自定义的jQuery登录验证插件</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;登录校验示例&lt;/title&gt;  &lt;style&gt;    .login-form {      margin: 100px auto 0;      max-width: 330px;    }    .login-form &gt; div {      margin: 15px 0;    }    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;  &lt;form action=&quot;&quot; class=&quot;login-form&quot; novalidate&gt;    &lt;div&gt;      &lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;      &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;name&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;passwd&quot;&gt;密码&lt;/label&gt;      &lt;input id=&quot;passwd&quot; type=&quot;password&quot; name=&quot;password&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;mobile&quot;&gt;手机&lt;/label&gt;      &lt;input id=&quot;mobile&quot; type=&quot;text&quot; name=&quot;mobile&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;where&quot;&gt;来自&lt;/label&gt;      &lt;input id=&quot;where&quot; type=&quot;text&quot; name=&quot;where&quot; autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/div&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;validate.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $.validate();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTML文件</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&quot;use strict&quot;;(function ($) {  function check() {    // 定义一个标志位，表示验证通过还是验证不通过    var flag = true;    var errMsg;    // 校验规则    $(&quot;form input[type!=&apos;:submit&apos;]&quot;).each(function () {      var labelName = $(this).prev().text();      var inputName = $(this).attr(&quot;name&quot;);      var inputValue = $(this).val();      if ($(this).attr(&quot;required&quot;)) {        // 如果是必填项        if (inputValue.length === 0) {          // 值为空          errMsg = labelName + &quot;不能为空&quot;;          $(this).next().text(errMsg);          flag = false;          return false;        }        // 如果是密码类型，我们就要判断密码的长度是否大于6位        if (inputName === &quot;password&quot;) {          // 除了上面判断为不为空还要判断密码长度是否大于6位          if (inputValue.length &lt; 6) {            errMsg = labelName + &quot;必须大于6位&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }        // 如果是手机类型，我们需要判断手机的格式是否正确        if (inputName === &quot;mobile&quot;) {          // 使用正则表达式校验inputValue是否为正确的手机号码          if (!/^1[345678]\d{9}$/.test(inputValue)) {            // 不是有效的手机号码格式            errMsg = labelName + &quot;格式不正确&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }      }    });    return flag;  }  function clearError(arg) {    // 清空之前的错误提示    $(arg).next().text(&quot;&quot;);  }  // 上面都是我定义的工具函数  $.extend({    validate: function () {      $(&quot;form :submit&quot;).on(&quot;click&quot;, function () {      return check();    });    $(&quot;form :input[type!=&apos;submit&apos;]&quot;).on(&quot;focus&quot;, function () {      clearError(this);    });    }  });})(jQuery);</code></pre><p>JS文件</p><p> 传参版插件：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;登录校验示例&lt;/title&gt;  &lt;style&gt;    .login-form {      margin: 100px auto 0;      max-width: 330px;    }    .login-form &gt; div {      margin: 15px 0;    }    .error {      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;  &lt;form action=&quot;&quot; class=&quot;login-form&quot; novalidate&gt;    &lt;div&gt;      &lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;      &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;name&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;passwd&quot;&gt;密码&lt;/label&gt;      &lt;input id=&quot;passwd&quot; type=&quot;password&quot; name=&quot;password&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;mobile&quot;&gt;手机&lt;/label&gt;      &lt;input id=&quot;mobile&quot; type=&quot;text&quot; name=&quot;mobile&quot; required autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;label for=&quot;where&quot;&gt;来自&lt;/label&gt;      &lt;input id=&quot;where&quot; type=&quot;text&quot; name=&quot;where&quot; autocomplete=&quot;off&quot;&gt;      &lt;span class=&quot;error&quot;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/div&gt;  &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;validate3.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $.validate({&quot;name&quot;:{&quot;required&quot;: true}, &quot;password&quot;: {&quot;required&quot;: true, &quot;minLength&quot;: 8}, &quot;mobile&quot;: {&quot;required&quot;: true}});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTML文件</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&quot;use strict&quot;;(function ($) {  function check(arg) {    // 定义一个标志位，表示验证通过还是验证不通过    var flag = true;    var errMsg;    // 校验规则    $(&quot;form input[type!=&apos;:submit&apos;]&quot;).each(function () {      var labelName = $(this).prev().text();      var inputName = $(this).attr(&quot;name&quot;);      var inputValue = $(this).val();      if (arg[inputName].required) {        // 如果是必填项        if (inputValue.length === 0) {          // 值为空          errMsg = labelName + &quot;不能为空&quot;;          $(this).next().text(errMsg);          flag = false;          return false;        }        // 如果是密码类型，我们就要判断密码的长度是否大于6位        if (inputName === &quot;password&quot;) {          // 除了上面判断为不为空还要判断密码长度是否大于6位          if (inputValue.length &lt; arg[inputName].minLength) {            errMsg = labelName + &quot;必须大于&quot;+arg[inputName].minLength+&quot;位&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }        // 如果是手机类型，我们需要判断手机的格式是否正确        if (inputName === &quot;mobile&quot;) {          // 使用正则表达式校验inputValue是否为正确的手机号码          if (!/^1[345678]\d{9}$/.test(inputValue)) {            // 不是有效的手机号码格式            errMsg = labelName + &quot;格式不正确&quot;;            $(this).next().text(errMsg);            flag = false;            return false;          }        }      }    });    return flag;  }  function clearError(arg) {    // 清空之前的错误提示    $(arg).next().text(&quot;&quot;);  }  // 上面都是我定义的工具函数  $.extend({    validate: function (arg) {      $(&quot;form :submit&quot;).on(&quot;click&quot;, function () {      return check(arg);    });    $(&quot;form :input[type!=&apos;submit&apos;]&quot;).on(&quot;focus&quot;, function () {      clearError(this);    });    }  });})(jQuery);</code></pre><p>JS文件</p><p>课后习题：</p><ol><li>登录+验证</li><li>左侧菜单</li><li>表格-增、删、改、查</li></ol>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux screen 常用命令</title>
      <link href="/2018/03/13/cnblog_8554604/"/>
      <url>/2018/03/13/cnblog_8554604/</url>
      <content type="html"><![CDATA[<h1 id="这是👉linux-screen-常用命令👈的摘要"><a href="#这是👉linux-screen-常用命令👈的摘要" class="headerlink" title="这是👉linux screen 常用命令👈的摘要"></a><a href="/2018/03/13/cnblog_8554604/">这是👉linux screen 常用命令👈的摘要</a></h1><a id="more"></a><pre><code>screen  -s  yourname   # 创建一个名字为yourname的screenscreen  -ls   # 查看所有screenscreen -r  yourname   # 回到yourname这个screenscreen -d yourname   # 结束yourname这个screenscreen -d -r yourname   # 结束当前screen回到yourname在当前这个screen  按ctrl + A + K  杀死当前screenctrl + A + D  后台当前screen </code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端基础之BOM和DOM</title>
      <link href="/2018/03/12/cnblog_8550048/"/>
      <url>/2018/03/12/cnblog_8550048/</url>
      <content type="html"><![CDATA[<h1 id="这是👉前端基础之BOM和DOM👈的摘要"><a href="#这是👉前端基础之BOM和DOM👈的摘要" class="headerlink" title="这是👉前端基础之BOM和DOM👈的摘要"></a><a href="/2018/03/12/cnblog_8550048/">这是👉前端基础之BOM和DOM👈的摘要</a></h1><a id="more"></a><h1 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h1><p>到目前为止，我们已经学过了JavaScript的一些简单的语法。但是这些简单的语法，并没有和浏览器有任何交互。</p><p>也就是我们还不能制作一些我们经常看到的网页的一些交互，我们需要继续学习BOM和DOM相关知识。</p><p>JavaScript分为 ECMAScript，DOM，BOM。</p><p>BOM（Browser Object Model）是指浏览器窗口对象模型，顶级对象是window。</p><p>DOM （Document Object Model）是指文档对象模型，并非一个对象。</p><p>window、document都是一个实例对象，他们都属于Object，表示浏览器中打开的窗口。</p><p>Window对象是客户端JavaScript最高层对象之一，由于window对象是其它大部分对象的共同祖先，在调用window对象的方法和属性时，可以省略window对象的引用。例如：window.document.write()可以简写成：document.write()。</p><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>window 对象表示一个浏览器窗口。</p><p>在客户端 JavaScript 中，Window<br>对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。例如，可以只写<br>document，而不必写 window.document</p><p>同样，可以把当前窗口对象的方法当作函数来使用，如只写 alert()，而不必写 Window.alert()。</p><pre><code>alert()            显示带有一段消息和一个确认按钮的警告框。setInterval()      按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval()    取消由 setInterval() 设置的 timeout。setTimeout()       在指定的毫秒数后调用函数或计算表达式。clearTimeout()     取消由 setTimeout() 方法设置的 timeout。scrollTo()         把内容滚动到指定的坐标。confirm()          显示带有一段消息以及确认按钮和取消按钮的对话框。prompt()           显示可提示用户输入的对话框。open()             打开一个新的浏览器窗口或查找一个已命名的窗口。close()            关闭浏览器窗口。</code></pre><p>几个例子</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>// 每隔一段时间就执行一次相应函数var timer = setInterval(function(){console.log(123);}, 3000)// 取消setInterval设置clearInterval(timer);// 在指定时间之后执行一次相应函数var timer = setTimeout(function(){alert(123);}, 3000)// 取消setTimeout设置clearTimeout(timer);</code></pre><p>View Code</p><h2 id="window的子对象"><a href="#window的子对象" class="headerlink" title="window的子对象"></a>window的子对象</h2><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>浏览器对象，通过这个对象可以判定用户所使用的浏览器，包含了浏览器相关信息。</p><pre><code>navigator.appName　　// Web浏览器全称navigator.appVersion　　// Web浏览器厂商和版本的详细字符串navigator.userAgent　　// 客户端绝大部分信息navigator.platform　　　// 浏览器运行所在的操作系统</code></pre><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>屏幕对象，不常用。</p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>浏览历史对象，包含了用户对当前页面的浏览历史，但我们无法查看具体的地址，可以用来前进或后退一个页面。</p><pre><code>history.forward()  // 前进一页history.back()  // 后退一页history.go(n)  //  前进n页</code></pre><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><pre><code>location.href  获取URLlocation.href=&quot;URL&quot; // 跳转到指定页面location.reload() 重新加载页面  </code></pre><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM（Document Object Model）是一套对文档的内容进行抽象和概念化的方法。<br>它是一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态地对文档的内容、结构和样式进行访问和修改。简单来讲，DOM是一种API（应用编程接口）。<br>JavaScript对DOM进行了实现，对应于JavaScript中的document对象，通过该对象对DOM文档进行程序级别的控制。</p><p>DOM标准规定HTML文档中的每个成分都是一个节点(node)：</p><ul><li>文档节点(document对象)：代表整个文档</li><li>元素节点(element 对象)：代表一个元素（标签）</li><li>文本节点(text对象)：代表元素（标签）中的文本</li><li>属性节点(attribute对象)：代表一个属性，元素（标签）才有属性</li><li>注释是注释节点(comment对象)</li></ul><h3 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h3><pre><code>document.getElementById                根据ID获取一个标签document.getElementsByName         根据name属性获取标签集合document.getElementsByClassName 根据class属性获取document.getElementsByTagName    根据标签名获取标签合集</code></pre><h3 id="间接查找"><a href="#间接查找" class="headerlink" title="间接查找"></a>间接查找</h3><pre><code>parentNode  父节点childNodes  所有子节点firstChild  第一个子节点lastChild  最后一个子节点nextSibling 下一个兄弟节点previousSibling  上一个兄弟节点  // 注意节点和标签的区别，主要记下面的parentElement 父节点标签元素children  所有子标签firstElementChild  第一个子标签元素lastElementChild  最后一个子标签元素nextElementSibling  下一个兄弟标签元素previousElementSibling  上一个兄弟标签元素</code></pre><h2 id="document对象的属性和操作"><a href="#document对象的属性和操作" class="headerlink" title="document对象的属性和操作"></a>document对象的属性和操作</h2><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>attributes</p><p>| 获取所有标签属性<br>—|—<br>getAttribute() | 获取指定标签属性<br>setAttribute() | 设置指定标签属<br>removeAttribute() | 移除指定标签属  </p><p>var s = document.createAttribute(“age”)</p><p>s.nodeValue = “18”</p><p>|</p><p>创建age属性</p><p>设置属性值为18</p><h3 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h3><table><thead><tr><th>innerText</th><th>所有的纯文本内容，包括子标签中的文本  </th></tr></thead><tbody><tr><td>outerText</td><td>与innerText类似  </td></tr><tr><td>innerHTML</td><td>所有子节点(包括元素、注释和文本节点)  </td></tr><tr><td>outerHTML</td><td>返回自身节点与所有子节点  </td></tr><tr><td></td><td></td></tr><tr><td>textContent</td><td>与innerText类似，返回的内容带样式  </td></tr><tr><td>data</td><td>文本内容  </td></tr><tr><td>length</td><td>文本长度  </td></tr><tr><td>createTextNode()</td><td>创建文本  </td></tr><tr><td>normalize()</td><td>删除文本与文本之间的空白  </td></tr><tr><td>splitText()</td><td>分割  </td></tr><tr><td>appendData()</td><td>追加  </td></tr><tr><td>deleteData(offset,count)</td><td>从offset指定的位置开始删除count个字符  </td></tr><tr><td>insertData(offset,text)</td><td>在offset指定的位置插入text  </td></tr><tr><td>replaceData(offset,count,text)</td><td>替换，从offset开始到offscount处的文本被text替换  </td></tr><tr><td>substringData(offset,count)</td><td>提取从ffset开始到offscount处的文本  </td></tr></tbody></table><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p><strong>操作class类</strong></p><pre><code> className  获取所有样式类名(字符串)  classList.remove(cls)  删除指定类classList.add(cls)  添加类  classList.contains(cls)  存在返回true，否则返回false  classList.toggle(cls)  存在就删除，否则添加</code></pre><p><strong>指定CSS操作</strong></p><pre><code>obj.style.backgroundColor=&quot;red&quot;</code></pre><p>JS操作CSS属性的规律：</p><p>1.对于没有中横线的CSS属性一般直接使用style.属性名即可。如：</p><pre><code>obj.style.marginobj.style.widthobj.style.leftobj.style.position</code></pre><p>2.对含有中横线的CSS属性，将中横线后面的第一个字母换成大写即可。如：</p><pre><code>obj.style.marginTopobj.style.borderLeftWidthobj.style.zIndexobj.style.fontFamily</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段<br>JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。</p><pre><code>onclick        当用户点击某个对象时调用的事件句柄。ondblclick     当用户双击某个对象时调用的事件句柄。onfocus        元素获得焦点。               // 练习：输入框onblur         元素失去焦点。               应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.onchange       域的内容被改变。             应用场景：通常用于表单元素,当元素内容被改变时触发.（select联动）onkeydown      某个键盘按键被按下。          应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.onkeypress     某个键盘按键被按下并松开。onkeyup        某个键盘按键被松开。onload         一张页面或一幅图像完成加载。onmousedown    鼠标按钮被按下。onmousemove    鼠标被移动。onmouseout     鼠标从某元素移开。onmouseover    鼠标移到某元素之上。onselect      在文本框中的文本被选中时发生。onsubmit      确认按钮被点击，使用的对象是form。</code></pre><h2 id="常用的那些"><a href="#常用的那些" class="headerlink" title="常用的那些"></a>常用的那些</h2><h3 id="操作内容"><a href="#操作内容" class="headerlink" title="操作内容"></a>操作内容</h3><pre><code>innerText  文本innerHTML  HTML内容value  值</code></pre><h3 id="文档节点的增删改查"><a href="#文档节点的增删改查" class="headerlink" title="文档节点的增删改查"></a>文档节点的增删改查</h3><p><strong>增</strong></p><pre><code> createElement(name)  创建节点（标签）  appendChild() 末尾添加节点，并返回新增节点  insertBefore()  参照节点之前插入节点，两个参数：要插入的节点和参照节点  </code></pre><p><strong>删</strong></p><pre><code> 查找到要删除的元素获取它的父元素使用removeChild()方法删除</code></pre><p><strong>改</strong>  </p><p>第一种方式:</p><pre><code>使用上面增和删结合完成修改</code></pre><p>第二种方式:</p><pre><code>使用setAttribute();方法修改属性          使用innerHTML属性修改元素的内容</code></pre><p><strong>查</strong></p><p>使用之前介绍的方法.</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端基础之JavaScript</title>
      <link href="/2018/03/08/cnblog_8527506/"/>
      <url>/2018/03/08/cnblog_8527506/</url>
      <content type="html"><![CDATA[<h1 id="这是👉前端基础之JavaScript👈的摘要"><a href="#这是👉前端基础之JavaScript👈的摘要" class="headerlink" title="这是👉前端基础之JavaScript👈的摘要"></a><a href="/2018/03/08/cnblog_8527506/">这是👉前端基础之JavaScript👈的摘要</a></h1><a id="more"></a><h1 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h1><h2 id="JavaScript的历史"><a href="#JavaScript的历史" class="headerlink" title="JavaScript的历史"></a>JavaScript的历史</h2><ul><li>1992年Nombas开发出C-minus-minus(C–)的嵌入式脚本语言(最初绑定在CEnvi软件中)，后将其改名ScriptEase(客户端执行的语言)。</li><li>Netscape(网景)接收Nombas的理念,(Brendan Eich)在其Netscape Navigator 2.0产品中开发出一套livescript的脚本语言。Sun和Netscape共同完成，后改名叫JavaScript。</li><li>微软随后模仿在其IE3.0的产品中搭载了一个JavaScript的克隆版叫Jscript。</li><li>为了统一三家,ECMA(欧洲计算机制造协会)定义了ECMA-262规范.国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。</li><li>ECMA-262 是 JavaScript 标准的官方名称。</li></ul><h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><table><thead><tr><th>年份</th><th>名称</th><th>描述  </th></tr></thead><tbody><tr><td>1997</td><td>ECMAScript 1</td><td>第一个版本  </td></tr><tr><td>1998</td><td>ECMAScript 2</td><td>版本变更  </td></tr><tr><td>1999</td><td>ECMAScript 3</td><td></td></tr></tbody></table><p>添加正则表达式</p><p>添加tru/catch  </p><p>  | ECMAScript 4 | 没有发布<br>2009 | ECMAScript 5 |</p><p>添加”strict mode”严格模式</p><p>添加JSON支持  </p><p>2011 | ECMAScript 5.1 | 版本变更<br>2015 | ECMAScript 6 | 添加类和模块<br>2016 | ECMAScript 7 |</p><p>增加指数运算符（**）</p><p>增加Array.prototype.includes  </p><p><em>注：ES6就是指ECMAScript 6。</em></p><p>尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的<br>JavaScript 实现是由以下 3 个不同部分组成的：</p><ul><li>核心（ECMAScript） </li><li>文档对象模型（DOM） Document object model (整合js，css，html)</li><li>浏览器对象模型（BOM） Broswer object model（整合js和浏览器）</li><li>Javascript在开发中绝大多数情况是基于对象的.也是面向对象的.</li></ul><p>简单地说，ECMAScript 描述了以下内容：</p><ul><li>语法 </li><li>类型 </li><li>语句 </li><li>关键字 </li><li>保留字 </li><li>运算符 </li><li>对象 (封装 继承 多态) 基于对象的语言.使用对象.</li></ul><h2 id="JavaScript引入方式"><a href="#JavaScript引入方式" class="headerlink" title="JavaScript引入方式"></a>JavaScript引入方式</h2><h3 id="Script标签内写代码"><a href="#Script标签内写代码" class="headerlink" title="Script标签内写代码"></a>Script标签内写代码</h3><pre><code>&lt;script&gt;  // 在这里写你的JS代码&lt;/script&gt;</code></pre><h3 id="引入额外的JS文件"><a href="#引入额外的JS文件" class="headerlink" title="引入额外的JS文件"></a>引入额外的JS文件</h3><pre><code>&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="JavaScript语言规范"><a href="#JavaScript语言规范" class="headerlink" title="JavaScript语言规范"></a>JavaScript语言规范</h2><h3 id="注释（注释是代码之母）"><a href="#注释（注释是代码之母）" class="headerlink" title="注释（注释是代码之母）"></a>注释（注释是代码之母）</h3><pre><code>// 这是单行注释/*这是  多行注释*/</code></pre><h3 id="结束符"><a href="#结束符" class="headerlink" title="结束符"></a>结束符</h3><p>JavaScript中的语句要以分号（;）为结束符。</p><h2 id="JavaScript语言基础"><a href="#JavaScript语言基础" class="headerlink" title="JavaScript语言基础"></a>JavaScript语言基础</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ol><li>JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。</li><li>声明变量使用 var 变量名; 的格式来进行声明</li></ol><pre><code>var name = &quot;Alex&quot;;var age = 18;</code></pre><p>注意：</p><p>变量名是区分大小写的。</p><p>推荐使用驼峰式命名规则。</p><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><p><strong>JavaScript拥有动态类型</strong></p><pre><code> var x;  // 此时x是undefinedvar x = 1;  // 此时x是数字var x = &quot;Alex&quot;  // 此时x是字符串 </code></pre><p><strong>数字类型</strong></p><p>JavaScript不区分整型和浮点型，就只有一种数字类型。</p><pre><code>var a = 12.34;var b = 20;var c = 123e5;  // 12300000var d = 123e-5;  // 0.00123</code></pre><p>还有一种NaN，表示不是一个数字（Not a Number）。</p><p>常用方法：</p><pre><code>parseInt(&quot;123&quot;)  // 返回123parseInt(&quot;ABC&quot;)  // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。parseFloat(&quot;123.456&quot;)  // 返回123.456</code></pre><p><strong>字符串</strong></p><pre><code> var a = &quot;Hello&quot;var b = &quot;world;var c = a + b; console.log(c);  // 得到Helloworld</code></pre><p>常用方法：</p><table><thead><tr><th>方法</th><th>说明  </th></tr></thead><tbody><tr><td>obj.length</td><td>返回长度  </td></tr><tr><td>obj.trim()</td><td>移除空白  </td></tr><tr><td>obj.trimLeft()</td><td>移除左边的空白  </td></tr><tr><td>obj.trimRight()</td><td>移除右边的空白  </td></tr><tr><td>obj.charAt(n)</td><td>返回第n个字符  </td></tr><tr><td>obj.concat(value, …)</td><td>拼接  </td></tr><tr><td>obj.indexOf(substring, start)</td><td>子序列位置  </td></tr><tr><td>obj.substring(from, to)</td><td>根据索引获取子序列  </td></tr><tr><td>obj.slice(start, end)</td><td>切片  </td></tr><tr><td>obj.toLowerCase()</td><td>小写  </td></tr><tr><td>obj.toUpperCase()</td><td>大写  </td></tr><tr><td>obj.split(delimiter, limit)</td><td>分割  </td></tr></tbody></table><p>拼接字符串一般使用”+”</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>区别于Python，true和false都是小写。</p><pre><code>var a = true;var b = false;</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>类似于Python中的列表。</p><pre><code>var a = [123, &quot;ABC&quot;];console.log(a[1]);  // 输出&quot;ABC&quot;</code></pre><p> 常用方法：</p><table><thead><tr><th>方法</th><th>说明  </th></tr></thead><tbody><tr><td>obj.length</td><td>数组的大小  </td></tr><tr><td>obj.push(ele)</td><td>尾部追加元素  </td></tr><tr><td>obj.pop()</td><td>获取尾部的元素  </td></tr><tr><td>obj.unshift(ele)</td><td>头部插入元素  </td></tr><tr><td>obj.shift()</td><td>头部移除元素  </td></tr><tr><td>obj.slice()</td><td>切片  </td></tr><tr><td>obj.reverse()</td><td>反转  </td></tr><tr><td>obj.join(seq)</td><td>将数组元素连接成字符串  </td></tr><tr><td>obj.concat(val, …)</td><td>连接数组  </td></tr><tr><td>obj.sort()</td><td>排序  </td></tr></tbody></table><p>遍历数组中的元素：</p><pre><code>var a = [10, 20, 30, 40];for (var i=0;i&lt;a.length;i++) {  console.log(i);}</code></pre><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><ul><li>null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null;</li><li>undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined。</li></ul><p>null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值。</p><p>还不明白，上图吧！</p><p><img src="https://images2018.cnblogs.com/blog/867021/201802/867021-20180226115608671-110898150.jpg" alt=""><img src="https://images2018.cnblogs.com/blog/867021/201802/867021-20180226114954211-338562205.jpg" alt=""></p><h3 id="类型查询"><a href="#类型查询" class="headerlink" title="类型查询"></a>类型查询</h3><pre><code>typeof &quot;abc&quot;  // &quot;string&quot;typeof null  // &quot;object&quot;typeof true  // &quot;boolean&quot;typeof 123 // &quot;number&quot;</code></pre><p>typeof是一个一元运算符（就像++，–，！，- 等一元运算符），不是一个函数，也不是一个语句。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><pre><code>+ - * / % ++ --</code></pre><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h3><pre><code>&gt; &gt;= &lt; &lt;= != == === !==</code></pre><p>注意：</p><pre><code>1 == &quot;1&quot;  // true1 === &quot;1&quot;  // false</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h3><pre><code>&amp;&amp; || !</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h3><pre><code>= += -= *= /=</code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><pre><code> var a = 10;if (a &gt; 5){  console.log(&quot;yes&quot;);}else {  console.log(&quot;no&quot;);}</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if-else if-else"></a>if-else if-else</h3><pre><code>var a = 10;if (a &gt; 5){  console.log(&quot;a &gt; 5&quot;);}else if (a &lt; 5) {  console.log(&quot;a &lt; 5&quot;);}else {  console.log(&quot;a = 5&quot;);}</code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><pre><code>var day = new Date().getDay();switch (day) {  case 0:  console.log(&quot;Sunday&quot;);  break;  case 1:  console.log(&quot;Monday&quot;);  break;default:  console.log(&quot;...&quot;)}</code></pre><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre><code>for (var i=0;i&lt;10;i++) {  console.log(i);}</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code>var i = 0;while (i &lt; 10) {  console.log(i);  i++;}</code></pre><h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><pre><code>var a = 1;var b = 2;var c = a &gt; b ? a : b</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>JavaScript中的函数和Python中的非常类似，只是定义方式有点区别。</p><pre><code>// 普通函数定义function f1() {  console.log(&quot;Hello world!&quot;);}// 带参数的函数function f2(a, b) {  console.log(arguments);  // 内置的arguments对象  console.log(arguments.length);  console.log(a, b);}// 带返回值的函数function sum(a, b){  return a + b;}sum(1, 2);  // 调用函数// 匿名函数方式var sum = function(a, b){  return a + b;}sum(1, 2);// 立即执行函数(function(a, b){  return a + b;})(1, 2);</code></pre><h3 id="函数的全局变量和局部变量"><a href="#函数的全局变量和局部变量" class="headerlink" title="函数的全局变量和局部变量"></a>函数的全局变量和局部变量</h3><p><strong>局部变量</strong> ：</p><p>在JavaScript函数内部声明的变量（使用<br>var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。只要函数运行完毕，本地变量就会被删除。</p><p><strong>全局变量：</strong></p><p>在函数外声明的变量是 _全局_ 变量，网页上的所有脚本和函数都能访问它。</p><p><strong>变量生存周期：</strong></p><p>JavaScript变量的生命期从它们被声明的时间开始。</p><p>局部变量会在函数运行以后被删除。</p><p>全局变量会在页面关闭后被删除。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层。</p><p><strong>几个例子：</strong></p><p>1.</p><pre><code>var city = &quot;BeiJing&quot;;function f() {  var city = &quot;ShangHai&quot;;  function inner(){    var city = &quot;ShenZhen&quot;;    console.log(city);  }  inner();}f();  //输出结果是？</code></pre><p>2.</p><pre><code>var city = &quot;BeiJing&quot;;function Bar() {  console.log(city);}function f() {  var city = &quot;ShangHai&quot;;  return Bar;}var ret = f();ret();  // 打印结果是？</code></pre><p>3.闭包</p><pre><code>var city = &quot;BeiJing&quot;;function f(){    var city = &quot;ShangHai&quot;;    function inner(){        console.log(city);    }    return inner;}var ret = f();ret();</code></pre><h2 id="内置对象和方法"><a href="#内置对象和方法" class="headerlink" title="内置对象和方法"></a>内置对象和方法</h2><p>JavaScript中的所有事物都是对象：字符串、数字、数组、日期，等等。在JavaScript中，对象是拥有属性和方法的数据。</p><p>我们在学习基本数据类型的时候已经带大家了解了，JavaScript中的Number对象、String对象、Array对象等。</p><h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h3><p>类似于（某方面类似）Python中的字典数据类型</p><pre><code>var a = {&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18};console.log(a.name);console.log(a[&quot;age&quot;]);</code></pre><p>遍历对象中的内容：</p><pre><code>var a = {&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18};for (var i in a){  console.log(i, a[i]);}</code></pre><p><a href="https://stackoverflow.com/questions/684672/how-do-i-loop-through-or-enumerate-a-javascript-object" target="_blank" rel="noopener">事情并没有那么简单…</a></p><p><strong>创建对象：</strong></p><pre><code> var person=new Object();  // 创建一个person对象person.name=&quot;Alex&quot;;  // person对象的name属性person.age=18;  // person对象的age属性</code></pre><p><strong>  扩展：</strong></p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>// 父类构造函数var Car = function (loc) {  this.loc = loc;};// 父类方法Car.prototype.move = function () {  this.loc ++;};// 子类构造函数var Van = function (loc) {  Car.call(this, loc);};// 继承父类的方法Van.prototype = Object.create(Car.prototype);// 修复 constructorVan.prototype.constructor = Van;// 扩展方法Van.prototype.grab = function () {  /* ... */};</code></pre><p>JavaScript面向对象之继承</p><h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><p><strong>创建Date对象</strong></p><pre><code> //方法1：不指定参数var d1 = new Date();console.log(d1.toLocaleString());//方法2：参数为日期字符串var d2 = new Date(&quot;2004/3/20 11:12&quot;);console.log(d2.toLocaleString());var d3 = new Date(&quot;04/03/20 11:12&quot;);console.log(d3.toLocaleString());//方法3：参数为毫秒数var d3 = new Date(5000);console.log(d3.toLocaleString());console.log(d3.toUTCString());//方法4：参数为年月日小时分钟秒毫秒var d4 = new Date(2004,2,20,11,12,0,300);console.log(d4.toLocaleString());  //毫秒并不直接显示</code></pre><p><strong>Date对象的方法：</strong></p><pre><code> var d = new Date(); //getDate()                 获取日//getDay ()                 获取星期//getMonth ()               获取月（0-11）//getFullYear ()            获取完整年份//getYear ()                获取年//getHours ()               获取小时//getMinutes ()             获取分钟//getSeconds ()             获取秒//getMilliseconds ()        获取毫秒//getTime ()                返回累计毫秒数(从1970/1/1午夜)</code></pre><p><strong>练习：</strong></p><p>编写代码，将当前日期按”2017-12-27 11:11 星期三”格式输出。</p><p>详细Date对象方法：<a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp" target="_blank" rel="noopener">点我</a></p><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><pre><code>var str1 = &apos;{&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18}&apos;;var obj1 = {&quot;name&quot;: &quot;Alex&quot;, &quot;age&quot;: 18};// JSON字符串转换成对象var obj = JSON.parse(str1); // 对象转换成JSON字符串var str = JSON.stringify(obj1);</code></pre><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>//RegExp对象//创建正则对象方式1// 参数1 正则表达式(不能有空格)// 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写)// 用户名只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。// 创建RegExp对象方式（逗号后面不要加空格）var reg1 = new RegExp(&quot;^[a-zA-Z][a-zA-Z0-9_]{5,11}$&quot;);// 匹配响应的字符串var s1 = &quot;bc123&quot;;//RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。reg1.test(s1);  // true// 创建方式2// /填写正则表达式/匹配模式（逗号后面不要加空格）var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/;reg2.test(s1);  // true// String对象与正则结合的4个方法var s2 = &quot;hello world&quot;;s2.match(/o/g);         // [&quot;o&quot;, &quot;o&quot;]             查找字符串中 符合正则 的内容s2.search(/h/g);        // 0                      查找字符串中符合正则表达式的内容位置s2.split(/o/g);         // [&quot;hell&quot;, &quot; w&quot;, &quot;rld&quot;]  按照正则表达式对字符串进行切割s2.replace(/o/g, &quot;s&quot;);  // &quot;hells wsrld&quot;          对字符串按照正则进行替换// 关于匹配模式：g和i的简单示例var s1 = &quot;name:Alex age:18&quot;;s1.replace(/a/, &quot;哈哈哈&quot;);      // &quot;n哈哈哈me:Alex age:18&quot;s1.replace(/a/g, &quot;哈哈哈&quot;);     // &quot;n哈哈哈me:Alex 哈哈哈ge:18&quot;      全局匹配s1.replace(/a/gi, &quot;哈哈哈&quot;);    // &quot;n哈哈哈me:哈哈哈lex 哈哈哈ge:18&quot;  不区分大小写// 注意事项1：// 如果regExpObject带有全局标志g，test()函数不是从字符串的开头开始查找，而是从属性regExpObject.lastIndex所指定的索引处开始查找。// 该属性值默认为0，所以第一次仍然是从字符串的开头查找。// 当找到一个匹配时，test()函数会将regExpObject.lastIndex的值改为字符串中本次匹配内容的最后一个字符的下一个索引位置。// 当再次执行test()函数时，将会从该索引位置处开始查找，从而找到下一个匹配。// 因此，当我们使用test()函数执行了一次匹配之后，如果想要重新使用test()函数从头开始查找，则需要手动将regExpObject.lastIndex的值重置为 0。// 如果test()函数再也找不到可以匹配的文本时，该函数会自动把regExpObject.lastIndex属性重置为 0。var reg3 = /foo/g;// 此时 regex.lastIndex=0reg3.test(&apos;foo&apos;); // 返回true// 此时 regex.lastIndex=3reg3.test(&apos;foo&apos;); // 返回false// 所以我们在使用test()方法校验一个字符串是否完全匹配时，不推荐添加全局匹配模式g。// 注意事项2(说出来你可能不信系列)：// 当我们不加参数调用RegExpObj.test()方法时, 相当于执行RegExpObj.test(&quot;undefined&quot;), 并且/undefined/.test()默认返回true。var reg4 = /^undefined$/;reg4.test(); // 返回truereg4.test(undefined); // 返回truereg4.test(&quot;undefined&quot;); // 返回true</code></pre><p>RegExp</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="noopener">扩展阅读</a></p><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>abs(x)      返回数的绝对值。exp(x)      返回 e 的指数。floor(x)    对数进行下舍入。log(x)      返回数的自然对数（底为e）。max(x,y)    返回 x 和 y 中的最高值。min(x,y)    返回 x 和 y 中的最低值。pow(x,y)    返回 x 的 y 次幂。random()    返回 0 ~ 1 之间的随机数。round(x)    把数四舍五入为最接近的整数。sin(x)      返回数的正弦。sqrt(x)     返回数的平方根。tan(x)      返回角的正切。</code></pre><p>Math</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端基础之CSS</title>
      <link href="/2018/03/08/cnblog_8527496/"/>
      <url>/2018/03/08/cnblog_8527496/</url>
      <content type="html"><![CDATA[<h1 id="这是👉前端基础之CSS👈的摘要"><a href="#这是👉前端基础之CSS👈的摘要" class="headerlink" title="这是👉前端基础之CSS👈的摘要"></a><a href="/2018/03/08/cnblog_8527496/">这是👉前端基础之CSS👈的摘要</a></h1><a id="more"></a><h1 id=""><a href="#" class="headerlink" title=""></a><a href="http://www.cnblogs.com/liwenzhou/p/7999532.html" target="_blank" rel="noopener"></a></h1><h1 id="CSS介绍"><a href="#CSS介绍" class="headerlink" title="CSS介绍"></a>CSS介绍</h1><p>CSS（ <strong>C</strong> ascading <strong>S</strong> tyle <strong>S</strong> heet，层叠样式表)定义 <strong>如何显示</strong> HTML元素。</p><p>当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。</p><h1 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h1><h2 id="CSS实例"><a href="#CSS实例" class="headerlink" title="CSS实例"></a>CSS实例</h2><p>每个CSS样式由两个组成部分：选择器和声明。声明又包括属性和属性值。每个声明之后用分号结束。</p><p><img src="https://images2017.cnblogs.com/blog/867021/201712/867021-20171215115756808-909989248.png" alt=""></p><h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h2><pre><code>/*这是注释*/</code></pre><p>注释是代码之母。–摘自哪吒语录</p><h1 id="CSS的几种引入方式"><a href="#CSS的几种引入方式" class="headerlink" title="CSS的几种引入方式"></a>CSS的几种引入方式</h1><h2 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h2><p>行内式是在标记的style属性中设定CSS样式。不推荐大规模使用。</p><pre><code>&lt;p style=&quot;color: red&quot;&gt;Hello world.&lt;/p&gt;</code></pre><h2 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h2><p>嵌入式是将CSS样式集中写在网页的<head></head>标签对的<style></style>标签对中。格式如下：</p><pre><code>&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        p{            background-color: #2b99ff;        }    &lt;/style&gt;&lt;/head&gt;</code></pre><h2 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h2><p>外部样式就是将css写在一个单独的文件中，然后在页面进行引入即可。推荐使用此方式。</p><pre><code>&lt;link href=&quot;mystyle.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</code></pre><h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><pre><code>p {color: &quot;red&quot;;}</code></pre><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><pre><code>#i1 {  background-color: red;}</code></pre><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><pre><code>.c1 {  font-size: 14px;}  p.c1 {    color: red;  }</code></pre><p>注意：</p><p>样式类名不要用数字开头（有的浏览器不认）。</p><p>标签中的class属性如果有多个，要用空格分隔。</p><h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><pre><code>* {  color: white;}</code></pre><h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><pre><code>/*li内部的a标签设置字体颜色*/li a {  color: green;}</code></pre><h3 id="儿子选择器"><a href="#儿子选择器" class="headerlink" title="儿子选择器"></a>儿子选择器</h3><pre><code>/*选择所有父级是 &lt;div&gt; 元素的 &lt;p&gt; 元素*/div&gt;p {  font-family: &quot;Arial Black&quot;, arial-black, cursive;}</code></pre><h3 id="毗邻选择器"><a href="#毗邻选择器" class="headerlink" title="毗邻选择器"></a>毗邻选择器</h3><pre><code>/*选择所有紧接着&lt;div&gt;元素之后的&lt;p&gt;元素*/div+p {  margin: 5px;}</code></pre><h3 id="弟弟选择器"><a href="#弟弟选择器" class="headerlink" title="弟弟选择器"></a>弟弟选择器</h3><pre><code>/*i1后面所有的兄弟p标签*/#i1~p {  border: 2px solid royalblue;}</code></pre><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><pre><code>/*用于选取带有指定属性的元素。*/p[title] {  color: red;}/*用于选取带有指定属性和值的元素。*/p[title=&quot;213&quot;] {  color: green;}  </code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>/*找到所有title属性以hello开头的元素*/[title^=&quot;hello&quot;] {  color: red;}/*找到所有title属性以hello结尾的元素*/[title$=&quot;hello&quot;] {  color: yellow;}/*找到所有title属性中包含（字符串包含）hello的元素*/[title*=&quot;hello&quot;] {  color: red;}/*找到所有title属性(有多个值或值以空格分割)中有一个值为hello的元素：*/[title~=&quot;hello&quot;] {  color: green;}</code></pre><p>不怎么常用的属性选择器</p><h2 id="分组和嵌套"><a href="#分组和嵌套" class="headerlink" title="分组和嵌套"></a>分组和嵌套</h2><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>当多个元素的样式相同的时候，我们没有必要重复地为每个元素都设置样式，我们可以通过在多个选择器之间使用逗号分隔的分组选择器来统一设置元素样式。</p><p>例如：</p><pre><code>div, p {  color: red;}</code></pre><p>上面的代码为div标签和p标签统一设置字体为红色。</p><p>通常，我们会分两行来写，更清晰:</p><pre><code>div,p {  color: red;}</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>多种选择器可以混合起来使用，比如：.c1类内部所有p标签设置字体颜色为红色。</p><pre><code>.c1 p {  color: red;}</code></pre><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><pre><code>/* 未访问的链接 */a:link {  color: #FF0000}/* 已访问的链接 */a:visited {  color: #00FF00} /* 鼠标移动到链接上 */a:hover {  color: #FF00FF} /* 选定的链接 */ a:active {  color: #0000FF}/*input输入框获取焦点时样式*/input:focus {  outline: none;  background-color: #eee;</code></pre><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><h3 id="first-letter"><a href="#first-letter" class="headerlink" title="first-letter"></a>first-letter</h3><p>常用的给首字母设置特殊样式：</p><pre><code>p:first-letter {  font-size: 48px;  color: red;}</code></pre><h3 id="before"><a href="#before" class="headerlink" title="before"></a>before</h3><pre><code>/*在每个&lt;p&gt;元素之前插入内容*/p:before {  content:&quot;*&quot;;  color:red;}</code></pre><h3 id="after"><a href="#after" class="headerlink" title="after"></a>after</h3><pre><code>/*在每个&lt;p&gt;元素之后插入内容*/p:after {  content:&quot;[?]&quot;;  color:blue;} </code></pre><p>before和after多用于清除浮动。</p><h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><h3 id="CSS继承"><a href="#CSS继承" class="headerlink" title="CSS继承"></a>CSS继承</h3><p>继承是CSS的一个主要特征，它是依赖于祖先-<br>后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个body定义了的字体颜色值也会应用到段落的文本中。</p><pre><code>body {  color: red;}</code></pre><p>此时页面上所有标签都会继承body的字体颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。</p><p>我们只要给对应的标签设置字体颜色就可覆盖掉它继承的样式。</p><pre><code>p {  color: green;}</code></pre><p>此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin,<br>padding, background等。</p><h3 id="选择器的优先级-1"><a href="#选择器的优先级-1" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h3><p>我们上面学了很多的选择器，也就是说在一个HTML页面中有很多种方式找到一个元素并且为其设置样式，那浏览器根据什么来决定应该应用哪个样式呢？</p><p>其实是按照不同选择器的权重来决定的，具体的选择器权重计算方式如下图：</p><p><img src="https://images2018.cnblogs.com/blog/867021/201803/867021-20180305155201408-1680872107.png" alt=""></p><p>除此之外还可以通过添加 !import方式来强制让样式生效，但并不推荐使用。因为如果过多的使用!import会使样式文件混乱不易维护。</p><p><em>万不得已可以使用!import</em></p><h1 id="CSS属性相关"><a href="#CSS属性相关" class="headerlink" title="CSS属性相关"></a>CSS属性相关</h1><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><h3 id="文字字体"><a href="#文字字体" class="headerlink" title="文字字体"></a>文字字体</h3><p>font-family可以把多个字体名称作为一个”回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。浏览器会使用它可识别的第一个值。</p><p>简单实例：</p><pre><code>body {  font-family: &quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;, &quot;Arial&quot;, sans-serif}</code></pre><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><pre><code>p {  font-size: 14px;}</code></pre><p>如果设置成inherit表示继承父元素的字体大小值。</p><h3 id="字重（粗细）"><a href="#字重（粗细）" class="headerlink" title="字重（粗细）"></a>字重（粗细）</h3><p>font-weight用来设置字体的字重（粗细）。</p><table><thead><tr><th>值</th><th>描述  </th></tr></thead><tbody><tr><td>normal</td><td>默认值，标准粗细  </td></tr><tr><td>bold</td><td>粗体  </td></tr><tr><td>bolder</td><td>更粗  </td></tr><tr><td>lighter</td><td>更细  </td></tr><tr><td>100~900</td><td>设置具体粗细，400等同于normal，而700等同于bold  </td></tr><tr><td>inherit</td><td>继承父元素字体的粗细值  </td></tr></tbody></table><h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><p>颜色属性被用来设置文字的颜色。</p><p>颜色是通过CSS最经常的指定：</p><ul><li>十六进制值 - 如:  <strong>＃</strong> FF0000</li><li>一个RGB值 - 如: RGB(255,0,0)</li><li>颜色的名称 - 如:  red</li></ul><p>还有rgba(255,0,0,0.3)，第四个值为alpha, 指定了色彩的透明度/不透明度，它的范围为0.0到1.0之间。</p><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><h3 id="文字对齐"><a href="#文字对齐" class="headerlink" title="文字对齐"></a>文字对齐</h3><p>text-align 属性规定元素中的文本的水平对齐方式。</p><table><thead><tr><th>值</th><th>描述  </th></tr></thead><tbody><tr><td>left</td><td>左边对齐 默认值  </td></tr><tr><td>right</td><td>右对齐  </td></tr><tr><td>center</td><td>居中对齐  </td></tr><tr><td>justify</td><td>两端对齐  </td></tr></tbody></table><h3 id="文字装饰"><a href="#文字装饰" class="headerlink" title="文字装饰"></a>文字装饰</h3><p>text-decoration 属性用来给文字添加特殊效果。</p><table><thead><tr><th>值</th><th>描述  </th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。  </td></tr><tr><td>underline</td><td>定义文本下的一条线。  </td></tr><tr><td>overline</td><td>定义文本上的一条线。  </td></tr><tr><td>line-through</td><td>定义穿过文本下的一条线。  </td></tr><tr><td>inherit</td><td>继承父元素的text-decoration属性的值。  </td></tr></tbody></table><p>常用的为去掉a标签默认的自划线：</p><pre><code>a {  text-decoration: none;}</code></pre><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p>将段落的第一行缩进 32像素：</p><pre><code>p {  text-indent: 32px;}</code></pre><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><pre><code>/*背景颜色*/  background-color: red;/*背景图片*/background-image: url(&apos;1.jpg&apos;);  /*   背景重复   repeat(默认):背景图片平铺排满整个网页   repeat-x：背景图片只在水平方向上平铺   repeat-y：背景图片只在垂直方向上平铺   no-repeat：背景图片不平铺  */background-repeat: no-repeat; /*背景位置*/background-position: right top（20px 20px）;</code></pre><p>支持简写：</p><pre><code>background:#ffffff url(&apos;1.png&apos;) no-repeat right top;</code></pre><p>使用背景图片的一个常见案例就是很多网站会把很多小图标放在一张图片上，然后根据位置去显示图片。减少频繁的图片请求。</p><p><a href="http://www.w3school.com.cn/css/css_background.asp" target="_blank" rel="noopener"> 参考链接点我</a></p><p>一个有趣的例子：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;滚动背景图示例&lt;/title&gt;    &lt;style&gt;        * {            margin: 0;        }        .box {            width: 100%;            height: 500px;            background: url(&quot;https://www.luffycity.com/static/img/width-bank.1c9d1b0.png&quot;) no-repeat center center;            background-attachment: fixed;        }        .d1 {            height: 500px;            background-color: tomato;        }        .d2 {            height: 500px;            background-color: steelblue;        }        .d3 {            height: 500px;            background-color: mediumorchid;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;d1&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;d2&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;d3&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>鼠标滚动背景不动</p><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>边框属性</p><ul><li>border-width</li><li>border-style</li><li>border-color</li></ul><pre><code>#i1 {  border-width: 2px;  border-style: solid;  border-color: red;}</code></pre><p>通常使用简写方式：</p><pre><code>#i1 {  border: 2px solid red;}</code></pre><p>边框样式</p><table><thead><tr><th>值</th><th>描述  </th></tr></thead><tbody><tr><td>none</td><td>无边框。  </td></tr><tr><td>dotted</td><td>点状虚线边框。  </td></tr><tr><td>dashed</td><td>矩形虚线边框。  </td></tr><tr><td>solid</td><td>实线边框。  </td></tr></tbody></table><p>除了可以统一设置边框外还可以单独为某一个边框设置样式，如下所示：</p><pre><code>#i1 {  border-top-style:dotted;  border-top-color: red;  border-right-style:solid;  border-bottom-style:dotted;  border-left-style:none;}</code></pre><h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><p>用于控制HTML元素的显示效果。</p><table><thead><tr><th>值</th><th>意义  </th></tr></thead><tbody><tr><td>display:”none”</td><td>HTML文档中元素存在，但是在浏览器中不显示。一般用于配合JavaScript代码使用。  </td></tr><tr><td>display:”block”</td><td>默认占满整个页面宽度，如果设置了指定宽度，则会用margin填充剩下的部分。  </td></tr><tr><td>display:”inline”</td><td>按行内元素显示，此时再设置元素的width、height、margin-top、margin-</td></tr></tbody></table><p>bottom和float属性都不会有什么影响。<br>display:”inline-block” | 使元素同时具有行内元素和块级元素的特点。  </p><p><strong>display:”none”与visibility:hidden的区别：</strong></p><p>visibility:hidden: 可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。</p><p>display:none: 可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。</p><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><ul><li><strong>margin</strong> :            用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。</li><li><strong>padding</strong> :           用于控制内容与边框之间的距离；   </li><li><strong>Border</strong> (边框):     围绕在内边距和内容外的边框。</li><li><strong>Content</strong> (内容):   盒子的内容，显示文本和图像。</li></ul><p>看图吧：</p><p><img src="https://images2018.cnblogs.com/blog/867021/201803/867021-20180305155247808-885981996.png" alt=""></p><h2 id="margin外边距"><a href="#margin外边距" class="headerlink" title="margin外边距"></a>margin外边距</h2><pre><code>.margin-test {  margin-top:5px;  margin-right:10px;  margin-bottom:15px;  margin-left:20px;}</code></pre><p>推荐使用简写：</p><pre><code>.margin-test {  margin: 5px 10px 15px 20px;}</code></pre><p>顺序：上右下左</p><p>常见居中：</p><pre><code>.mycenter {  margin: 0 auto;}</code></pre><h2 id="padding内填充"><a href="#padding内填充" class="headerlink" title="padding内填充"></a>padding内填充</h2><pre><code>.padding-test {  padding-top: 5px;  padding-right: 10px;  padding-bottom: 15px;  padding-left: 20px;}</code></pre><p>推荐使用简写：</p><pre><code>.padding-test {  padding: 5px 10px 15px 20px;}</code></pre><p>顺序：上右下左</p><p>补充padding的常用简写方式：</p><ul><li>提供一个，用于四边；</li><li>提供两个，第一个用于上－下，第二个用于左－右；</li><li>如果提供三个，第一个用于上，第二个用于左－右，第三个用于下；</li><li>提供四个参数值，将按上－右－下－左的顺序作用于四边；</li></ul><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>在 CSS 中，任何元素都可以浮动。</p><p>浮动元素会生成一个块级框，而不论它本身是何种元素。</p><p>关于浮动的两个特点：</p><ul><li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li><li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</li></ul><h3 id="三种取值"><a href="#三种取值" class="headerlink" title="三种取值"></a>三种取值</h3><p>left：向左浮动</p><p>right：向右浮动</p><p>none：默认值，不浮动</p><p><a href="http://www.w3school.com.cn/css/css_positioning_floating.asp" target="_blank" rel="noopener">参考示例</a></p><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>clear属性规定元素的哪一侧不允许其他浮动元素。</p><table><thead><tr><th>值</th><th>描述  </th></tr></thead><tbody><tr><td>left</td><td>在左侧不允许浮动元素。  </td></tr><tr><td>right</td><td>在右侧不允许浮动元素。  </td></tr><tr><td>both</td><td>在左右两侧均不允许浮动元素。  </td></tr><tr><td>none</td><td>默认值。允许浮动元素出现在两侧。  </td></tr><tr><td>inherit</td><td>规定应该从父元素继承 clear 属性的值。  </td></tr></tbody></table><p>注意：clear属性只会对 <strong>自身</strong> 起作用，而不会影响其他元素。</p><h3 id="父标签塌陷问题"><a href="#父标签塌陷问题" class="headerlink" title="父标签塌陷问题"></a>父标签塌陷问题</h3><pre><code>.clearfix:after {  content: &quot;&quot;;  display: block;  clear: both;}</code></pre><h2 id="overflow溢出属性"><a href="#overflow溢出属性" class="headerlink" title="overflow溢出属性"></a>overflow溢出属性</h2><table><thead><tr><th>值</th><th>描述  </th></tr></thead><tbody><tr><td>visible</td><td>默认值。内容不会被修剪，会呈现在元素框之外。  </td></tr><tr><td>hidden</td><td>内容会被修剪，并且其余内容是不可见的。  </td></tr><tr><td>scroll</td><td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。  </td></tr><tr><td>auto</td><td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。  </td></tr><tr><td>inherit</td><td>规定应该从父元素继承 overflow 属性的值。  </td></tr></tbody></table><ul><li>overflow（水平和垂直均设置）</li><li>overflow-x（设置水平方向）</li><li>overflow-y（设置垂直方向）</li></ul><h2 id="定位（position）"><a href="#定位（position）" class="headerlink" title="定位（position）"></a>定位（position）</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。</p><h3 id="relative（相对定位）"><a href="#relative（相对定位）" class="headerlink" title="relative（相对定位）"></a>relative（相对定位）</h3><p>相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-<br>index属性定义。</p><p>注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。</p><h3 id="absolute（绝对定位）"><a href="#absolute（绝对定位）" class="headerlink" title="absolute（绝对定位）"></a>absolute（绝对定位）</h3><p>定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</p><p>重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。</p><p>另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。</p><h3 id="fixed（固定）"><a href="#fixed（固定）" class="headerlink" title="fixed（固定）"></a>fixed（固定）</h3><p>fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-<br>index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这<br>是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是”定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。</p><p>在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。</p><p>示例代码：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;返回顶部示例&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;    }    .d1 {      height: 1000px;      background-color: #eeee;    }    .scrollTop {      background-color: darkgrey;      padding: 10px;      text-align: center;      position: fixed;      right: 10px;      bottom: 20px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;d1&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;scrollTop&quot;&gt;返回顶部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>返回顶部按钮样式示例</p><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><pre><code>#i2 {  z-index: 999;}</code></pre><p>设置对象的层叠顺序，数值大的会覆盖在数值小的标签之上。z-index 仅能在定位元素上奏效。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;自定义模态框&lt;/title&gt;  &lt;style&gt;    .cover {      background-color: rgba(0,0,0,0.65);      position: fixed;      top: 0;      right: 0;      bottom: 0;      left: 0;      z-index: 998;    }    .modal {      background-color: white;      position: fixed;      width: 600px;      height: 400px;      left: 50%;      top: 50%;      margin: -200px 0 0 -300px;      z-index: 1000;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;cover&quot;&gt;&lt;/div&gt;&lt;div class=&quot;modal&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>自定义模态框示例</p><h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h2><p>用来定义透明效果。取值范围是0~1，0是完全透明，1是完全不透明。</p><h1 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h1><h2 id="顶部导航菜单"><a href="#顶部导航菜单" class="headerlink" title="顶部导航菜单"></a>顶部导航菜单</h2><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;li标签的float示例&lt;/title&gt;  &lt;style&gt;    /*清除浏览器默认外边距和内填充*/    * {      margin: 0;      padding: 0;    }    a {      text-decoration: none; /*去除a标签默认的下划线*/    }    .nav {      background-color: black;      height: 40px;      width: 100%;      position: fixed;      top: 0;    }    ul {      list-style-type: none; /*删除列表默认的圆点样式*/      margin: 0; /*删除列表默认的外边距*/      padding: 0; /*删除列表默认的内填充*/    }    /*li元素向左浮动*/    li {      float: left;    }    li &gt; a {      display: block; /*让链接显示为块级标签*/      padding: 0 15px; /*设置左右各15像素的填充*/      color: #b0b0b0; /*设置字体颜色*/      line-height: 40px; /*设置行高*/    }    /*鼠标移上去颜色变白*/    li &gt; a:hover {      color: #fff;    }    /*清除浮动 解决父级塌陷问题*/    .clearfix:after {      content: &quot;&quot;;      display: block;      clear: both;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 顶部导航栏 开始 --&gt;&lt;div class=&quot;nav&quot;&gt;  &lt;ul class=&quot;clearfix&quot;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;玉米商城&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;MIUI&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;ioT&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;云服务&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;水滴&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;金融&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;优品&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;!-- 顶部导航栏 结束 --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>顶部导航菜单示例</p><h2 id="圆形头像"><a href="#圆形头像" class="headerlink" title="圆形头像"></a>圆形头像</h2><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;圆形的头像示例&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;      padding: 0;      background-color: #eeeeee;    }    .header-img {      width: 150px;      height: 150px;      border: 3px solid white;      border-radius: 100%;      overflow: hidden;    }    .header-img&gt;img {      max-width: 100%;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;header-img&quot;&gt;  &lt;img src=&quot;https://q1mi.github.io/Blog/asset/img/head_img.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>圆形头像图示例</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端知识之HTML内容</title>
      <link href="/2018/03/05/cnblog_8508917/"/>
      <url>/2018/03/05/cnblog_8508917/</url>
      <content type="html"><![CDATA[<h1 id="这是👉前端知识之HTML内容👈的摘要"><a href="#这是👉前端知识之HTML内容👈的摘要" class="headerlink" title="这是👉前端知识之HTML内容👈的摘要"></a><a href="/2018/03/05/cnblog_8508917/">这是👉前端知识之HTML内容👈的摘要</a></h1><a id="more"></a><h1 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h1><h2 id="Web服务本质"><a href="#Web服务本质" class="headerlink" title="Web服务本质"></a>Web服务本质</h2><pre><code>import socketsk = socket.socket()sk.bind((&quot;127.0.0.1&quot;, 8080))sk.listen(5)while True:    conn, addr = sk.accept()    data = conn.recv(8096)    conn.send(b&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)    conn.secd(b&quot;&lt;h1&gt;Hello world!&lt;/h1&gt;&quot;)    conn.close()</code></pre><p>浏览器发请求 –&gt; HTTP协议 –&gt; 服务端接收请求 –&gt; 服务端返回响应 –&gt; 服务端把HTML文件内容发给浏览器 –&gt; 浏览器渲染页面</p><h2 id="HTML是什么？"><a href="#HTML是什么？" class="headerlink" title="HTML是什么？"></a>HTML是什么？</h2><ul><li>超文本标记语言（Hypertext Markup Language, HTML）是一种用于创建网页的标记语言。</li><li>本质上是浏览器可识别的规则，我们按照规则写网页，浏览器根据规则渲染我们的网页。对于不同的浏览器，对同一个标签可能会有不同的解释。（兼容性问题）</li><li>网页文件的扩展名：.html或.htm</li></ul><h2 id="HTML不是什么？"><a href="#HTML不是什么？" class="headerlink" title="HTML不是什么？"></a>HTML不是什么？</h2><p>HTML是一种标记语言（markup language），它不是一种编程语言。</p><p>HTML使用标签来描述网页。</p><p><img src="https://images2017.cnblogs.com/blog/867021/201712/867021-20171206155335159-1559665689.png" alt=""></p><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><p>最基本的HTML文档：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;css样式优先级&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol><li>&lt;!DOCTYPE html&gt;声明为HTML5文档。</li><li><html>、</html>是文档的开始标记和结束的标记。是HTML页面的根元素，在它们之间是文档的头部（head）和主体（body）。</li><li><head>、</head>定义了HTML文档的开头部分。它们之间的内容不会在浏览器的文档窗口显示。包含了文档的元（meta）数据。</li><li><title>、</title>定义了网页标题，在浏览器标题栏显示。</li><li><body>、</body>之间的文本是可见的网页主体内容。</li></ol><p><em><strong>注意：</strong> 对于中文网页需要使用  <strong>&lt; meta charset=”utf-8”&gt;</strong> 声明编码，否则会出现乱码。有些浏览器会设置 GBK<br>为默认编码，则你需要设置为  <strong>&lt; meta charset=”gbk”&gt;。</strong></em></p><h2 id="HTML标签格式"><a href="#HTML标签格式" class="headerlink" title="HTML标签格式"></a>HTML标签格式</h2><ul><li>HTML标签是由尖括号包围的关键字，如<html>, <div>等</div></html></li><li>HTML标签通常是成对出现的，比如：<div>和</div>，第一个标签是开始，第二个标签是结束。结束标签会有斜线。</li><li>也有一部分标签是单独呈现的，比如：<br>、<hr>、<img src="/2018/03/05/cnblog_8508917/1.jpg">等。</li><li>标签里面可以有若干属性，也可以不带属性。</li></ul><p><strong>标签的语法：</strong></p><ul><li>&lt;标签名 属性1=”属性值1” 属性2=”属性值2”……&gt;内容部分&lt;/标签名&gt;</li><li>&lt;标签名 属性1=”属性值1” 属性2=”属性值2”…… /&gt;</li></ul><p><strong>几个很重要的属性：</strong></p><ul><li>id：定义标签的唯一ID，HTML文档树中唯一</li><li>class：为html元素定义一个或多个类名（classname）(CSS样式类名)</li><li>style：规定元素的行内样式（CSS样式）</li></ul><h2 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h2><pre><code>&lt;!--注释内容--&gt;</code></pre><p>注释是代码之母.</p><h2 id="lt-DOCTYPE-gt-标签"><a href="#lt-DOCTYPE-gt-标签" class="headerlink" title="&lt;!DOCTYPE&gt; 标签"></a>&lt;!DOCTYPE&gt; 标签</h2><p>&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 <html> 标签之前。</html></p><p>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p><h1 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h1><h2 id="head内常用标签"><a href="#head内常用标签" class="headerlink" title="head内常用标签"></a>head内常用标签</h2><table><thead><tr><th>标签</th><th>意义  </th></tr></thead><tbody><tr><td><title></title></td><td>定义网页标题  </td></tr><tr><td><style></style></td><td>定义内部样式表  </td></tr><tr><td><script></script></td><td>定义JS代码或引入外部JS文件  </td></tr><tr><td><link></td><td>引入外部样式表文件  </td></tr><tr><td><meta></td><td>定义网页原信息  </td></tr></tbody></table><h3 id="Meta标签"><a href="#Meta标签" class="headerlink" title="Meta标签"></a>Meta标签</h3><p>Meta标签介绍：</p><ul><li><meta>元素可提供有关页面的原信息（mata-information）,针对搜索引擎和更新频度的描述和关键词。</li><li><meta>标签位于文档的头部，不包含任何内容。</li><li><meta>提供的信息是用户不可见的。</li></ul><p>meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name<br>属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p><p>1.http-<br>equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。</p><pre><code>&lt;!--2秒后跳转到对应的网址，注意引号--&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2;URL=https://www.oldboyedu.com&quot;&gt;&lt;!--指定文档的编码类型--&gt;&lt;meta http-equiv=&quot;content-Type&quot; charset=UTF8&quot;&gt;&lt;!--告诉IE以最高级模式渲染文档--&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;</code></pre><p>2.name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p><pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;meta总结,html meta,meta属性,meta跳转&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;老男孩教育Python学院&quot;&gt;</code></pre><h2 id="body内常用标签"><a href="#body内常用标签" class="headerlink" title="body内常用标签"></a>body内常用标签</h2><h3 id="基本标签（块级标签和内联标签）"><a href="#基本标签（块级标签和内联标签）" class="headerlink" title="基本标签（块级标签和内联标签）"></a>基本标签（块级标签和内联标签）</h3><pre><code>&lt;b&gt;加粗&lt;/b&gt;  &lt;i&gt;斜体&lt;/i&gt;  &lt;u&gt;下划线&lt;/u&gt;  &lt;s&gt;删除&lt;/s&gt;  &lt;p&gt;段落标签&lt;/p&gt;  &lt;h1&gt;标题1&lt;/h1&gt;  &lt;h2&gt;标题2&lt;/h2&gt;  &lt;h3&gt;标题3&lt;/h3&gt;  &lt;h4&gt;标题4&lt;/h4&gt;  &lt;h5&gt;标题5&lt;/h5&gt;  &lt;h6&gt;标题6&lt;/h6&gt;  &lt;!--换行--&gt;  &lt;br&gt;  &lt;!--水平线--&gt;&lt;hr&gt;</code></pre><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>内容</th><th>对应代码  </th></tr></thead><tbody><tr><td>空格</td><td>&nbsp;  </td></tr><tr><td>&gt;</td><td>&gt;  </td></tr><tr><td>&lt;</td><td>&lt;  </td></tr><tr><td>&amp;</td><td>&amp;  </td></tr><tr><td>¥</td><td>&yen;  </td></tr><tr><td>版权</td><td>&copy;  </td></tr><tr><td>注册</td><td>&reg;  </td></tr></tbody></table><h3 id="div标签和span标签"><a href="#div标签和span标签" class="headerlink" title="div标签和span标签"></a>div标签和span标签</h3><p>div标签用来定义一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。<br>span标签用来定义内联(行内)元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现。</p><p>块级元素与行内元素的区别：<br>所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。<br>这两个元素是专门为定义CSS样式而生的。</p><p><strong>注意：</strong></p><p>关于标签嵌套：通常块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。</p><p>p标签不能包含块级标签。</p><h3 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h3><pre><code>&lt;img src=&quot;图片的路径&quot; alt=&quot;图片未加载成功时的提示&quot; title=&quot;鼠标悬浮时提示信息&quot; width=&quot;宽&quot; height=&quot;高(宽高两个属性只用一个会自动等比缩放)&quot;&gt;</code></pre><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>超链接标签</p><p>所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>什么是URL？URL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。URL举例http://www.sohu.com/stu/intro.htmlhttp://222.172.123.33/stu/intro.htmlURL地址由4部分组成第1部分：为协议：http://、ftp://等 第2部分：为站点地址：可以是域名或IP地址第3部分：为页面在站点中的目录：stu第4部分：为页面名称，例如 index.html各部分之间用&quot;/&quot;符号隔开。</code></pre><p>URL</p><pre><code>&lt;a href=&quot;http://www.oldboyedu.com&quot; target=&quot;_blank&quot; &gt;点我&lt;/a&gt;</code></pre><p>href属性指定目标网页地址。该地址可以有几种类型：</p><ul><li>绝对URL - 指向另一个站点（比如 href=”<a href="http://www.jd.com）" target="_blank" rel="noopener">http://www.jd.com）</a></li><li>相对URL - 指当前站点中确切的路径（href=”index.htm”）</li><li>锚URL - 指向页面中的锚（href=”#top”）</li></ul><p>target：</p><ul><li>_blank表示在新标签页中打开目标网页</li><li>_self表示在当前标签页中打开目标网页</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>1.无序列表</p><pre><code>&lt;ul type=&quot;disc&quot;&gt;  &lt;li&gt;第一项&lt;/li&gt;  &lt;li&gt;第二项&lt;/li&gt;&lt;/ul&gt;</code></pre><p>type属性：</p><ul><li>disc（实心圆点，默认值）</li><li>circle（空心圆圈）</li><li>square（实心方块）</li><li>none（无样式）</li></ul><p>2.有序列表</p><pre><code>&lt;ol type=&quot;1&quot; start=&quot;2&quot;&gt;  &lt;li&gt;第一项&lt;/li&gt;  &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt;</code></pre><p>type属性：</p><ul><li>1 数字列表，默认值</li><li>A 大写字母</li><li>a 小写字母</li><li>Ⅰ大写罗马</li><li>ⅰ小写罗马</li></ul><p>3.标题列表</p><pre><code>&lt;dl&gt;  &lt;dt&gt;标题1&lt;/dt&gt;  &lt;dd&gt;内容1&lt;/dd&gt;  &lt;dt&gt;标题2&lt;/dt&gt;  &lt;dd&gt;内容1&lt;/dd&gt;  &lt;dd&gt;内容2&lt;/dd&gt;&lt;/dl&gt;</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。<br>表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。<br>表格的基本结构：</p><pre><code>&lt;table&gt;  &lt;thead&gt;  &lt;tr&gt;    &lt;th&gt;序号&lt;/th&gt;    &lt;th&gt;姓名&lt;/th&gt;    &lt;th&gt;爱好&lt;/th&gt;  &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;tr&gt;    &lt;td&gt;1&lt;/td&gt;    &lt;td&gt;Egon&lt;/td&gt;    &lt;td&gt;杠娘&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;2&lt;/td&gt;    &lt;td&gt;Yuan&lt;/td&gt;    &lt;td&gt;日天&lt;/td&gt;  &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;</code></pre><p>属性:</p><ul><li>border: 表格边框.</li><li>cellpadding: 内边距</li><li>cellspacing: 外边距.</li><li>width: 像素 百分比.（最好通过css来设置长宽）</li><li>rowspan: 单元格竖跨多少行</li><li>colspan: 单元格横跨多少列（即合并单元格）</li></ul><h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p><strong>功能：</strong></p><p>表单用于向服务器传输数据，从而实现用户与Web服务器的交互</p><p>表单能够包含input系列标签，比如文本字段、复选框、单选框、提交按钮等等。</p><p>表单还可以包含textarea、select、fieldset和 label标签。</p><p><strong>表单属性</strong></p><table><thead><tr><th>属性</th><th>值</th><th>含义  </th></tr></thead><tbody><tr><td>action</td><td>URL</td><td>指定一个表单处理目标URL，表单数据将被提交到该URL地址的处理程序。如果该属性值为空，则提交到文档自身。  </td></tr><tr><td>method</td><td>get或post</td><td>将表单数据提交到http服务器的方法，默认为get  </td></tr><tr><td>enctype</td><td>application/x-www-form-urlencoded</td><td></td></tr></tbody></table><p>指定表单数据的编码类型，此属性只有在method属性设置为post时才有效。默认值为application/x-www-form-<br>urlencode对所有字符进行编码。如果表单包含用于文件上传的控件（input<br>type=”file”）,那么这个属性值必须设置为multipart/form-data，不对字符进行编码。  </p><p><strong>表单元素</strong></p><p>基本概念：<br>HTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。<br>表单一般用来收集用户的输入信息<br>表单工作原理：<br>访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交。这些信息通过Internet传送到服务器上。<br>服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误。当数据完整无误后，服务器反馈一个输入完成的信息</p><h3 id="input系列"><a href="#input系列" class="headerlink" title="input系列"></a>input系列</h3><table><thead><tr><th>type属性值</th><th>表现形式</th><th>对应代码  </th></tr></thead><tbody><tr><td>text</td><td>单行输入文本</td><td>&lt;input type=text” /&gt;  </td></tr><tr><td>password</td><td>密码输入框</td><td><input type="password">  </td></tr><tr><td>checkbox</td><td>复选框</td><td><input type="checkbox" checked="checked">  </td></tr><tr><td>radio</td><td>单选框</td><td><input type="radio">  </td></tr><tr><td>submit</td><td>提交按钮</td><td><input type="submit" value="提交">  </td></tr><tr><td>reset</td><td>重置按钮</td><td><input type="reset" value="重置">  </td></tr><tr><td>button</td><td>普通按钮</td><td><input type="button" value="普通按钮">  </td></tr><tr><td>hidden</td><td>隐藏按钮</td><td><input type="hidden" value="隐藏按钮">  </td></tr><tr><td>file</td><td>文本选择框</td><td><input type="file">  </td></tr></tbody></table><p>类型（type）说明：</p><ul><li>text：文本输入框</li><li>password：密码输入框</li><li>radio：单选框</li><li>checkbox：多选框</li><li>submit：提交按钮</li><li>button：可点击的按钮，没有任何行为，一般配合JS使用</li><li>hidden：对用户不可见，通常用于修改某条数据时，记录数据的id值</li><li>file：提交文件  form表单需要加上enctype=”multipart/form-data”，method=”post”</li></ul><p>属性说明:</p><ul><li>name：表单提交时的”键”，注意和id的区别</li><li>value：表单提交时对应项的值 <ul><li>type=”button”, “reset”, “submit”时，为按钮上显示的文本年内容</li><li>type=”text”,”password”,”hidden”时，为输入框的初始值</li><li>type=”checkbox”, “radio”, “file”，为输入相关联的值</li></ul></li><li>checked：radio和checkbox默认被选中的项</li><li>readonly：text和password设置只读</li><li>disabled：所有input均适用</li></ul><h3 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h3><pre><code>&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;  &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt;    &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;    &lt;option selected=&quot;selected&quot; value=&quot;2&quot;&gt;上海&lt;/option&gt;    &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt;    &lt;option value=&quot;4&quot;&gt;深圳&lt;/option&gt;  &lt;/select&gt;&lt;/form&gt;</code></pre><p>属性说明：</p><ul><li>multiple：布尔属性，设置后为多选，否则默认单选</li><li>disabled：禁用</li><li>selected：默认选中该项</li><li>value：定义提交时的选项值</li></ul><h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><p>定义：<label> 标签为 input 元素定义标注（标记）。<br>说明：</label></p><ol><li>label 元素不会向用户呈现任何特殊效果。</li><li><label> 标签的 for 属性值应当与相关元素的 id 属性值相同。</label></li></ol><pre><code>&lt;form action=&quot;&quot;&gt;  &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;  &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;&lt;/form&gt;</code></pre><h3 id="textarea多行文本"><a href="#textarea多行文本" class="headerlink" title="textarea多行文本"></a>textarea多行文本</h3><pre><code>&lt;textarea name=&quot;memo&quot; id=&quot;memo&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;  默认内容&lt;/textarea&gt;</code></pre><p>属性说明：</p><ul><li>name：名称</li><li>rows：行数</li><li>cols：列数</li><li>disabled：禁用</li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 之 索引原理与慢查询优化</title>
      <link href="/2018/02/28/cnblog_8485214/"/>
      <url>/2018/02/28/cnblog_8485214/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-之-索引原理与慢查询优化👈的摘要"><a href="#这是👉MySQL-之-索引原理与慢查询优化👈的摘要" class="headerlink" title="这是👉MySQL 之 索引原理与慢查询优化👈的摘要"></a><a href="/2018/02/28/cnblog_8485214/">这是👉MySQL 之 索引原理与慢查询优化👈的摘要</a></h1><a id="more"></a><h1 id="浏览目录"><a href="#浏览目录" class="headerlink" title="浏览目录"></a><a href="http://www.cnblogs.com/wangfengming/articles/8092914.html" target="_blank" rel="noopener"></a>浏览目录</h1><ul><li><strong>一  索引介绍</strong></li><li><strong>二  索引类型</strong></li><li><strong>三  索引分类</strong></li><li><strong>四  聚合索引和辅助索引 </strong></li><li><strong>五  测试索引</strong></li><li><strong>六  正确使用索引</strong></li><li><strong>七  组合索引</strong></li><li><strong>八  注意事项</strong></li><li><strong>九  查询计划</strong></li><li><strong>十  慢日志查询</strong></li><li><strong>十一  大数据量分页优化</strong></li></ul><h2 id="1-索引介绍"><a href="#1-索引介绍" class="headerlink" title="1. 索引介绍"></a>1. 索引介绍</h2><blockquote></blockquote><p>一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。  </p><blockquote><p>说起加速查询，就不得不提到索引了。</p></blockquote><blockquote></blockquote><blockquote><p>什么索引:</p></blockquote><blockquote></blockquote><blockquote><p>简单的说,相当于图书的目录,可以帮助用户快速的找到需要的内容.</p></blockquote><blockquote></blockquote><blockquote></blockquote><p>在MySQL中也叫做”键”，是存储引擎用于快速找到记录的一种数据结构。能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍.  </p><blockquote></blockquote><h2 id="2-索引类型"><a href="#2-索引类型" class="headerlink" title="2.索引类型"></a>2.索引类型</h2><blockquote><p><strong>1. BTREE 类型</strong></p></blockquote><blockquote></blockquote><blockquote><p><strong><em>就是一种将索引值按一定的算法，存入一个树形的数据结构中.(如下图:)</em></strong></p></blockquote><blockquote></blockquote><blockquote><p>#####<br><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171224192713225-1028521247.png" alt=""></p></blockquote><blockquote></blockquote><blockquote><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一磁盘块中的数据会被一次性读取出来，而不是按需读取。InnoDB<br>存储引擎使用页作为数据读取单位，页是其磁盘管理的最小单位，默认 page 大小是 16kB。</p></blockquote><blockquote></blockquote><blockquote></blockquote><p>如上图，是一颗b+树，关于b+树的定义可以参见<a href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><blockquote></blockquote><blockquote><p><strong>b+树的查找过程</strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><blockquote></blockquote><blockquote><p><strong>  注意:1.索引字段要尽量的小,磁盘块可以存储更多的索引.</strong></p></blockquote><blockquote></blockquote><blockquote><p><strong>   2. </strong>索引最左匹配特性<em>**</em></p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p><strong>  2. HASH 类型</strong></p></blockquote><blockquote></blockquote><blockquote><p><strong>_hash就是一种（key=<br>value）形式的键值对,允许多个key对应相同的value，但不允许一个key对应多个value,为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据.<br>_ <em>hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率.</em></strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171223131106459-1539286084.png" alt=""></p><blockquote></blockquote><blockquote><p>假设索引使用hash函数f( )，如下：</p></blockquote><blockquote><pre><code>f(&apos;Arjen&apos;) = 2323</code></pre></blockquote><blockquote><pre><code>f(&apos;Baron&apos;) = 7437</code></pre></blockquote><blockquote><pre><code>f(&apos;Peter&apos;) = 8784</code></pre></blockquote><blockquote><pre><code>f(&apos;Vadim&apos;) = 2458</code></pre></blockquote><blockquote></blockquote><blockquote><p>此时，索引的结构大概如下：</p></blockquote><blockquote></blockquote><blockquote><p><img src="https://images.cnblogs.com/cnblogs_com/hustcat/mysql/mysql02-03.JPG" alt=""></p></blockquote><blockquote></blockquote><blockquote><pre><code>**3.HASH与BTREE比较:**</code></pre></blockquote><blockquote><pre><code>hash类型的索引：查询单条快，范围查询慢</code></pre></blockquote><blockquote><pre><code>btree类型的索引：b+树，层数越多，数据量越大,范围查询和随机查询快（innodb默认索引类型）</code></pre></blockquote><blockquote><pre><code>不同的存储引擎支持的索引类型也不一样</code></pre></blockquote><blockquote><pre><code>InnoDB 支持事务，支持行级别锁定，支持 Btree、Full-text 等索引，不支持 Hash 索引；</code></pre></blockquote><blockquote><pre><code>MyISAM 不支持事务，支持表级别锁定，支持 Btree、Full-text 等索引，不支持 Hash 索引；</code></pre></blockquote><blockquote><pre><code>Memory 不支持事务，支持表级别锁定，支持 Btree、Hash 等索引，不支持 Full-text 索引；</code></pre></blockquote><blockquote><pre><code>NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 Btree、Full-text 等索引；</code></pre></blockquote><blockquote><pre><code>Archive 不支持事务，支持表级别锁定，不支持 Btree、Hash、Full-text 等索引；</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3.索引分类"></a>3.索引分类</h2><blockquote><p>MySQL中常见索引有：</p></blockquote><blockquote></blockquote><blockquote><ul><li>普通索引</li></ul></blockquote><blockquote><ul><li>唯一索引</li></ul></blockquote><blockquote><ul><li>主键索引</li></ul></blockquote><blockquote><ul><li>组合索引</li></ul></blockquote><blockquote><ul><li>全文索引</li></ul></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><h5 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h5></blockquote><blockquote></blockquote><blockquote><p>普通索引仅有一个功能：加速查询</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>#创建表同时添加name字段为普通索引</code></pre></blockquote><blockquote><pre><code>create table tb1(</code></pre></blockquote><blockquote><pre><code>id int not null auto_increment primary key,</code></pre></blockquote><blockquote><pre><code>name varchar(100) not null,</code></pre></blockquote><blockquote><pre><code>   index idx_name(name)  );</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建表+索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>#单独为表指定普通索引</code></pre></blockquote><blockquote><pre><code>create index idx_name on tb1(name);</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>drop index idx_name on tb1;</code></pre></blockquote><blockquote></blockquote><blockquote><p>删除索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>show index from tb1;</code></pre></blockquote><blockquote></blockquote><blockquote><p>查看索引</p></blockquote><blockquote></blockquote><blockquote><h5 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h5></blockquote><blockquote></blockquote><blockquote><p>唯一索引有两个功能：加速查询 和 唯一约束（可含一个null 值）</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>create table tb2(</code></pre></blockquote><blockquote><pre><code>id int not null auto_increment primary key,</code></pre></blockquote><blockquote><pre><code>name varchar(50) not null,</code></pre></blockquote><blockquote><pre><code>age int not null,</code></pre></blockquote><blockquote><pre><code>  unique index idx_age (age)  )</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建表+唯一(unique)索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>create unique index idx_age on tb2(age);</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建unique索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>drop unique  index idx_age on tb2;</code></pre></blockquote><blockquote></blockquote><blockquote><p>删除unique索引</p></blockquote><blockquote></blockquote><blockquote><h5 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h5></blockquote><blockquote></blockquote><blockquote><p> 主键有两个功能：加速查询 和 唯一约束（不可含null）</p></blockquote><blockquote></blockquote><blockquote><p> 注意:一个表中最多只能有一个主键索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>#方式一:</code></pre></blockquote><blockquote><pre><code>create table tb3(</code></pre></blockquote><blockquote><pre><code>id int not null auto_increment primary key,</code></pre></blockquote><blockquote><pre><code>name varchar(50) not null,</code></pre></blockquote><blockquote><pre><code>age int default 0</code></pre></blockquote><blockquote><pre><code>);</code></pre></blockquote><blockquote><pre><code>#方式二:</code></pre></blockquote><blockquote><pre><code>create table tb3(</code></pre></blockquote><blockquote><pre><code>id int not null auto_increment,</code></pre></blockquote><blockquote><pre><code>name varchar(50) not null,</code></pre></blockquote><blockquote><pre><code>age int default 0 ,</code></pre></blockquote><blockquote><pre><code>primary key(id)</code></pre></blockquote><blockquote><pre><code>);</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建表 + 创建主键</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>alter table tb3 add primary key(id);</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建主键</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>#方式一</code></pre></blockquote><blockquote><pre><code>alter table tb3 drop primary key;</code></pre></blockquote><blockquote><pre><code>#方式二:</code></pre></blockquote><blockquote><pre><code>#如果当前主键为自增主键,则不能直接删除.需要先修改自增属性,再删除</code></pre></blockquote><blockquote><pre><code>alter table tb3 modify id int ,drop primary key;</code></pre></blockquote><blockquote></blockquote><blockquote><p>删除主键</p></blockquote><blockquote></blockquote><blockquote><h5 id="4-组合索引"><a href="#4-组合索引" class="headerlink" title="4.组合索引"></a>4.组合索引</h5></blockquote><blockquote></blockquote><blockquote><p>组合索引是将n个列组合成一个索引</p></blockquote><blockquote></blockquote><blockquote><p>其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = ‘alex’ and n2 = 666。</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>create table tb4(</code></pre></blockquote><blockquote><pre><code>id int not null primary key,</code></pre></blockquote><blockquote><pre><code>name varchar(50),</code></pre></blockquote><blockquote><pre><code>age int,</code></pre></blockquote><blockquote><pre><code>sex char(1),</code></pre></blockquote><blockquote><pre><code>index idx_age_sex(age,sex)</code></pre></blockquote><blockquote><pre><code>);</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建表+组合索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>create index idx_age_sex on tb4(age,sex);</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建组合索引</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>drop index idx_age_sex on tb4;</code></pre></blockquote><blockquote></blockquote><blockquote><p>删除组合索引</p></blockquote><blockquote></blockquote><blockquote><h5 id="5-全文索引-了解"><a href="#5-全文索引-了解" class="headerlink" title="5.全文索引(了解)"></a>5.全文索引(了解)</h5></blockquote><blockquote></blockquote><blockquote><p>全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用 [分词技术]<br>等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p></blockquote><blockquote></blockquote><blockquote><p><strong>强烈注意</strong> ：MySQL自带的全文索引只能用于数据库引擎为 <strong> <em>MyISAM</em></strong><br>的数据表，如果是其他数据引擎，则全文索引不会生效。此外，MySQL(5.6版本之前)自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，可以采用一些外部工具来完成.。比如采用Sphinx来做mysql的全文索引工具是一个很好的选择。</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>介绍索引创建的原则:</code></pre></blockquote><blockquote><pre><code>可以创建索引:</code></pre></blockquote><blockquote><pre><code>1.    字段经常出现在where子句或者连接条件中</code></pre></blockquote><blockquote><pre><code>2.    字段识别度高</code></pre></blockquote><blockquote><pre><code>3.    表经常被访问、数据量很大，且通常每次访问的数据量小于记录总量的2%-4%</code></pre></blockquote><blockquote><pre><code>不用创建索引:</code></pre></blockquote><blockquote><pre><code>1.    表很小的情况下，没有必要使用索引</code></pre></blockquote><blockquote><pre><code>2.    不经常在Where后使用的字段</code></pre></blockquote><blockquote><pre><code>3.    字段的识别度低(比如性别)</code></pre></blockquote><blockquote><pre><code>4.    如果表数据需要频繁修改，不建议使用索引</code></pre></blockquote><blockquote><pre><code>5.    如果查询返回记录很多(每次访问的数据量大于记录总数的2%-4%)，不建议使用索引</code></pre></blockquote><blockquote><pre><code>6.    如果where后含IS NULL /IS NOT NULL/ like &apos;%输入符%&apos;等条件，不建议使用索引。</code></pre></blockquote><blockquote></blockquote><blockquote><p>索引创建的原则</p></blockquote><blockquote></blockquote><blockquote></blockquote><h2 id="4-聚合索引和辅助索引"><a href="#4-聚合索引和辅助索引" class="headerlink" title="4.聚合索引和辅助索引"></a>4.聚合索引和辅助索引</h2><blockquote><p><strong>数据库中的B+树索引可以分为聚集索引和辅助索引.</strong></p></blockquote><blockquote></blockquote><blockquote><p><strong>聚集索引 ：InnoDB表 索引组织表，即表中数据按主键B+树存放，叶子节点直接存放整条数据，每张表只能有一个聚集索引。</strong></p></blockquote><blockquote></blockquote><blockquote><p>1.当你定义一个主键时，InnnodDB存储引擎则把它当做聚集索引</p></blockquote><blockquote></blockquote><blockquote><p>2.如果你没有定义一个主键，则InnoDB定位到第一个唯一索引，且该索引的所有列值均飞空的，则将其当做聚集索引。</p></blockquote><blockquote></blockquote><blockquote><p>3如果表没有主键或合适的唯一索引INNODB会产生一个隐藏的行ID值6字节的行ID聚集索引，</p></blockquote><blockquote></blockquote><blockquote><p>补充：由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能有一个聚集索引，聚集索引对于主键的排序和范围查找非常有利.</p></blockquote><blockquote></blockquote><blockquote><p>例子:<br>比如图书馆新进了一批书。那么这些书需要放到图书馆内。书如何放呢？一般都有一个规则，杂志类的放到101房间，文学类的放到102房间，理工类的放到103房间等等。这些存储的规则决定了每本书应该放到哪里。而这个例子中聚集索引为书的类别。</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p><strong>辅助索引：</strong><br>（也称非聚集索引）是指叶节点不包含行的全部数据，叶节点除了包含键值之外，还包含一个书签连接，通过该书签再去找相应的行数据。下图显示了InnoDB存储引擎辅助索引和聚集索引的关系：</p></blockquote><blockquote></blockquote><blockquote><p><img src="http://img.blog.csdn.net/20130613111257656" alt=""></p></blockquote><blockquote></blockquote><blockquote></blockquote><p>从上图中可以看出，辅助索引叶节点存放的是主键值，获得主键值后，再从聚集索引中查找整行数据。举个例子，如果在一颗高度为3的辅助索引中查找数据，首先从辅助索引中获得主键值（3次IO），接着从高度为3的聚集索引中查找以获得整行数据（3次IO），总共需6次IO。一个表上可以存在多个辅助索引。</p><blockquote></blockquote><blockquote><p>  例子: 同学如果想去图书馆找一本书，而不知道这本书在哪里？那么这个同学首先应该找的就是<br>检索室吧。对于要查找一本书来说，在检索室查是一个非常快捷的的途径了吧。但是，在检索室中你查到了该书在XX室XX书架的信息。你的查询结束了吗？没有吧。你仅仅找到了目的书的位置信息，你还要去该位置去取书。</p></blockquote><blockquote></blockquote><blockquote><p>对于这种方式来说，你需要两个步骤：<br> 1、查询该记录所在的位置。<br> 2、通过该位置去取要找的记录。</p></blockquote><blockquote></blockquote><blockquote><p>总结二者区别:</p></blockquote><blockquote></blockquote><blockquote><p><strong>相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。</strong></p></blockquote><blockquote></blockquote><blockquote><p><strong>**不同的是：聚集索引叶子结点存放的是一整行的信息,而辅助索引 </strong> <strong>叶子结点存放的是单个索引列信息.<strong>**</strong></strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>为了阐述非聚集索引写性能问题，我们先来看一个例子：</code></pre></blockquote><blockquote><pre><code>mysql&gt;create table t (</code></pre></blockquote><blockquote><pre><code>id int auto_increment,</code></pre></blockquote><blockquote><pre><code>name varchar(30),</code></pre></blockquote><blockquote><pre><code>primary key (id));</code></pre></blockquote><blockquote></blockquote><p>我们创建了一个表，表的主键是id，id列式自增长的，即当执行插入操作时，id列会自动增长，页中行记录按id顺序存放，不需要随机读取其它页的数据。因此，在这样的情况下（即聚集索引），插入操作效率很高。</p><blockquote></blockquote><p>但是，在大部分应用中，很少出现表中只有一个聚集索引的情况，更多情况下，表上会有多个非聚集的（辅助索引）。比如，对于上一张表t，业务上还需要按非唯一的name字段查找，则表定义改为：</p><blockquote><pre><code>mysql&gt;create table t (</code></pre></blockquote><blockquote><pre><code>id int auto_increment,</code></pre></blockquote><blockquote><pre><code>name varchar(30),</code></pre></blockquote><blockquote><pre><code>primary key (id),</code></pre></blockquote><blockquote><pre><code>key (name));</code></pre></blockquote><blockquote></blockquote><p>这时，除了主键聚合索引外，还产生了一个name列的辅助索引，对于该非聚集索引来说，叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。</p><blockquote></blockquote><blockquote><p>辅助索引写性能问题</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p><strong>何时使用聚集索引或非聚集索引</strong></p></blockquote><blockquote></blockquote><blockquote><p>下面的表总结了何时使用聚集索引或非聚集索引（很重要）：</p></blockquote><blockquote></blockquote><blockquote><p>动作描述</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>使用聚集索引</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>使用非聚集索引  </p><p>—|—|—  </p><p>列经常被分组排序</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应  </p><p>返回某范围内的数据</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>不应  </p><p>一个或极少不同值</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>不应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>不应  </p><p>小数目的不同值</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>不应  </p><p>大数目的不同值</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>不应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应  </p><p>频繁更新的列</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>不应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应  </p><p>外键列</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应  </p><p>主键列</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>应  </p><p>频繁修改索引列</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>不应</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>应</p></blockquote><blockquote></blockquote><blockquote></blockquote><h2 id="5-测试索引"><a href="#5-测试索引" class="headerlink" title="5.测试索引"></a>5.测试索引</h2><blockquote><p><strong>1.创建数据</strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>-- 1.创建表</code></pre></blockquote><blockquote><pre><code>CREATE TABLE userInfo(</code></pre></blockquote><blockquote><pre><code>id int NOT NULL,</code></pre></blockquote><blockquote><pre><code>name VARCHAR(16) DEFAULT NULL,</code></pre></blockquote><blockquote><pre><code>age int,</code></pre></blockquote><blockquote><pre><code>sex char(1) not null,</code></pre></blockquote><blockquote><pre><code>email varchar(64) default null</code></pre></blockquote><blockquote><pre><code>)ENGINE=MYISAM DEFAULT CHARSET=utf8;</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建表</p></blockquote><blockquote></blockquote><blockquote><p>注意:MYISAM存储引擎 不产生引擎事务，数据插入速度极快，为方便快速插入测试数据，等我们插完数据，再把存储类型修改为InnoDB</p></blockquote><blockquote></blockquote><blockquote><p><strong>**</strong>2.创建存储过程，插入数据<strong>**</strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>-- 2.创建存储过程</code></pre></blockquote><blockquote><pre><code>delimiter$$</code></pre></blockquote><blockquote><pre><code>CREATE PROCEDURE insert_user_info(IN num INT)</code></pre></blockquote><blockquote><pre><code>BEGIN</code></pre></blockquote><blockquote><pre><code>DECLARE val INT DEFAULT 0;</code></pre></blockquote><blockquote><pre><code>DECLARE n INT DEFAULT 1;</code></pre></blockquote><blockquote><pre><code>-- 循环进行数据插入</code></pre></blockquote><blockquote><pre><code>WHILE n &lt;= num DO</code></pre></blockquote><blockquote><pre><code>set val = rand()*50;</code></pre></blockquote><blockquote><pre><code>INSERT INTO</code></pre><p>userInfo(id,name,age,sex,email)values(n,concat(‘alex’,val),rand()*50,if(val%2=0,’女’,’男’),concat(‘alex’,n,<a href="mailto:&#39;@qq.com" target="_blank" rel="noopener">&#39;@qq.com</a>‘));</p></blockquote><blockquote><pre><code>set n=n+1;</code></pre></blockquote><blockquote><pre><code>end while;</code></pre></blockquote><blockquote><pre><code>END $$</code></pre></blockquote><blockquote><pre><code>delimiter;</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建存储过程</p></blockquote><blockquote></blockquote><blockquote><p><strong><strong>3.调用存储过程,插入500万条数据</strong></strong></p></blockquote><blockquote><pre><code>call insert_user_info(5000000);</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226094421369-1281265499.png" alt=""></p><blockquote></blockquote><blockquote><p>  <strong> </strong>4.此步骤可以忽略。修改引擎为INNODB<em>**</em></p></blockquote><blockquote><pre><code>ALTER TABLE userinfo ENGINE=INNODB;</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226094602650-1078997557.png" alt=""></p><blockquote></blockquote><blockquote><p><strong>5.测试索引</strong></p></blockquote><blockquote></blockquote><blockquote><ol><li>在没有索引的前提下测试查询速度</li></ol></blockquote><blockquote><pre><code>SELECT * FROM userinfo WHERE id = 4567890;</code></pre></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226100011322-1119889126.png" alt=""></p><blockquote></blockquote><p>注意:无索引情况,mysql根本就不知道id等于4567890的记录在哪里，只能把数据表从头到尾扫描一遍，此时有多少个磁盘块就需要进行多少IO操作，所以查询速度很慢.</p><blockquote></blockquote><blockquote><p>2.在表中已经存在大量数据的前提下，为某个字段段建立索引，建立速度会很慢</p></blockquote><blockquote><pre><code>CREATE INDEX idx_id on userinfo(id);</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226095723509-1270958485.png" alt=""></p><blockquote></blockquote><blockquote><p> 3.在索引建立完毕后，以该字段为查询条件时，查询速度提升明显</p></blockquote><blockquote><pre><code>select * from userinfo where id  = 4567890;</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226100144572-1811075076.png" alt=""></p><blockquote></blockquote><blockquote><p> 注意:</p></blockquote><blockquote></blockquote><blockquote><ol><li><strong> </strong> mysql先去索引表里根据b+树的搜索原理很快搜索到id为4567890的数据,IO大大降低，因而速度明显提升</li></ol></blockquote><blockquote></blockquote><blockquote><ol start="2"><li>我们可以去mysql的data目录下找到该表，可以看到添加索引后该表占用的硬盘空间多了</li></ol></blockquote><blockquote></blockquote><blockquote><p>3.如果使用没有添加索引的字段进行条件查询,速度依旧会很慢(如图:)</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226101828337-80007504.png" alt=""></p><h2 id="6-正确使用索引"><a href="#6-正确使用索引" class="headerlink" title="6.正确使用索引"></a>6.正确使用索引</h2><blockquote><p>  <strong>数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。<br> 即使建立索引，索引也不会生效,例如:</strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>1. 范围查询(&gt;、&gt;=、&lt;、&lt;=、!= 、between...and)</code></pre></blockquote><blockquote><pre><code>#1. = 等号</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where id = 1000 -- 执行索引,索引效率高</code></pre></blockquote><blockquote><pre><code>#2. &gt; &gt;= &lt; &lt;= between...and 区间查询</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where id &lt;100; -- 执行索引,区间范围越小,索引效率越高</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where id &gt;100; --执行索引,区间范围越大,索引效率越低</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where id between 10 and 500000</code></pre><p>–执行索引,区间范围越大,索引效率越低</p></blockquote><blockquote><pre><code>#3. != 不等于</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where id != 1000;  -- 索引范围大,索引效率低</code></pre></blockquote><blockquote><pre><code>2.like &apos;%xx%&apos;</code></pre></blockquote><blockquote><pre><code>为 name 字段添加索引</code></pre></blockquote><blockquote><pre><code>create index idx_name on userinfo(name);</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where name like &apos;%xxxx%&apos;; --</code></pre><p>全模糊查询,索引效率低</p></blockquote><blockquote><pre><code>select count(*) from userinfo where name like &apos;%xxxx&apos;;   --</code></pre><p>以什么结尾模糊查询,索引效率低</p></blockquote><blockquote><pre><code>例外: 当like使用以什么开头会索引使用率高</code></pre></blockquote><blockquote><pre><code>select * from userinfo where name like &apos;xxxx%&apos;;</code></pre></blockquote><blockquote><pre><code>3.or</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where id = 12334 or email =&apos;xxxx&apos;; --</code></pre><p>email不是索引字段,索引此查询全表扫描</p></blockquote><blockquote><pre><code>例外：当or条件中有未建立索引的列才失效，以下会走索引</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where id = 12334 or name = &apos;alex3&apos;; --</code></pre><p>id 和 name 都为索引字段时, or条件也会执行索引</p></blockquote><blockquote><pre><code>4.使用函数</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where reverse(name) = &apos;5xela&apos;; --</code></pre><p>name索引字段,使用函数时,索引失效</p></blockquote><blockquote><pre><code>例外:索引字段对应的值可以使用函数,我们可以改为一下形式</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where name = reverse(&apos;5xela&apos;);</code></pre></blockquote><blockquote><pre><code>5.类型不一致</code></pre></blockquote><blockquote><pre><code>如果列是字符串类型，传入条件是必须用引号引起来，不然...</code></pre></blockquote><blockquote><pre><code>select count(*) from userinfo where name = 454;</code></pre></blockquote><blockquote><pre><code>6.order by</code></pre></blockquote><blockquote><pre><code>#排序条件为索引，则select字段必须也是索引字段，否则无法命中  select email from userinfo ORDER BY name DESC; -- 无法命中索引</code></pre></blockquote><blockquote><pre><code>select name from userinfo ORDER BY name DESC;  -- 命中索引</code></pre></blockquote><blockquote><pre><code>特别的:如果对主键排序，则还是速度很快：</code></pre></blockquote><blockquote><pre><code>select * from userinfo order by id desc;</code></pre></blockquote><blockquote></blockquote><blockquote><p>示例</p></blockquote><blockquote></blockquote><blockquote></blockquote><h2 id="7-组合索引"><a href="#7-组合索引" class="headerlink" title="7.组合索引"></a>7.组合索引</h2><blockquote><p> 组合索引: 是指对表上的多个列组合起来做一个索引.</p></blockquote><blockquote></blockquote><blockquote><p> 组合索引好处:简单的说有两个主要原因：</p></blockquote><blockquote></blockquote><blockquote><p>  *<br>“一个顶三个”。建了一个(a,b,c)的组合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><ul><li>索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select <em> from table where a = 1<br>and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W</em>10%=100w<br>条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是组合索引，通过索引筛选出1000w <em>10% </em>10%<br>*10%=1w，然后再排序、分页，哪个更高效，一眼便知</li></ul></blockquote><blockquote></blockquote><blockquote><pre><code>&gt; 组合索引最左匹配原则: 从左往右依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>select * from mytable where a=3 and b=5 and c=4;</code></pre></blockquote><blockquote><pre><code>　　abc三个索引都在where条件里面用到了，而且都发挥了作用</code></pre></blockquote><blockquote><pre><code>select * from mytable where  c=4 and b=6 and a=3;</code></pre></blockquote><blockquote><pre><code>　　这条语句列出来只想说明 mysql没有那么笨，where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</code></pre></blockquote><blockquote><pre><code>select * from mytable where a=3 and c=7;</code></pre></blockquote><blockquote><pre><code>　　a用到索引，b没有用，所以c是没有用到索引效果的</code></pre></blockquote><blockquote><pre><code>select * from mytable where a=3 and b&gt;7 and c=3;</code></pre></blockquote><blockquote><pre><code>　　a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</code></pre></blockquote><blockquote><pre><code>select * from mytable where b=3 and c=4;</code></pre></blockquote><blockquote><pre><code>　　因为a索引没有使用，所以这里 bc都没有用上索引效果</code></pre></blockquote><blockquote><pre><code>select * from mytable where a&gt;4 and b=7 and c=9;</code></pre></blockquote><blockquote><pre><code>　　a用到了  b没有使用，c没有使用</code></pre></blockquote><blockquote><pre><code>select * from mytable where a=3 order by b;</code></pre></blockquote><blockquote><pre><code>　　a用到了索引，b在结果排序中也用到了索引的效果</code></pre></blockquote><blockquote><pre><code>select * from mytable where a=3 order by c;</code></pre></blockquote><blockquote><pre><code>　　a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了</code></pre></blockquote><blockquote><pre><code>select * from mytable where b=3 order by a;</code></pre></blockquote><blockquote><pre><code>　　b没有用到索引，排序中a也没有发挥索引效果</code></pre></blockquote><blockquote></blockquote><blockquote><p>示例</p></blockquote><blockquote></blockquote><blockquote></blockquote><h2 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8.注意事项"></a>8.注意事项</h2><blockquote></blockquote><blockquote><pre><code>1. 避免使用select *</code></pre></blockquote><blockquote><pre><code>2. count(1)或count(列) 代替 count(*)</code></pre></blockquote><blockquote><pre><code>3. 创建表时尽量时 char 代替 varchar</code></pre></blockquote><blockquote><pre><code>4. 表的字段顺序固定长度的字段优先</code></pre></blockquote><blockquote><pre><code>5. 组合索引代替多个单列索引（经常使用多个条件查询时）</code></pre></blockquote><blockquote><pre><code>6. 使用连接（JOIN）来代替子查询(Sub-Queries)</code></pre></blockquote><blockquote><pre><code>7. 不要有超过5个以上的表连接（JOIN）</code></pre></blockquote><blockquote><pre><code>8. 优先执行那些能够大量减少结果的连接。</code></pre></blockquote><blockquote><pre><code>9. 连表时注意条件类型需一致</code></pre></blockquote><blockquote><pre><code>10.索引散列值不适合建索引，例：性别不适合</code></pre></blockquote><blockquote></blockquote><h2 id="9-查询计划"><a href="#9-查询计划" class="headerlink" title="9.查询计划"></a>9.查询计划</h2><blockquote><p><strong>explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化</strong></p></blockquote><blockquote><pre><code>explain  select count(*) from userinfo where  id = 1;</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171226134625135-198622003.png" alt=""></p><blockquote><pre><code>执行计划：让mysql预估执行操作(一般正确)</code></pre></blockquote><blockquote><pre><code>all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt;</code></pre><p>system/const</p></blockquote><blockquote><pre><code>慢：</code></pre></blockquote><blockquote><pre><code>explain select * from userinfo where email=&apos;alex&apos;;</code></pre></blockquote><blockquote><pre><code>type: ALL(全表扫描)</code></pre></blockquote><blockquote><pre><code>特别的: select * from userinfo limit 1;</code></pre></blockquote><blockquote><pre><code>快：</code></pre></blockquote><blockquote><pre><code>explain select * from userinfo where name=&apos;alex&apos;;</code></pre></blockquote><blockquote><pre><code>type: ref(走索引)</code></pre></blockquote><blockquote></blockquote><blockquote><p><a href="http://www.cnblogs.com/wangfengming/articles/8275448.html" target="_blank" rel="noopener">EXPLAIN 参数详解:<br>http://www.cnblogs.com/wangfengming/articles/8275448.html</a></p></blockquote><blockquote></blockquote><blockquote></blockquote><h2 id="10-慢日志查询"><a href="#10-慢日志查询" class="headerlink" title="10. 慢日志查询"></a>10. <strong>慢日志查询</strong></h2><blockquote><p>  <strong>慢查询日志</strong>  </p></blockquote><blockquote><p>将mysql服务器中影响数据库性能的相关SQL语句记录到日志文件，通过对这些特殊的SQL语句分析，改进以达到提高数据库性能的目的。</p></blockquote><blockquote></blockquote><blockquote><p>慢查询日志参数:</p></blockquote><blockquote><pre><code>long_query_time     ：  设定慢查询的阀值，超出设定值的SQL即被记录到慢查询日志，缺省值为10s</code></pre></blockquote><blockquote><pre><code>slow_query_log      ：  指定是否开启慢查询日志</code></pre></blockquote><blockquote><pre><code>log_slow_queries    ：  指定是否开启慢查询日志(该参数已经被slow_query_log取代，做兼容性保留)</code></pre></blockquote><blockquote><pre><code>slow_query_log_file ：  指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log</code></pre></blockquote><blockquote><pre><code>log_queries_not_using_indexes: 为使用索引的搜索是否记录</code></pre></blockquote><blockquote></blockquote><blockquote><p>查看 MySQL慢日志信息</p></blockquote><blockquote><pre><code>#.查询慢日志配置信息 :</code></pre></blockquote><blockquote><pre><code>show variables like &apos;%query%&apos;;</code></pre></blockquote><blockquote><pre><code>#.修改配置信息</code></pre></blockquote><blockquote><pre><code>set global slow_query_log  = on;</code></pre></blockquote><blockquote></blockquote><blockquote><p>查看不使用索引参数状态:</p></blockquote><blockquote><pre><code># 显示参数　　</code></pre></blockquote><blockquote><pre><code>show variables like &apos;%log_queries_not_using_indexes&apos;;</code></pre></blockquote><blockquote><pre><code># 开启状态</code></pre></blockquote><blockquote><pre><code>set global log_queries_not_using_indexes  = on;</code></pre></blockquote><blockquote></blockquote><blockquote><p>查看慢日志显示的方式</p></blockquote><blockquote><pre><code>#查看慢日志记录的方式</code></pre></blockquote><blockquote><pre><code>show variables like &apos;%log_output%&apos;;</code></pre></blockquote><blockquote><pre><code>#设置慢日志在文件和表中同时记录</code></pre></blockquote><blockquote><pre><code>set global log_output=&apos;FILE,TABLE&apos;;</code></pre></blockquote><blockquote></blockquote><blockquote><p>测试慢查询日志</p></blockquote><blockquote><pre><code>#查询时间超过10秒就会记录到慢查询日志中</code></pre></blockquote><blockquote><pre><code>select sleep(3) FROM user ;</code></pre></blockquote><blockquote><pre><code>#查看表中的日志</code></pre></blockquote><blockquote><pre><code>select * from mysql.slow_log;</code></pre></blockquote><blockquote></blockquote><h2 id="11-大数据量分页优化"><a href="#11-大数据量分页优化" class="headerlink" title="11.大数据量分页优化"></a>11.大数据量分页优化</h2><blockquote><p> 执行此段代码:</p></blockquote><blockquote><pre><code>select * from tb1 limit 3000000,10;</code></pre></blockquote><blockquote></blockquote><blockquote><p>优化方案:</p></blockquote><blockquote></blockquote><blockquote><p>一. 简单粗暴，就是不允许查看这么靠后的数据，比如百度就是这样的</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171213221208894-1193507537.png" alt=""></p><blockquote></blockquote><blockquote><p>最多翻到72页就不让你翻了，这种方式就是从业务上解决；</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>二.在查询下一页时把上一页的行id作为参数传递给客户端程序，然后sql就改成了</p></blockquote><blockquote><pre><code>select * from tb1 where id&gt;3000000 limit 10;</code></pre></blockquote><blockquote></blockquote><blockquote><p>这条语句执行也是在毫秒级完成的，id&gt;300w其实就是让mysql直接跳到这里了，不用依次在扫描全面所有的行</p></blockquote><blockquote></blockquote><blockquote><p>如果你的table的主键id是自增的，并且中间没有删除和断点，那么还有一种方式，比如100页的10条数据</p></blockquote><blockquote><pre><code>select * from tb1 where id&gt;100*10 limit 10;</code></pre></blockquote><blockquote></blockquote><blockquote><p>三.最后第三种方法：延迟关联</p></blockquote><blockquote></blockquote><blockquote><p>我们在来分析一下这条语句为什么慢，慢在哪里。</p></blockquote><blockquote><pre><code>select * from tb1 limit 3000000,10;</code></pre></blockquote><blockquote></blockquote><blockquote><p>玄机就处在这个 <em> 里面，这个表除了id主键肯定还有其他字段  比如 name  age  之类的，因为select  </em><br>所以mysql在沿着id主键走的时候要回行拿数据，走一下拿一下数据；</p></blockquote><blockquote></blockquote><blockquote><p>如果把语句改成</p></blockquote><blockquote><pre><code>select id from tb1 limit 3000000,10;</code></pre></blockquote><blockquote></blockquote><blockquote><p>你会发现时间缩短了一半；然后我们在拿id分别去取10条数据就行了；</p></blockquote><blockquote></blockquote><blockquote><p>语句就改成这样了：</p></blockquote><blockquote><pre><code>select table.* from tb1 inner join ( select id from tb1 limit 3000000,10</code></pre><p>) as tmp on tmp.id=table.id;</p></blockquote><blockquote></blockquote><blockquote><p>这三种方法最先考虑第一种 其次第二种，第三种是别无选择</p></blockquote>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】</title>
      <link href="/2018/02/28/cnblog_8485209/"/>
      <url>/2018/02/28/cnblog_8485209/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】👈的摘要"><a href="#这是👉MySQL-之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】👈的摘要" class="headerlink" title="这是👉MySQL 之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】👈的摘要"></a><a href="/2018/02/28/cnblog_8485209/">这是👉MySQL 之【视图】【触发器】【存储过程】【函数】【事物】【数据库锁】【数据库备份】👈的摘要</a></h1><a id="more"></a><h1 id="浏览目录"><a href="#浏览目录" class="headerlink" title="浏览目录:"></a>浏览目录:</h1><ul><li><p>1.视图  </p></li><li><p>2.触发器</p></li><li>3.存储过程</li><li>4.函数</li><li>5.事物</li><li>6.数据库锁</li><li>7.数据库备份</li></ul><h2 id="1-视图"><a href="#1-视图" class="headerlink" title="1.视图"></a>1.视图</h2><blockquote><p>  <strong>视图:</strong> 是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据</p></blockquote><blockquote></blockquote><blockquote><p>视图有如下特点;<br> 1. 视图的列可以来自不同的表，是表的抽象和逻辑意义上建立的新关系。<br> 2. 视图是由基本表（实表）产生的表（虚表）。<br> 3. 视图的建立和删除不影响基本表。<br> 4. 对视图内容的更新（添加、删除和修改）直接影响基本表。<br> 5. 当视图来自多个基本表时，不允许添加和删除数据,但是能修改数据!</p></blockquote><blockquote></blockquote><blockquote><p>1.创建视图</p></blockquote><blockquote><pre><code>create view 视图名称  as sql 查询语句</code></pre></blockquote><blockquote></blockquote><blockquote><p>2.使用视图</p></blockquote><blockquote><pre><code>select * from 视图名称;</code></pre></blockquote><blockquote></blockquote><blockquote><p>3.更新视图</p></blockquote><blockquote><pre><code>alter view 视图名称 AS SQL语句</code></pre></blockquote><blockquote></blockquote><blockquote><p>4. 删除视图</p></blockquote><blockquote><pre><code>drop view ren_view;</code></pre></blockquote><h2 id="2-触发器-trigger"><a href="#2-触发器-trigger" class="headerlink" title="2.触发器-trigger"></a>2.触发器-trigger</h2><blockquote><p><strong>触发器</strong> ：监视某种情况，并触发某种操作。</p></blockquote><blockquote></blockquote><blockquote><p>触发器创建语法四要素：1.监视地点(table)</p></blockquote><blockquote></blockquote><blockquote><p>2.监视事件(insert/update/delete)</p></blockquote><blockquote></blockquote><blockquote><p>   3.触发时间(after/before)</p></blockquote><blockquote></blockquote><blockquote><p>4.触发事件(insert/update/delete)</p></blockquote><blockquote></blockquote><blockquote><p>1.创建触发器语法</p></blockquote><blockquote><pre><code>create trigger triggerName  after/before  insert/update/delete</code></pre></blockquote><blockquote><pre><code>on 表名 for each row #这句话是固定的</code></pre></blockquote><blockquote><pre><code>begin</code></pre></blockquote><blockquote><pre><code>#需要执行的sql语句</code></pre></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote><pre><code>注意1:after/before: 只能选一个 ,after 表示 后置触发, before 表示前置触发</code></pre></blockquote><blockquote><pre><code>注意2:insert/update/delete:只能选一个</code></pre></blockquote><blockquote></blockquote><blockquote><p>创建两张表</p></blockquote><blockquote></blockquote><blockquote><p>#商品表</p></blockquote><blockquote></blockquote><blockquote><p>create table goods(</p></blockquote><blockquote></blockquote><blockquote><p>  id int primary key auto_increment,</p></blockquote><blockquote></blockquote><blockquote><p>  name varchar(20),</p></blockquote><blockquote></blockquote><blockquote><p>  num int</p></blockquote><blockquote></blockquote><blockquote><p>);</p></blockquote><blockquote></blockquote><blockquote><p>|</p></blockquote><blockquote></blockquote><blockquote><p>#订单表</p></blockquote><blockquote></blockquote><blockquote><p>create table order_table(</p></blockquote><blockquote></blockquote><blockquote><pre><code>oid int primary key auto_increment,</code></pre></blockquote><blockquote></blockquote><blockquote><pre><code>gid int,</code></pre></blockquote><blockquote></blockquote><blockquote><pre><code>much int</code></pre></blockquote><blockquote></blockquote><blockquote><p>);  </p><p>—|—  </p><p>添加3条商品数据</p></blockquote><blockquote><pre><code>insert into goods(name,num) values(&apos;商品1&apos;,10),(&apos;商品2&apos;,10),(&apos;商品3&apos;,10);</code></pre></blockquote><blockquote></blockquote><blockquote><p>如果我们在没使用触发器之前：假设我们现在卖了3个商品1，我们需要做两件事</p></blockquote><blockquote></blockquote><blockquote><p>1.往订单表插入一条记录</p></blockquote><blockquote><pre><code>insert into order_table(gid,much) values(1,3);</code></pre></blockquote><blockquote></blockquote><blockquote><p>2.更新商品表商品1的剩余数量</p></blockquote><blockquote><pre><code>update goods set num=num-3 where id=1;</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>现在，我们来创建一个触发器：</p></blockquote><blockquote><pre><code>create trigger tg1 after insert on  order_table</code></pre></blockquote><blockquote><pre><code>for each row</code></pre></blockquote><blockquote><pre><code>begin    update goods set num = num -3 where id = 1;</code></pre></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote></blockquote><blockquote><p>这时候我们只要执行：</p></blockquote><blockquote><pre><code>insert into order_table(gid,much) values(1,3);  </code></pre></blockquote><blockquote></blockquote><blockquote><p>会发现商品1的数量变为7了，说明在我们插入一条订单的时候，</p></blockquote><blockquote></blockquote><blockquote><p>触发器自动帮我们做了更新操作。</p></blockquote><blockquote></blockquote><blockquote><p>但现在会有一个问题，因为我们触发器里面num和id都是写死的，所以不管我们买哪个商品，最终更新的都是商品1的数量。比如：我们往订单表再插入一条记录：</p></blockquote><blockquote><pre><code>insert into order_table(gid,much) values(2,3);</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>执行完后会发现商品1的数量变4了，而商品2的数量没变，这样显然不是我们想要的结果。我们需要改改我们之前创建的触发器。</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。</p></blockquote><blockquote></blockquote><blockquote><p>对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。</p></blockquote><blockquote></blockquote><blockquote><p>所以现在我们可以这样来改我们的触发器:</p></blockquote><blockquote><pre><code>create trigger tg2 after insert on order_table</code></pre></blockquote><blockquote><pre><code>for each row</code></pre></blockquote><blockquote><pre><code>begin</code></pre></blockquote><blockquote><pre><code>update goods set num = num-new.much  where id = new.gid;</code></pre></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote></blockquote><blockquote><p>第二个触发器创建完毕，我们先把第一个触发器删掉</p></blockquote><blockquote><pre><code>drop trigger tg1;</code></pre></blockquote><blockquote></blockquote><blockquote><p>再来测试一下，插入一条订单记录：</p></blockquote><blockquote><pre><code>insert into order_table(gid,much) values(2,3)</code></pre></blockquote><blockquote></blockquote><blockquote><p>执行完发现商品2的数量变为7了，现在就对了。</p></blockquote><blockquote></blockquote><blockquote><p>现在还存在两种情况：</p></blockquote><blockquote></blockquote><blockquote><p>1.当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？</p></blockquote><blockquote></blockquote><blockquote><p> 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。</p></blockquote><blockquote></blockquote><blockquote><p>那我们的触发器就该这样写：</p></blockquote><blockquote><pre><code>create trigger tg3 afert delete  on order_table</code></pre></blockquote><blockquote><pre><code>for each row</code></pre></blockquote><blockquote><pre><code>bigen</code></pre></blockquote><blockquote><pre><code>update goods set num = num + old.much where id = old.gid;--</code></pre><p>(注意这边的变化)</p></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote></blockquote><blockquote><p>2.当用户修改一个订单的数量时，我们触发器修改怎么写?</p></blockquote><blockquote><pre><code>create trigger tg4 after update on order_table</code></pre></blockquote><blockquote><pre><code>for each row</code></pre></blockquote><blockquote><pre><code>begin</code></pre></blockquote><blockquote><pre><code>update goods set num = num+old.much-new.much where id = old.gid;</code></pre></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote></blockquote><h2 id="3-存储过程"><a href="#3-存储过程" class="headerlink" title="3.存储过程"></a>3.存储过程</h2><blockquote><p> MySQL数据库在5.0版本后开始支持存储过程，那么什么是存储过程呢？怎么创建、查看和删除存储过程呢？存储过程有什么优点？</p></blockquote><blockquote></blockquote><blockquote><p><strong>存储过程</strong><br>：类似于函数(方法),简单的说存储过程是为了完成某个数据库中的特定功能而编写的语句集合，该语句集包括SQL语句（对数据的增删改查）、条件语句和循环语句等。  </p></blockquote><blockquote></blockquote><blockquote><ol><li>查看现有的存储过程</li></ol></blockquote><blockquote><pre><code>show procedure status;</code></pre></blockquote><blockquote></blockquote><blockquote><p>2 .删除存储过程</p></blockquote><blockquote><pre><code>drop procedure 存储过程名称;</code></pre></blockquote><blockquote></blockquote><blockquote><ol start="3"><li>调用 存储过程</li></ol></blockquote><blockquote><pre><code>call 存储过程名称(参数入/出类型 参数名 数据类型);</code></pre></blockquote><blockquote></blockquote><blockquote><p> 4.创建存储过程</p></blockquote><blockquote><pre><code>1.体会封装</code></pre></blockquote><blockquote><pre><code>#1.体会封装</code></pre></blockquote><blockquote><pre><code>create procedure p1 ()</code></pre></blockquote><blockquote><pre><code>begin</code></pre></blockquote><blockquote><pre><code>    select * from account;  end</code></pre></blockquote><blockquote><pre><code>2.SQL 体会参数</code></pre></blockquote><blockquote><pre><code>create procedure p2(in i int,out n varchar(50))</code></pre></blockquote><blockquote><pre><code>begin</code></pre></blockquote><blockquote><pre><code>select name into n from account where id = i;</code></pre></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote><pre><code>-- 调用</code></pre></blockquote><blockquote><pre><code>set @name =null;</code></pre></blockquote><blockquote><pre><code>CALL p2(1,@name);</code></pre></blockquote><blockquote><pre><code>select @name;</code></pre></blockquote><blockquote></blockquote><blockquote><p>注意1: mysql中有三种出入参数类型:分别为:1. <strong>in</strong> 入参类型   2. <strong>out</strong> 出参类型    3. <strong>inout</strong><br>出入参类型  </p></blockquote><blockquote><p>注意2: into 关键字 可以 将前面字段的查询结果 执行 给 into 后面的变量.</p></blockquote><blockquote></blockquote><blockquote><p>3.SQL 体会控制</p></blockquote><blockquote><pre><code>#3.SQL 体会控制</code></pre></blockquote><blockquote><pre><code>create procedure p3(in x int,in c char(1))</code></pre></blockquote><blockquote><pre><code>begin</code></pre></blockquote><blockquote><pre><code>if c =&apos;d&apos; then</code></pre></blockquote><blockquote><pre><code>select * from account where money &gt;x;</code></pre></blockquote><blockquote><pre><code>else</code></pre></blockquote><blockquote><pre><code>select * from account where money &lt;x;   　　end if;</code></pre></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote></blockquote><blockquote><p> 4.体会循环:计算1-100累加的和,并且返回计算结果.</p></blockquote><blockquote><pre><code>#4.体会循环:计算1-100累加的和,并且返回计算结果.</code></pre></blockquote><blockquote><pre><code>create procedure p4(inout n int)</code></pre></blockquote><blockquote><pre><code>begin</code></pre></blockquote><blockquote><pre><code>DECLARE sum int default 0; -- 设置总和变量,并且指定初始值0</code></pre></blockquote><blockquote><pre><code>declare i int; -- 声明变量</code></pre></blockquote><blockquote><pre><code>set i = 0;    -- 通过set为变量设置值</code></pre></blockquote><blockquote><pre><code>　　  while i&lt;=n DO  -- 开始循环</code></pre></blockquote><blockquote><pre><code>set sum = sum +i;</code></pre></blockquote><blockquote><pre><code>set i = i+1;</code></pre></blockquote><blockquote><pre><code>end while; -- 结束循环</code></pre></blockquote><blockquote><pre><code>　　  select sum; -- 提供结果</code></pre></blockquote><blockquote><pre><code>set n = sum;--将计算结果提供给 输出变量 n;</code></pre></blockquote><blockquote><pre><code>end;</code></pre></blockquote><blockquote><pre><code>-- 调用:</code></pre></blockquote><blockquote><pre><code>set @n = 100;</code></pre></blockquote><blockquote><pre><code>call p4(@n);</code></pre></blockquote><blockquote><pre><code>select @n;</code></pre></blockquote><blockquote></blockquote><blockquote><p><strong>存储过程优点</strong> ：<br>         1、存储过程增强了SQL语言灵活性。</p></blockquote><blockquote></blockquote><blockquote><p>存储过程可以使用控制语句编写，可以完成复杂的判断和较复杂的运算，有很强的灵活性；<br>         2、减少网络流量，降低了网络负载。</p></blockquote><blockquote></blockquote><blockquote><p>存储过程在服务器端创建成功后，只需要调用该存储过程即可，而传统的做法是每次都将大量的SQL语句通过网络发送至数据库服务器端然后再执行<br>         3、存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译。</p></blockquote><blockquote></blockquote><blockquote><p>一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。<br> <strong>存储过程缺点</strong> ：  </p></blockquote><blockquote><p>  1、扩展功能不方便</p></blockquote><blockquote></blockquote><blockquote><p>2、不便于系统后期维护</p></blockquote><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h2><blockquote><p>  <strong>MySQL提供的内建函数:</strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>一、数学函数</code></pre></blockquote><blockquote><pre><code>ROUND(x,y)</code></pre></blockquote><blockquote><pre><code>返回参数x的四舍五入的有y位小数的值</code></pre></blockquote><blockquote><pre><code>RAND()</code></pre></blockquote><blockquote><pre><code>返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</code></pre></blockquote><blockquote><pre><code>二、聚合函数(常用于GROUP BY从句的SELECT查询中)</code></pre></blockquote><blockquote><pre><code>AVG(col)返回指定列的平均值</code></pre></blockquote><blockquote><pre><code>COUNT(col)返回指定列中非NULL值的个数</code></pre></blockquote><blockquote><pre><code>MIN(col)返回指定列的最小值</code></pre></blockquote><blockquote><pre><code>MAX(col)返回指定列的最大值</code></pre></blockquote><blockquote><pre><code>SUM(col)返回指定列的所有值之和</code></pre></blockquote><blockquote><pre><code>    GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果  三、字符串函数</code></pre></blockquote><blockquote><pre><code>CHAR_LENGTH(str)</code></pre></blockquote><blockquote><pre><code>返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。</code></pre></blockquote><blockquote><pre><code>CONCAT(str1,str2,...)</code></pre></blockquote><blockquote><pre><code>字符串拼接</code></pre></blockquote><blockquote><pre><code>如有任何一个参数为NULL ，则返回值为 NULL。</code></pre></blockquote><blockquote><pre><code>CONCAT_WS(separator,str1,str2,...)</code></pre></blockquote><blockquote><pre><code>字符串拼接（自定义连接符）</code></pre></blockquote><blockquote><pre><code>CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。</code></pre></blockquote><blockquote><pre><code>CONV(N,from_base,to_base)</code></pre></blockquote><blockquote><pre><code>进制转换</code></pre></blockquote><blockquote><pre><code>例如：</code></pre></blockquote><blockquote><pre><code>SELECT CONV(&apos;a&apos;,16,2); 表示将 a 由16进制转换为2进制字符串表示</code></pre></blockquote><blockquote><pre><code>FORMAT(X,D)</code></pre></blockquote><blockquote><pre><code>将数字X 的格式写为&apos;#,###,###.##&apos;,以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若  D</code></pre><p>为 0, 则返回结果不带有小数点，或不含小数部分。</p></blockquote><blockquote><pre><code>例如：</code></pre></blockquote><blockquote><pre><code>SELECT FORMAT(12332.1,4); 结果为： &apos;12,332.1000&apos;</code></pre></blockquote><blockquote><pre><code>INSERT(str,pos,len,newstr)</code></pre></blockquote><blockquote><pre><code>在str的指定位置插入字符串</code></pre></blockquote><blockquote><pre><code>pos：要替换位置其实位置</code></pre></blockquote><blockquote><pre><code>len：替换的长度</code></pre></blockquote><blockquote><pre><code>newstr：新字符串</code></pre></blockquote><blockquote><pre><code>特别的：</code></pre></blockquote><blockquote><pre><code>如果pos超过原字符串长度，则返回原字符串</code></pre></blockquote><blockquote><pre><code>如果len超过原字符串长度，则由新字符串完全替换</code></pre></blockquote><blockquote><pre><code>INSTR(str,substr)</code></pre></blockquote><blockquote><pre><code>返回字符串 str 中子字符串的第一个出现位置。</code></pre></blockquote><blockquote><pre><code>LEFT(str,len)</code></pre></blockquote><blockquote><pre><code>返回字符串str 从开始的len位置的子序列字符。</code></pre></blockquote><blockquote><pre><code>LOWER(str)</code></pre></blockquote><blockquote><pre><code>变小写</code></pre></blockquote><blockquote><pre><code>UPPER(str)</code></pre></blockquote><blockquote><pre><code>变大写</code></pre></blockquote><blockquote><pre><code>REVERSE(str)</code></pre></blockquote><blockquote><pre><code>返回字符串 str ，顺序和字符顺序相反。</code></pre></blockquote><blockquote><pre><code>SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len)</code></pre><p>, SUBSTRING(str FROM pos FOR len)</p></blockquote><blockquote><pre><code>不带有len 参数的格式从字符串str返回一个子字符串，起始于位置</code></pre><p>pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL<br>语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos<br>使用一个负值。</p></blockquote><blockquote><pre><code>mysql&gt; SELECT SUBSTRING(&apos;Quadratically&apos;,5);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;ratically&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT SUBSTRING(&apos;foobarbar&apos; FROM 4);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;barbar&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT SUBSTRING(&apos;Quadratically&apos;,5,6);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;ratica&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT SUBSTRING(&apos;Sakila&apos;, -3);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;ila&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT SUBSTRING(&apos;Sakila&apos;, -5, 3);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;aki&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT SUBSTRING(&apos;Sakila&apos; FROM -4 FOR 2);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;ki&apos;</code></pre></blockquote><blockquote><pre><code>四、日期和时间函数</code></pre></blockquote><blockquote><pre><code>CURDATE()或CURRENT_DATE() 返回当前的日期</code></pre></blockquote><blockquote><pre><code>CURTIME()或CURRENT_TIME() 返回当前的时间</code></pre></blockquote><blockquote><pre><code>DAYOFWEEK(date)   返回date所代表的一星期中的第几天(1~7)</code></pre></blockquote><blockquote><pre><code>DAYOFMONTH(date)  返回date是一个月的第几天(1~31)</code></pre></blockquote><blockquote><pre><code>DAYOFYEAR(date)   返回date是一年的第几天(1~366)</code></pre></blockquote><blockquote><pre><code>DAYNAME(date)   返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE);</code></pre></blockquote><blockquote><pre><code>FROM_UNIXTIME(ts,fmt)  根据指定的fmt格式，格式化UNIX时间戳ts</code></pre></blockquote><blockquote><pre><code>HOUR(time)   返回time的小时值(0~23)</code></pre></blockquote><blockquote><pre><code>MINUTE(time)   返回time的分钟值(0~59)</code></pre></blockquote><blockquote><pre><code>MONTH(date)   返回date的月份值(1~12)</code></pre></blockquote><blockquote><pre><code>MONTHNAME(date)   返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);</code></pre></blockquote><blockquote><pre><code>NOW()    返回当前的日期和时间</code></pre></blockquote><blockquote><pre><code>QUARTER(date)   返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE);</code></pre></blockquote><blockquote><pre><code>WEEK(date)   返回日期date为一年中第几周(0~53)</code></pre></blockquote><blockquote><pre><code>YEAR(date)   返回日期date的年份(1000~9999)</code></pre></blockquote><blockquote><pre><code>重点:</code></pre></blockquote><blockquote><pre><code>DATE_FORMAT(date,format) 根据format字符串格式化date值</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT DATE_FORMAT(&apos;2009-10-04 22:23:00&apos;, &apos;%W %M %Y&apos;);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;Sunday October 2009&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT DATE_FORMAT(&apos;2007-10-04 22:23:00&apos;, &apos;%H:%i:%s&apos;);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;22:23:00&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT DATE_FORMAT(&apos;1900-10-04 22:23:00&apos;,</code></pre></blockquote><blockquote><pre><code>-&gt;                 &apos;%D %y %a %d %m %b %j&apos;);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;4th 00 Thu 04 10 Oct 277&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT DATE_FORMAT(&apos;1997-10-04 22:23:00&apos;,</code></pre></blockquote><blockquote><pre><code>-&gt;                 &apos;%H %k %I %r %T %S %w&apos;);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;22 22 10 10:23:00 PM 22:23:00 00 6&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT DATE_FORMAT(&apos;1999-01-01&apos;, &apos;%X %V&apos;);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;1998 52&apos;</code></pre></blockquote><blockquote><pre><code>mysql&gt; SELECT DATE_FORMAT(&apos;2006-06-00&apos;, &apos;%d&apos;);</code></pre></blockquote><blockquote><pre><code>-&gt; &apos;00&apos;</code></pre></blockquote><blockquote><pre><code>五、加密函数</code></pre></blockquote><blockquote><pre><code>MD5()      计算字符串str的MD5校验和</code></pre></blockquote><blockquote><pre><code>PASSWORD(str)      返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。</code></pre></blockquote><blockquote><pre><code>六、控制流函数      CASE WHEN[test1] THEN [result1]...ELSE [default] END</code></pre></blockquote><blockquote><pre><code>如果testN是真，则返回resultN，否则返回default</code></pre></blockquote><blockquote><pre><code>CASE [test] WHEN[val1] THEN [result]...ELSE [default]END      如果test和valN相等，则返回resultN，否则返回default</code></pre></blockquote><blockquote><pre><code>IF(test,t,f)      如果test是真，返回t；否则返回f</code></pre></blockquote><blockquote><pre><code>IFNULL(arg1,arg2)</code></pre></blockquote><blockquote><pre><code>如果arg1不是空，返回arg1，否则返回arg2</code></pre></blockquote><blockquote><pre><code>NULLIF(arg1,arg2)</code></pre></blockquote><blockquote><pre><code>如果arg1=arg2返回NULL；否则返回arg1  </code></pre></blockquote><blockquote><p>MySQL内建函数</p></blockquote><blockquote></blockquote><blockquote><p>更多函数: <a href="https://dev.mysql.com/doc/refman/5.7/en/functions.html" target="_blank" rel="noopener">官方猛击这里</a></p></blockquote><blockquote></blockquote><blockquote><p>1、自定义函数</p></blockquote><blockquote><pre><code>CREATE FUNCTION fun1(i1 int,i2 int)</code></pre></blockquote><blockquote><pre><code>RETURNS INT //设置返回类型</code></pre></blockquote><blockquote><pre><code>BEGIN</code></pre></blockquote><blockquote><pre><code>DECLARE sum int default 0;</code></pre></blockquote><blockquote><pre><code>set sum = i1+i2;</code></pre></blockquote><blockquote><pre><code>RETURN(sum); //返回结果</code></pre></blockquote><blockquote><pre><code>end</code></pre></blockquote><blockquote></blockquote><blockquote><p>2.调用自定义函数</p></blockquote><blockquote><pre><code>#直接调用自定义函数</code></pre></blockquote><blockquote><pre><code>select fun1(1,5);</code></pre></blockquote><blockquote><pre><code>#在sql语句中使用自定义函数</code></pre></blockquote><blockquote><pre><code>select fun1(参数1,参数2),name from 表名</code></pre></blockquote><blockquote></blockquote><blockquote><p>3.删除自定义函数</p></blockquote><blockquote><pre><code>DROP FUNCTION fun_name;</code></pre></blockquote><blockquote></blockquote><blockquote><p> 4.函数与存储过程的区别:</p></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images2017.cnblogs.com/blog/1284211/201801/1284211-20180110165949129-789952402.png" alt=""></p><h2 id="5-事物处理"><a href="#5-事物处理" class="headerlink" title="5.事物处理"></a>5.事物处理</h2><blockquote><p><strong>  一、 什么是事务</strong></p></blockquote><blockquote></blockquote><blockquote><p>事务就是一段sql 语句的批处理，但是这个批处理是一个原子的，不可分割，要么都执行，要么回滚（rollback）都不执行。</p></blockquote><blockquote></blockquote><blockquote><p><strong>二、为什么出现这种技术</strong></p></blockquote><blockquote></blockquote><blockquote><p>为什么要使用事务这个技术呢？<br>现在的很多软件都是多用户，多程序，多线程的，对同一个表可能同时有很多人在用，为保持数据的一致性，所以提出了事务的概念。这样很抽象，举个例子：</p></blockquote><blockquote></blockquote><blockquote><p>A 给B 要划钱，A 的账户-1000元， B 的账户就要+1000元，这两个update 语句必须作为一个整体来执行，不然A 扣钱了，B<br>没有加钱这种情况很难处理（找出原因）。</p></blockquote><blockquote></blockquote><blockquote><p><strong>三、事物的特性</strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p>80年代中国人结婚四大件：手表、自行车、缝纫机、收音机（三转一响）。要把事务娶回家同样需要四大件，所以事务很刻薄（ACID），四大件清单：原子性(Atom）、一致性（Consistent）、隔离性（Isolate）、持久性（Durable）。ACID就是数据库事务正确执行的四个特性的缩写。</p><blockquote></blockquote><blockquote><ul><li><strong>原子性</strong> ：要么不谈，要谈就要结婚！</li></ul></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>对于其数据修改，要么全都执行，要么全都不执行。</p></blockquote><blockquote></blockquote><blockquote><ul><li><strong>一致性</strong> ：恋爱时，什么方式爱我；结婚后还得什么方式爱我；</li></ul></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>数据库原来有什么样的约束，事务执行之后还需要存在这样的约束，所有规则都必须应用于事务的修改，以保持所有数据的完整性。</p></blockquote><blockquote></blockquote><blockquote><ul><li><strong>隔离性</strong> ：闹完洞房后，是俩人的私事。</li></ul></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>一个事务不能知道另外一个事务的执行情况（中间状态）</p></blockquote><blockquote></blockquote><blockquote><ul><li><strong>持久性</strong> ：一旦领了结婚证，无法后悔。</li></ul></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>即使出现致命的系统故障也将一直保持。不要告诉我系统说commit成功了，回头电话告诉我，服务器机房断电了，我的事务涉及到的数据修改可能没有进入数据库。</p></blockquote><blockquote></blockquote><blockquote><p>另外需要注意:</p></blockquote><blockquote></blockquote><blockquote><ul><li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li></ul></blockquote><blockquote><ul><li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li></ul></blockquote><blockquote><ul><li>事务用来管理 insert,update,delete 语句</li></ul></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><h5 id="四、事务控制语句："><a href="#四、事务控制语句：" class="headerlink" title="四、事务控制语句："></a>四、事务控制语句：</h5></blockquote><blockquote></blockquote><blockquote><ul><li>BEGIN 或 START TRANSACTION；显式地开启一个事务；</li></ul></blockquote><blockquote></blockquote><blockquote><ul><li>COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；</li></ul></blockquote><blockquote></blockquote><blockquote><ul><li>ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li></ul></blockquote><blockquote></blockquote><blockquote><ul><li>SAVEPOINT : 保存点,可以把一个事物分割成几部分.在执行ROLLBACK 时 可以指定在什么位置上进行回滚操作.</li></ul></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>注意: SET AUTOCOMMIT=0 ;禁止自动提交 和 SET AUTOCOMMIT=1 开启自动提交.</p></blockquote><blockquote></blockquote><blockquote><p><strong>五、例子: 鲁班转账给后羿</strong></p></blockquote><blockquote></blockquote><blockquote><p>1.创建表</p></blockquote><blockquote><pre><code>create table account(</code></pre></blockquote><blockquote><pre><code>id int(50) not null auto_increment primary key,</code></pre></blockquote><blockquote><pre><code>name VARCHAR(50) not null,</code></pre></blockquote><blockquote><pre><code>money DOUBLE(5,2) not NULL</code></pre></blockquote><blockquote><pre><code>);</code></pre></blockquote><blockquote></blockquote><blockquote><p>2.插入数据</p></blockquote><blockquote><pre><code>insert into account (name,money) values(&apos;鲁班&apos;,250),(&apos;后羿&apos;,5000);</code></pre></blockquote><blockquote></blockquote><blockquote><p>3.执行转账</p></blockquote><blockquote><pre><code>start transaction; -- 开启事物</code></pre></blockquote><blockquote><pre><code>--  执行sql语句操作</code></pre></blockquote><blockquote><pre><code>update account set money = money - 500 where id =&apos;1&apos;;  update account set money = money+500 where id = &apos;2&apos;;</code></pre></blockquote><blockquote><pre><code>commit;  -- 手动提交事物</code></pre></blockquote><blockquote><pre><code>rollback; -- 回滚事物</code></pre></blockquote><blockquote><pre><code>--  查看结果</code></pre></blockquote><blockquote><pre><code>select * from account;</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>START TRANSACTION ;</code></pre></blockquote><blockquote><pre><code>insert into account (name,money) values(&apos;李元芳&apos;,1000);</code></pre></blockquote><blockquote><pre><code>SAVEPOINT s1;</code></pre></blockquote><blockquote><pre><code>insert into account (name,money) values(&apos;张桂枝&apos;,1500);</code></pre></blockquote><blockquote><pre><code>ROLLBACK to s1;</code></pre></blockquote><blockquote></blockquote><blockquote><p>保存点示例</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p>最后<br>我们了解几个数据库不得不知的秘密，事务一旦启动，读数据分成两种，被别人读和读别人的数据。被别人读会产生脏数据的问题。读别人的会产生不可重复读和幻读两种情况。</p></blockquote><blockquote></blockquote><blockquote><p>  *<br><a href="http://www.cnblogs.com/wangfengming/articles/8269290.html" target="_blank" rel="noopener"><strong>脏读</strong></a>：读到的数据不是此刻真实的数据。</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><p>脏读就是指,当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。打个比方：</p><blockquote></blockquote><blockquote><p>我的支付宝余额3000元，事务A改为2000，但事务A尚未提交。与此同时，事务B正在读取，并且<br>“成功”读取到余额为2000。随后，事务A由于网络或者IO原因执行失败，回滚成3000元，事务B拿到的值继续运算，就是错误的.</p></blockquote><blockquote></blockquote><blockquote><p>银行转帐，A给B转1000元，B+1000，这个时候，B就能够读取到。这个时候A还没有减掉1000元，后悔了，没有提交，这个时候B把钱提走了，这不扯吗？<br>银行在早年代出现类似情形的bug.</p></blockquote><blockquote></blockquote><blockquote><p>  *<br><a href="http://www.cnblogs.com/wangfengming/articles/8269400.html" target="_blank" rel="noopener"><strong>不可重复读</strong></a>：读了两次，值不一样。</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><p>一个事务对同一行数据重复读取两次，但是却得到了不同的结果。例如，在两次读取的中途，有人对该行数据进行了update操作，并提交，结果就让当前这个事务郁闷了<br>…</p><blockquote></blockquote><blockquote></blockquote><p>还是余额3000元，事务A是一个比较长的事务，一开始读取到3000，结果恰好我的水电自动扣款100成功(事务B执行成功)，事务A在最后读取到的余额成了2900元。这就是不可重复读现象。</p><blockquote></blockquote><blockquote><p>  *<br><a href="http://www.cnblogs.com/wangfengming/articles/8269088.html" target="_blank" rel="noopener"><strong>幻读</strong></a>：原来没有，现在有了…</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><p>事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。</p><blockquote></blockquote><blockquote><p>事务A正在统计到目前为止的订单数量，一开始读到的是10笔。结果恰好这个时候，家人用此支付宝买了一个家电。等事务A打算提交的时候发现成了11笔。</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p><strong>事物的 4种 隔离机制:</strong></p></blockquote><blockquote></blockquote><blockquote><ol><li>读未提交（read uncommitted）：隔离级别是最低，会导致引发脏读，不可重复读，和幻读。</li></ol></blockquote><blockquote></blockquote><blockquote><p>这种隔离级别可以让当前事务读取到其它事物还没有提交的数据。</p></blockquote><blockquote></blockquote><blockquote><p>2.读已提交（read committed）：可避免脏读情况发生,  但引发 不可重复读，和幻读。</p></blockquote><blockquote></blockquote><blockquote><p>这种隔离级别可以让当前事务读取到其它事物已经提交的数据。</p></blockquote><blockquote></blockquote><blockquote><p>3.可重复读取（repeatable read）:MySQL默认的事务隔离级别</p></blockquote><blockquote></blockquote><blockquote></blockquote><p>它可以避免脏读、不可重复读的问题，确保同一个事务的多个实例在并发操作数据的时候，会看到相同的数据行。但是理论上，该级别会出现幻读情况，不过MySQL的存储引擎通过多版本并发控制机制解决了该问题，因此该级别是可以避免幻读的。</p><blockquote></blockquote><blockquote><p>4.串行（serializable）：隔离级别最高,可避免以上所有问题, 但会降低可并发性.</p></blockquote><blockquote></blockquote><blockquote></blockquote><p>这种隔离级别将事物放在一个队列中，每个事物开始之后，别的事物被挂起。同一个时间点只能有一个事物能操作数据库对象。这种隔离级别对于数据的完整性是最高的，但是同时大大降低了系统的可并发性。</p><h2 id="6-数据锁"><a href="#6-数据锁" class="headerlink" title="6.数据锁"></a>6.数据锁</h2><blockquote><p><strong>1.  </strong> <strong>锁的基本概念</strong></p></blockquote><blockquote></blockquote><blockquote><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。</p></blockquote><blockquote></blockquote><blockquote><p><strong>2.  </strong> <strong>锁的基本类型</strong></p></blockquote><blockquote></blockquote><blockquote><p><strong>** 多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：</strong>共享锁和排它锁。**</p></blockquote><blockquote></blockquote><blockquote><p><strong>2.1  </strong> <strong>共享锁（</strong> <strong>Shared Lock</strong> <strong>，也叫</strong> <strong>S</strong> <strong>锁）</strong></p></blockquote><blockquote></blockquote><blockquote><p>共享锁(S)表示对数据进行读操作。因此多个事务可以同时为一个对象加共享锁。（如果试衣间的门还没被锁上，顾客都能够同时进去参观）</p></blockquote><blockquote></blockquote><blockquote><p><strong>2.2  </strong> <strong>排他锁</strong> <strong>(Exclusive Lock</strong> <strong>，也叫</strong> <strong>X</strong> <strong>锁</strong> <strong>)</strong></p></blockquote><blockquote></blockquote><blockquote><p>排他锁(X)表示对数据进行写操作。如果一个事务对<br>对象加了排他锁，其他事务就不能再给它加任何锁了。(某个顾客把试衣间从里面反锁了，其他顾客想要使用这个试衣间，就只有等待锁从里面给打开了).</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p><strong>3. 实际开发中常见的两种锁:</strong></p></blockquote><blockquote></blockquote><blockquote><p><em>**</em> 3.1悲观锁<br>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block(阻塞)直到它拿到锁。传统的关系型<a href="http://lib.csdn.net/base/mysql" title="MySQL知识库" target="_blank" rel="noopener">数据库</a>里边就用到了很多这种锁机制.</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><p>注意：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性.因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。关闭自动提交命令为：set<br>autocommit=0;</p><blockquote></blockquote><blockquote><p>设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</p></blockquote><blockquote><pre><code>-- 0.开始事务</code></pre></blockquote><blockquote><pre><code>set autocommit=0;</code></pre></blockquote><blockquote><pre><code>-- 1.查询出数据信息</code></pre></blockquote><blockquote><pre><code>select * from ren where p_id=&apos;p001&apos; for update;</code></pre></blockquote><blockquote><pre><code>-- 2.修改当前人员信息</code></pre></blockquote><blockquote><pre><code>update ren set p_name=&apos;张1丰&apos; where p_id=&apos;p001&apos;;</code></pre></blockquote><blockquote><pre><code>-- 3. 提交事务</code></pre></blockquote><blockquote><pre><code>-- commit;</code></pre></blockquote><blockquote></blockquote><blockquote><p>在另外的查询页面执行:</p></blockquote><blockquote><pre><code>select * from ren where p_id=&apos;p001&apos; for update;</code></pre></blockquote><blockquote></blockquote><blockquote><p>会发现当前查询会进入到等待状态,不会显示出数据,当上面的sql执行完毕提交事物后,当前sql才会显示结果.</p></blockquote><blockquote></blockquote><blockquote><p>注意1:在使用悲观锁时,如果表中没有指定主键,则会进行锁表操作.</p></blockquote><blockquote></blockquote><blockquote><p>注意2: 悲观锁的确保了数据的安全性，在数据被操作的时候锁定数据不被访问，但是这样会带来很大的性能问题。因此悲观锁在实际开发中使用是相对比较少的。</p></blockquote><blockquote></blockquote><blockquote><p> 3.2 <strong>  乐观锁</strong>,<br>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p></blockquote><blockquote></blockquote><blockquote><p>使用乐观锁的两种方式:</p></blockquote><blockquote></blockquote><blockquote><p>1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现<br>方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version”<br>字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录<br>的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数 据。</p></blockquote><blockquote></blockquote><blockquote><p> 代码示例:</p></blockquote><blockquote><pre><code>update account set name=&apos;ygz&apos; , version = version+1 where id = &apos;1&apos; and</code></pre><p>version = 1;</p></blockquote><blockquote></blockquote><blockquote><p>2.乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳 （datatime）,<br>和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p><strong>两种锁各有优缺点:</strong></p></blockquote><blockquote></blockquote><blockquote></blockquote><p>不可认为一种好于另一种，像乐观锁适用于写入比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry(重试)，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适.</p><h2 id="7-数据库备份"><a href="#7-数据库备份" class="headerlink" title="7.数据库备份"></a>7.数据库备份</h2><p>mysqldump 命令将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。</p><p>mysqldump命令的工作原理很简单。它先查出需要备份的表的结构，再在文本文件中生成一个CREATE语句。然后，将表中的所有记录转换成一条INSERT语句。然后通过这些语句，就能够创建表并插入数据。</p><blockquote><p><strong>1. </strong>使用mysqldump实现逻辑备份<em>**</em></p></blockquote><blockquote><pre><code>#语法：</code></pre></blockquote><blockquote><pre><code># mysqldump -h 服务器 -u用户名 -p密码 数据库名 &gt; 备份文件.sql</code></pre></blockquote><blockquote><pre><code>#示例：</code></pre></blockquote><blockquote><pre><code>#单库备份</code></pre></blockquote><blockquote><pre><code>mysqldump -uroot -p123456 db1 &gt; c:/db1.sql</code></pre></blockquote><blockquote><pre><code>mysqldump -uroot -p123456 db1 table1 table2 &gt; c:/db1-table1-table2.sql</code></pre></blockquote><blockquote><pre><code>#多库备份</code></pre></blockquote><blockquote><pre><code>mysqldump -uroot -p123456 --databases db1 db2 mysql db3 &gt;</code></pre><p>c:/db1_db2_mysql_db3.sql</p></blockquote><blockquote><pre><code>#备份所有库</code></pre></blockquote><blockquote><pre><code>mysqldump -uroot -p123456 --all-databases &gt; c:/all.sql</code></pre></blockquote><blockquote></blockquote><blockquote></blockquote><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><blockquote><pre><code>--all-databases  , - A</code></pre></blockquote><blockquote><pre><code>导出全部数据库。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases</code></pre></blockquote><blockquote><pre><code>--all-tablespaces  , -Y</code></pre></blockquote><blockquote><pre><code>导出全部表空间。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --all-tablespaces</code></pre></blockquote><blockquote><pre><code>--no-tablespaces  , -y</code></pre></blockquote><blockquote><pre><code>不导出任何表空间信息。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --no-tablespaces</code></pre></blockquote><blockquote><pre><code>--add-drop-database</code></pre></blockquote><blockquote><pre><code>每个数据库创建之前添加drop数据库语句。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --add-drop-database</code></pre></blockquote><blockquote><pre><code>--add-drop-table</code></pre></blockquote><blockquote><pre><code>每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用--skip-add-drop-table取消选项)</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases  (默认添加drop语句)</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases -skip-add-drop-table  (取消drop语句)</code></pre></blockquote><blockquote><pre><code>--add-locks</code></pre></blockquote><blockquote><pre><code>在每个表导出之前增加LOCK TABLES并且之后UNLOCK  TABLE。(默认为打开状态，使用--skip-add-locks取消选项)</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases  (默认添加LOCK语句)</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases -skip-add-locks   (取消LOCK语句)</code></pre></blockquote><blockquote><pre><code>--allow-keywords</code></pre></blockquote><blockquote><pre><code>允许创建是关键词的列名字。这由表名前缀于每个列名做到。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --allow-keywords</code></pre></blockquote><blockquote><pre><code>--apply-slave-statements</code></pre></blockquote><blockquote><pre><code>在&apos;CHANGE MASTER&apos;前添加&apos;STOP SLAVE&apos;，并且在导出的最后添加&apos;START SLAVE&apos;。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --apply-slave-statements</code></pre></blockquote><blockquote><pre><code>--character-sets-dir</code></pre></blockquote><blockquote><pre><code>字符集文件的目录</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases  --character-sets-</code></pre><p>dir=/usr/local/mysql/share/mysql/charsets</p></blockquote><blockquote><pre><code>--comments</code></pre></blockquote><blockquote><pre><code>附加注释信息。默认为打开，可以用--skip-comments取消</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases  (默认记录注释)</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --skip-comments   (取消注释)</code></pre></blockquote><blockquote><pre><code>--compatible</code></pre></blockquote><blockquote><pre><code>导出的数据将和其它数据库或旧版本的MySQL</code></pre><p>相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，</p></blockquote><blockquote><pre><code>要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --compatible=ansi</code></pre></blockquote><blockquote><pre><code>--compact</code></pre></blockquote><blockquote><pre><code>导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：--skip-add-drop-table  --skip-add-</code></pre><p>locks –skip-comments –skip-disable-keys</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --compact</code></pre></blockquote><blockquote><pre><code>--complete-insert,  -c</code></pre></blockquote><blockquote><pre><code>使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --complete-insert</code></pre></blockquote><blockquote><pre><code>--compress, -C</code></pre></blockquote><blockquote><pre><code>在客户端和服务器之间启用压缩传递所有信息</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --compress</code></pre></blockquote><blockquote><pre><code>--create-options,  -a</code></pre></blockquote><blockquote><pre><code>在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases</code></pre></blockquote><blockquote><pre><code>--databases,  -B</code></pre></blockquote><blockquote><pre><code>导出几个数据库。参数后面所有名字参量都被看作数据库名。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --databases test mysql</code></pre></blockquote><blockquote><pre><code>--debug</code></pre></blockquote><blockquote><pre><code>输出debug信息，用于调试。默认值为：d:t,/tmp/mysqldump.trace</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --debug</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --debug=&quot; d:t,/tmp/debug.trace&quot;</code></pre></blockquote><blockquote><pre><code>--debug-check</code></pre></blockquote><blockquote><pre><code>检查内存和打开文件使用说明并退出。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --debug-check</code></pre></blockquote><blockquote><pre><code>--debug-info</code></pre></blockquote><blockquote><pre><code>输出调试信息并退出</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --debug-info</code></pre></blockquote><blockquote><pre><code>--default-character-set</code></pre></blockquote><blockquote><pre><code>设置默认字符集，默认值为utf8</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --default-character-set=utf8</code></pre></blockquote><blockquote><pre><code>--delayed-insert</code></pre></blockquote><blockquote><pre><code>采用延时插入方式（INSERT DELAYED）导出数据</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --delayed-insert</code></pre></blockquote><blockquote><pre><code>--delete-master-logs</code></pre></blockquote><blockquote><pre><code>master备份后删除日志. 这个参数将自动激活--master-data。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --delete-master-logs</code></pre></blockquote><blockquote><pre><code>--disable-keys</code></pre></blockquote><blockquote><pre><code>对于每个表，用/*!40000 ALTER TABLE tbl_name DISABLE KEYS */;和/*!40000 ALTER</code></pre><p>TABLE tbl_name ENABLE KEYS<br>*/;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases</code></pre></blockquote><blockquote><pre><code>--dump-slave</code></pre></blockquote><blockquote><pre><code>该选项将主的binlog位置和文件名追加到导出数据的文件中(show slave status)。设置为1时，将会以CHANGE</code></pre><p>MASTER命令输出到数据文件；设置为2时，会在change前加上注释。该选项将会打开–lock-all-tables，除非–single-<br>transaction被指定。该选项会自动关闭–lock-tables选项。默认值为0。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --dump-slave=1</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --dump-slave=2</code></pre></blockquote><blockquote><pre><code>--master-data</code></pre></blockquote><blockquote><pre><code>该选项将当前服务器的binlog的位置和文件名追加到输出文件中(show master status)。如果为1，将会输出CHANGE</code></pre><p>MASTER 命令；如果为2，输出的CHANGE  MASTER命令前添加注释信息。该选项将打开–lock-all-tables 选项，除非–<br>single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的–single-<br>transaction选项）。该选项自动关闭–lock-tables选项。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --master-data=1;</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --master-data=2;</code></pre></blockquote><blockquote><pre><code>--events, -E</code></pre></blockquote><blockquote><pre><code>导出事件。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --events</code></pre></blockquote><blockquote><pre><code>--extended-insert,  -e</code></pre></blockquote><blockquote><pre><code>使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用--skip-extended-</code></pre><p>insert取消选项。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases--skip-extended-insert   (取消选项)</code></pre></blockquote><blockquote><pre><code>--fields-terminated-by</code></pre></blockquote><blockquote><pre><code>导出文件中忽略给定字段。与--tab选项一起使用，不能用于--databases和--all-databases选项</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p test test --tab=&quot;/home/mysql&quot; --fields-terminated-</code></pre><p>by=”#”</p></blockquote><blockquote><pre><code>--fields-enclosed-by</code></pre></blockquote><blockquote><pre><code>输出文件中的各个字段用给定字符包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p test test --tab=&quot;/home/mysql&quot; --fields-enclosed-</code></pre><p>by=”#”</p></blockquote><blockquote><pre><code>--fields-optionally-enclosed-by</code></pre></blockquote><blockquote><pre><code>输出文件中的各个字段用给定字符选择性包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p test test --tab=&quot;/home/mysql&quot;  --fields-enclosed-</code></pre><p>by=”#” –fields-optionally-enclosed-by  =”#”</p></blockquote><blockquote><pre><code>--fields-escaped-by</code></pre></blockquote><blockquote><pre><code>输出文件中的各个字段忽略给定字符。与--tab选项一起使用，不能用于--databases和--all-databases选项</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p mysql user --tab=&quot;/home/mysql&quot; --fields-escaped-</code></pre><p>by=”#”</p></blockquote><blockquote><pre><code>--flush-logs</code></pre></blockquote><blockquote><pre><code>开始导出之前刷新日志。</code></pre></blockquote><blockquote><pre><code>请注意：假如一次导出多个数据库(使用选项--databases或者--all-databases)，将会逐个数据库刷新日志。除使用--lock-</code></pre><p>all-tables或者–master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用–<br>lock-all-tables 或者–master-data 和–flush-logs。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --flush-logs</code></pre></blockquote><blockquote><pre><code>--flush-privileges</code></pre></blockquote><blockquote><pre><code>在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES</code></pre><p>语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --flush-privileges</code></pre></blockquote><blockquote><pre><code>--force</code></pre></blockquote><blockquote><pre><code>在导出过程中忽略出现的SQL错误。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --force</code></pre></blockquote><blockquote><pre><code>--help</code></pre></blockquote><blockquote><pre><code>显示帮助信息并退出。</code></pre></blockquote><blockquote><pre><code>mysqldump  --help</code></pre></blockquote><blockquote><pre><code>--hex-blob</code></pre></blockquote><blockquote><pre><code>使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --all-databases --hex-blob</code></pre></blockquote><blockquote><pre><code>--host, -h</code></pre></blockquote><blockquote><pre><code>需要导出的主机信息</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre></blockquote><blockquote><pre><code>--ignore-table</code></pre></blockquote><blockquote><pre><code>不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：--ignore-</code></pre><p>table=database.table1 –ignore-table=database.table2 ……</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --ignore-</code></pre><p>table=mysql.user</p></blockquote><blockquote><pre><code>--include-master-host-port</code></pre></blockquote><blockquote><pre><code>在--dump-slave产生的&apos;CHANGE  MASTER</code></pre><p>TO..’语句中增加’MASTER_HOST=<host>，MASTER_PORT=<port>‘<br>    mysqldump  -uroot -p –host=localhost –all-databases –include-master-<br>host-port</port></host></p></blockquote><blockquote><pre><code>--insert-ignore</code></pre></blockquote><blockquote><pre><code>在插入行时使用INSERT IGNORE语句.</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --insert-ignore</code></pre></blockquote><blockquote><pre><code>--lines-terminated-by</code></pre></blockquote><blockquote><pre><code>输出文件的每行用给定字符串划分。与--tab选项一起使用，不能用于--databases和--all-databases选项。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost test test --tab=&quot;/tmp/mysql&quot;</code></pre><p>–lines-terminated-by=”##”</p></blockquote><blockquote><pre><code>--lock-all-tables,  -x</code></pre></blockquote><blockquote><pre><code>提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭--single-transaction 和--lock-</code></pre><p>tables 选项。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --lock-all-tables</code></pre></blockquote><blockquote><pre><code>--lock-tables,  -l</code></pre></blockquote><blockquote><pre><code>开始导出前，锁定所有表。用READ  LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-</code></pre><p>transaction是一个更好的选择，因为它根本不需要锁定表。</p></blockquote><blockquote><pre><code>请注意当导出多个数据库时，--lock-</code></pre><p>tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --lock-tables</code></pre></blockquote><blockquote><pre><code>--log-error</code></pre></blockquote><blockquote><pre><code>附加警告和错误信息到给定文件</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases  --log-</code></pre><p>error=/tmp/mysqldump_error_log.err</p></blockquote><blockquote><pre><code>--max_allowed_packet</code></pre></blockquote><blockquote><pre><code>服务器发送和接受的最大包长度。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre><p>–max_allowed_packet=10240</p></blockquote><blockquote><pre><code>--net_buffer_length</code></pre></blockquote><blockquote><pre><code>TCP/IP和socket连接的缓存大小。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre><p>–net_buffer_length=1024</p></blockquote><blockquote><pre><code>--no-autocommit</code></pre></blockquote><blockquote><pre><code>使用autocommit/commit 语句包裹表。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-autocommit</code></pre></blockquote><blockquote><pre><code>--no-create-db,  -n</code></pre></blockquote><blockquote><pre><code>只导出数据，而不添加CREATE DATABASE 语句。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-create-db</code></pre></blockquote><blockquote><pre><code>--no-create-info,  -t</code></pre></blockquote><blockquote><pre><code>只导出数据，而不添加CREATE TABLE 语句。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-create-info</code></pre></blockquote><blockquote><pre><code>--no-data, -d</code></pre></blockquote><blockquote><pre><code>不导出任何数据，只导出数据库表结构。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-data</code></pre></blockquote><blockquote><pre><code>--no-set-names,  -N</code></pre></blockquote><blockquote><pre><code>等同于--skip-set-charset</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --no-set-names</code></pre></blockquote><blockquote><pre><code>--opt</code></pre></blockquote><blockquote><pre><code>等同于--add-drop-table,  --add-locks, --create-options, --quick,</code></pre><p>–extended-insert, –lock-tables,  –set-charset, –disable-keys 该选项默认开启,  可以用<br>–skip-opt禁用.</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --opt</code></pre></blockquote><blockquote><pre><code>--order-by-primary</code></pre></blockquote><blockquote><pre><code>如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --order-by-primary</code></pre></blockquote><blockquote><pre><code>--password, -p</code></pre></blockquote><blockquote><pre><code>连接数据库密码</code></pre></blockquote><blockquote><pre><code>--pipe(windows系统可用)</code></pre></blockquote><blockquote><pre><code>使用命名管道连接mysql</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --pipe</code></pre></blockquote><blockquote><pre><code>--port, -P</code></pre></blockquote><blockquote><pre><code>连接数据库端口号</code></pre></blockquote><blockquote><pre><code>--protocol</code></pre></blockquote><blockquote><pre><code>使用的连接协议，包括：tcp, socket, pipe, memory.</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --protocol=tcp</code></pre></blockquote><blockquote><pre><code>--quick, -q</code></pre></blockquote><blockquote><pre><code>不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --skip-quick</code></pre></blockquote><blockquote><pre><code>--quote-names,-Q</code></pre></blockquote><blockquote><pre><code>使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --skip-quote-names</code></pre></blockquote><blockquote><pre><code>--replace</code></pre></blockquote><blockquote><pre><code>使用REPLACE INTO 取代INSERT INTO.</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --replace</code></pre></blockquote><blockquote><pre><code>--result-file,  -r</code></pre></blockquote><blockquote><pre><code>直接输出到指定文件中。该选项应该用在使用回车换行对（\\r\\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --result-</code></pre><p>file=/tmp/mysqldump_result_file.txt</p></blockquote><blockquote><pre><code>--routines, -R</code></pre></blockquote><blockquote><pre><code>导出存储过程以及自定义函数。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --routines</code></pre></blockquote><blockquote><pre><code>--set-charset</code></pre></blockquote><blockquote><pre><code>添加&apos;SET NAMES  default_character_set&apos;到输出文件。默认为打开状态，使用--skip-set-</code></pre><p>charset关闭选项。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --skip-set-charset</code></pre></blockquote><blockquote><pre><code>--single-transaction</code></pre></blockquote><blockquote><pre><code>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN</code></pre><p>不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和–lock-tables<br>选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用–quick 选项。</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --single-</code></pre><p>transaction</p></blockquote><blockquote><pre><code>--dump-date</code></pre></blockquote><blockquote><pre><code>将导出时间添加到输出文件中。默认为打开状态，使用--skip-dump-date关闭选项。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --skip-dump-date</code></pre></blockquote><blockquote><pre><code>--skip-opt</code></pre></blockquote><blockquote><pre><code>禁用-opt选项.</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --skip-opt</code></pre></blockquote><blockquote><pre><code>--socket,-S</code></pre></blockquote><blockquote><pre><code>指定连接mysql的socket文件位置，默认路径/tmp/mysql.sock</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre><p>–socket=/tmp/mysqld.sock</p></blockquote><blockquote><pre><code>--tab,-T</code></pre></blockquote><blockquote><pre><code>为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。注意使用--tab不能指定--</code></pre><p>databases参数</p></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost test test --tab=&quot;/home/mysql&quot;</code></pre></blockquote><blockquote><pre><code>--tables</code></pre></blockquote><blockquote><pre><code>覆盖--databases (-B)参数，指定需要导出的表名，在后面的版本会使用table取代tables。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --databases test --tables test</code></pre></blockquote><blockquote><pre><code>--triggers</code></pre></blockquote><blockquote><pre><code>导出触发器。该选项默认启用，用--skip-triggers禁用它。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --triggers</code></pre></blockquote><blockquote><pre><code>--tz-utc</code></pre></blockquote><blockquote><pre><code>在导出顶部设置时区TIME_ZONE=&apos;+00:00&apos; ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --tz-utc</code></pre></blockquote><blockquote><pre><code>--user, -u</code></pre></blockquote><blockquote><pre><code>指定连接的用户名。</code></pre></blockquote><blockquote><pre><code>--verbose, --v</code></pre></blockquote><blockquote><pre><code>输出多种平台信息。</code></pre></blockquote><blockquote><pre><code>--version, -V</code></pre></blockquote><blockquote><pre><code>输出mysqldump版本信息并退出</code></pre></blockquote><blockquote><pre><code>--where, -w</code></pre></blockquote><blockquote><pre><code>只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --where=&quot;</code></pre><p>user=’root’”</p></blockquote><blockquote><pre><code>--xml, -X</code></pre></blockquote><blockquote><pre><code>导出XML格式.</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --xml</code></pre></blockquote><blockquote><pre><code>--plugin_dir</code></pre></blockquote><blockquote><pre><code>客户端插件的目录，用于兼容不同的插件版本。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases</code></pre><p>–plugin_dir=”/usr/local/lib/plugin”</p></blockquote><blockquote><pre><code>--default_auth</code></pre></blockquote><blockquote><pre><code>客户端插件默认使用权限。</code></pre></blockquote><blockquote><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --default-</code></pre><p>auth=”/usr/local/lib/plugin/<plugin>“</plugin></p></blockquote><blockquote></blockquote><blockquote><p>参数说明</p></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote><p><strong>2.恢复逻辑备份</strong></p></blockquote><blockquote><pre><code>#在mysql命令下，用source命令导入备份文件：</code></pre></blockquote><blockquote><pre><code>mysql&gt;  USE 数据库名;</code></pre></blockquote><blockquote><pre><code>mysql&gt;  source 备份文件.sql;</code></pre></blockquote><blockquote></blockquote><p>注意：只能在cmd界面下执行source命令，不能在mysql工具里面执行source命令，会报错，因为cmd是直接调用mysql.exe来执行命令的。　　</p><blockquote></blockquote><blockquote></blockquote><p>可避免脏读情况发生</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 之 数据操作</title>
      <link href="/2018/02/28/cnblog_8485204/"/>
      <url>/2018/02/28/cnblog_8485204/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-之-数据操作👈的摘要"><a href="#这是👉MySQL-之-数据操作👈的摘要" class="headerlink" title="这是👉MySQL 之 数据操作👈的摘要"></a><a href="/2018/02/28/cnblog_8485204/">这是👉MySQL 之 数据操作👈的摘要</a></h1><a id="more"></a><h1 id="阅读目录"><a href="#阅读目录" class="headerlink" title="阅读目录"></a>阅读目录</h1><ul><li>一 介绍</li><li>二 插入数据 INSERT</li><li>三 更新操作 UPDATE</li><li>四 删除操作 DELETE</li><li>五 查询操作 SELECT</li></ul><h2 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一  介绍"></a>一  介绍</h2><p>在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括</p><ol><li>使用INSERT实现数据的插入</li><li>UPDATE实现数据的更新</li><li>使用DELETE实现数据的删除</li><li>使用SELECT查询数据。</li></ol><h2 id="二-插入数据-INSERT"><a href="#二-插入数据-INSERT" class="headerlink" title="二 插入数据 INSERT"></a>二 插入数据 INSERT</h2><pre><code>#语法一: 按字段进行插入insert into 表(字段1,字段2 ...) values (值1,值2 ...);#语法二:按字段顺序插入insert into 表 values (值1,值2 ...);#语法三: 插入多条记录insert into 表 values (值1,值2 ...) ,(值1,值2 ...)  ,(值1,值2 ...); #语法四:插入查询结果insert into 表(字段1,字段2 ...)  select 字段1,字段2 ... from 表;    </code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>四种插入数据方式:一.插入一条数据insert into student(id,name,age,sex,salary) values(1,&apos;小猪&apos;,18,&apos;男&apos;,2500);二.插入多条数据insert into student(id,name,age,sex,salary) values(1,&apos;小猪&apos;,18,&apos;男&apos;,2500) ,(2,&apos;小猪2&apos;,28,&apos;男&apos;,2500),(3,&apos;小猪3&apos;,38,&apos;男&apos;,2500);三.直接插入insert into student values(1,&apos;小猪&apos;,18,&apos;男&apos;,2500);ps:如果插入的数据个数和位置正好与表的字段个数和位置匹配,则可以省略表名后面的字段定义四.查询并插入insert into student(id,name,age) select id,name,age from tb ;ps:从tb表中查询数据并插入到 student表中</code></pre><p>代码示例</p><h2 id="三-更新操作-UPDATE"><a href="#三-更新操作-UPDATE" class="headerlink" title="三 更新操作 UPDATE"></a>三 更新操作 UPDATE</h2><pre><code>#语法一: 更新整表数据update 表 set 字段1= &apos;值1&apos;, 字段2=&apos;值2&apos; ... ; #语法二:更新符合条件字段3的数据update 表 set 字段1= &apos;值1&apos;, 字段2=&apos;值2&apos; ... where 字段3 = 值3; </code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>方式一:update student set name = &apos;猪猪哥&apos; ;ps: student表中所有的 name 字段 的值 全部被更新为 &apos;猪猪哥&apos;方式二:update student set name= &apos;猪猪哥&apos; ,age =13  where id = 2;ps: 更新 student 表中 name 和 age 字段的值,并且只更新 id = 2的一条记录</code></pre><p>代码示例</p><h2 id="四-删除操作-DELETE"><a href="#四-删除操作-DELETE" class="headerlink" title="四 删除操作 DELETE"></a>四 删除操作 DELETE</h2><pre><code>#语法一:整表数据删除delete from 表 ; #语法二:删除符合 where后条件的数据delete from 表 where 字段1=值1; </code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>方式一:delete from student;ps:删除 student 表中所有的数据,注意:如果有自增主键,主键记录的值不会被删除.方式二:delete from student where id=1;ps:只删除id 为1的数据.方式三:truncate student;ps:清空表</code></pre><p>代码示例</p><p><strong>truncate和delete的区别？[面试题]</strong></p><pre><code> 1、TRUNCATE 在各种表上无论是大的还是小的都非常快。而DELETE 操作会被表中数据量的大小影响其执行效率.2、TRUNCATE是一个DDL语言而DELETE是DML语句，向其他所有的DDL语言一样，他将被隐式提交，不能对TRUNCATE使用ROLLBACK命令。3、TRUNCATE不能触发触发器，DELETE会触发触发器。4、当表被清空后表和表的索引和自增主键将重新设置成初始大小，而delete则不能。</code></pre><h2 id="五-查询操作-SELECT"><a href="#五-查询操作-SELECT" class="headerlink" title="五 查询操作 SELECT"></a>五 查询操作 SELECT</h2><p>根据查询功能的不同,我们可以为查询划分为以下几类:</p><p>1.单表查询</p><p><a href="http://www.cnblogs.com/wangfengming/articles/8064956.html" target="_blank" rel="noopener">具体操作详见:<br>http://www.cnblogs.com/wangfengming/articles/8064956.html</a></p><p>2.多表查询</p><p><a href="http://www.cnblogs.com/wangfengming/articles/8067220.html" target="_blank" rel="noopener">具体操作详见:<br>http://www.cnblogs.com/wangfengming/articles/8067220.html</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 之 表操作</title>
      <link href="/2018/02/28/cnblog_8485190/"/>
      <url>/2018/02/28/cnblog_8485190/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-之-表操作👈的摘要"><a href="#这是👉MySQL-之-表操作👈的摘要" class="headerlink" title="这是👉MySQL 之 表操作👈的摘要"></a><a href="/2018/02/28/cnblog_8485190/">这是👉MySQL 之 表操作👈的摘要</a></h1><a id="more"></a><h1 id="阅读目录"><a href="#阅读目录" class="headerlink" title="阅读目录"></a>阅读目录</h1><ul><li>一 什么是表</li><li>二 创建表</li><li>三 查询表数据</li><li>四 修改表结构</li><li>五 删除表</li><li>六 复制表</li><li>七 数据库存储引擎</li><li>八 数据类型</li></ul><h2 id="一-什么是表"><a href="#一-什么是表" class="headerlink" title="一 什么是表"></a>一 什么是表</h2><p>表(TABLE) 是一种结构化的文件，可用来存储某种特定类型的数据。表中的一条记录有对应的标题，标题 称之为 表的字段。</p><p><img src="https://images2018.cnblogs.com/blog/1284211/201802/1284211-20180221133025676-605361970.png" alt=""></p><h2 id="二-创建表"><a href="#二-创建表" class="headerlink" title="二 创建表"></a>二 创建表</h2><pre><code>CREATE TABLE 表名(字段名1 类型[(宽度) 约束条件],字段名2 类型[(宽度) 约束条件],字段名3 类型[(宽度) 约束条件])ENGINE=innodb DEFAULT CHARSET utf8;</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>create table student(    id int not null auto_increment primary key,    name varchar(250) not null,    age int not null,    sex enum(&apos;男&apos;,&apos;女&apos;) not null default &apos;男&apos;,    salary double(10,2) not null)engine=innodb default charset=utf8;ps: not null :表示此列不能为空     auto_increment :表示自增长,默认每次增长+1注意:自增长只能添加在主键或者唯一索引字段上primary key :表示主键(唯一且不为空)engine =innodb :表示指定当前表的存储引擎default charset utf8 :设置表的默认编码集</code></pre><p>创建表</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。            create table tb1(                nid int not null auto_increment primary key,                num int null            )            或            create table tb1(                nid int not null,                num int not null,                primary key(nid,num)            )</code></pre><p>主键</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）            create table tb1(                nid int not null auto_increment primary key,                num int null            )            或            create table tb1(                nid int not null auto_increment,                num int null,                index(nid)            )注意：1、对于自增列，必须是索引（含主键）。         2、对于自增可以设置步长和起始值     show session variables like &apos;auto_inc%&apos;;     set session auto_increment_increment=2;     set session auto_increment_offset=10;      show global  variables like &apos;auto_inc%&apos;;      set global auto_increment_increment=2;      set global auto_increment_offset=10; </code></pre><p>自增</p><h2 id="三-查询表数据"><a href="#三-查询表数据" class="headerlink" title="三.查询表数据"></a>三.查询表数据</h2><pre><code>#查询表数据select 字段(多个以&quot;,&quot;间隔) from 表名;例:  select name,sex from student;或者: select * from student;#查看表结构desc 表名;例: desc student;#查看创建表信息show create table student;　　</code></pre><h2 id="四-修改表结构"><a href="#四-修改表结构" class="headerlink" title="四.修改表结构"></a>四.修改表结构</h2><pre><code>#添加表字段alter table 表名 add 字段名 类型 约束;例如: alter table student add age int not null default 0 after name;ps: after name 表示在name字段后添加字段 age. #修改表字段方式一: alter table student modify 字段 varchar(100) null;方式二: alter table student change 旧字段 新字段 int not null default 0;ps:二者区别:change 可以改变字段名字和属性modify只能改变字段的属性#删除表字段 :alter table student drop 字段名;#更新表名称:rename table 旧表名 to 新表名;</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#添加主键 : alter table student add primary key(字段,&quot;多个&quot;,&quot;间隔&quot;);#移除主键 : alter table student drop primary key;ps:如果主键为自增长,以上方式则不被允许执行,请先去掉主键自增长属性,然后再移除主键alter table student modify id int not null,drop primary key </code></pre><p>更新主键操作</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#添加外键: alter table 从表 add CONSTRAINT fk_test foreign key 从表(字段) REFERENCES 主表(字段);#移除外键: alter table 表 drop foreign key 外键名称;ps:如果外键设置后想修改,那么只能是先删除,再添加</code></pre><p>外键更新操作</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#修改默认值 : alter table 表 alter 字段 set default 100;#删除默认值 :alter table 表 alter 字段 drop default;</code></pre><p>默认值更新操作</p><h2 id="五-删除表"><a href="#五-删除表" class="headerlink" title="五.删除表"></a>五.删除表</h2><pre><code>#删除表drop table 表名;#清空表truncate table 表名;　　</code></pre><h2 id="六-复制表"><a href="#六-复制表" class="headerlink" title="六.复制表"></a>六.复制表</h2><pre><code>#只复制表结构和表中数据CREATE TABLE tb2 SELECT * FROM tb1;ps:主键自增/索引/触发器/外键 不会 被复制#只复制表结构create table tb2 like tb1;ps: 数据/触发器/外键 不会被复制　</code></pre><h2 id="七-数据库存储引擎"><a href="#七-数据库存储引擎" class="headerlink" title="七 数据库存储引擎"></a>七 数据库存储引擎</h2><p>   <a href="http://www.cnblogs.com/wangfengming/p/7930333.html" target="_blank" rel="noopener">详情参考:<br>http://www.cnblogs.com/wangfengming/p/7930333.html</a></p><h2 id="八-数据类型"><a href="#八-数据类型" class="headerlink" title="八.数据类型"></a>八.数据类型</h2><p>MySQL支持多种类型，大致可以分为四类：数值、字符串类型、日期/时间和其他类型。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>二进制类型:    bit[(M)]       二进制位（101001），m表示二进制位的长度（1-64），默认m＝1整数类型:    tinyint[(m)] [unsigned] [zerofill]        小整数，数据类型用于保存一些范围的整数数值范围：        有符号：-128 ～ 127.        无符号：255        特别的： MySQL中无布尔值，使用tinyint(1)构造。    int[(m)][unsigned][zerofill]        整数，数据类型用于保存一些范围的整数数值范围：        有符号： -2147483648 ～ 2147483647        无符号：4294967295    bigint[(m)][unsigned][zerofill]        大整数，数据类型用于保存一些范围的整数数值范围：        有符号：-9223372036854775808 ～ 9223372036854775807        无符号：18446744073709551615作用：存储年龄，等级，id，各种号码等注意：为该类型指定宽度时，仅仅只是指定查询结果的显示宽度，与存储范围无关，所以我们使用默认的就可以了    有符号和无符号的最大数字需要的显示宽度均为10，    而针对有符号的最小值则需要11位才能显示完全，所以int类型默认的显示宽度为11是非常合理的小数型:    decimal[(m[,d])] [unsigned] [zerofill]        准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。        特别的：对于精确数值计算时需要用此类型        decaimal能够存储精确值的原因在于其内部按照字符串存储。    FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]        单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。        有符号：(-3.402823466E+38 to -1.175494351E-38),0,(1.175494351E-38 to 3.402823466E+38)        无符号：0，(1.175 494 351 E-38，3.402 823 466 E+38)        **** 数值越大，越不准确 ****    DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]        双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。        有符号：(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，               (2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)        无符号：0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)        **** 数值越大，越不准确 ****作用：存储薪资、身高、体重、体质参数等字符型:    char (m)        char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。        PS: 即使数据小于m长度，也会占用m长度,但是在查询时，查出的结果会自动删除尾部的空格        特点:定长，简单粗暴，浪费空间，存取速度快    varchar(m)        varchar 数据类型用于变长的字符串，可以包含最多达65535个字符(理论上可以,但是实际上在超出21845长度后,mysql会自动帮您转换数据类型为文本类型)。        其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。        PS: varchar类型存储数据的真实内容，例如:如果&apos;ab  &apos;,尾部的空格也会被存起来        强调：varchar类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数（1-2Bytes最大表示65535个数字，正好符合mysql对row的最大字节限制，即已经足够使用）        如果真实的数据&lt;255bytes则需要1Bytes的前缀（1Bytes=8bit 2**8最大表示的数字为255）        如果真实的数据&gt;255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535）        特点:变长，精准，节省空间，存取速度慢        sql优化：创建表时，定长的类型往前放，变长的往后放                        比如性别          比如地址或描述信息        PS：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。            因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡                text        text数据类型用于保存变长的大字符串，可以最多到65535 (2**16 − 1)个字符。枚举类型(了解):          enum        An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)        示例：            CREATE TABLE user (             name VARCHAR(40),             sex ENUM(&apos;男&apos;, &apos;女&apos;, &apos;未知&apos;)            );            INSERT INTO user (name, sex) VALUES (&apos;人1&apos;,&apos;男&apos;), (&apos;人2&apos;,&apos;女&apos;),                                                (&apos;人3&apos;,&apos;未知&apos;),(&apos;人4&apos;,&apos;人妖&apos;);            PS:人4会插入成功吗??        集合类型(了解):    set        A SET column can have a maximum of 64 distinct members.        示例：        CREATE TABLE myset (col SET(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;));        INSERT INTO myset (col) VALUES (&apos;a,d&apos;), (&apos;d,a&apos;), (&apos;a,d,a&apos;), (&apos;a,d,d&apos;), (&apos;d,a,d&apos;);日期/时间类型:    DATE     日期值        YYYY-MM-DD（1000-01-01/9999-12-31）    TIME  时间值或持续时间        HH:MM:SS（&apos;-838:59:59&apos;/&apos;838:59:59&apos;）    YEAR 年份值        YYYY（1901/2155）    DATETIME 混合日期和时间值        YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59）    TIMESTAMP 时间戳        YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时）作用：存储用户注册时间，文章发布时间，员工入职时间，出生时间，过期时间等</code></pre><p>数据类型</p><p>详情参考:</p><ul><li><a href="http://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-data-types.html</a></li><li><a href="http://dev.mysql.com/doc/refman/5.7/en/data-type-overview.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/data-type-overview.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 之 库操作</title>
      <link href="/2018/02/28/cnblog_8485174/"/>
      <url>/2018/02/28/cnblog_8485174/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-之-库操作👈的摘要"><a href="#这是👉MySQL-之-库操作👈的摘要" class="headerlink" title="这是👉MySQL 之 库操作👈的摘要"></a><a href="/2018/02/28/cnblog_8485174/">这是👉MySQL 之 库操作👈的摘要</a></h1><a id="more"></a><h1 id="阅读目录"><a href="#阅读目录" class="headerlink" title="阅读目录:"></a><strong>阅读目录:</strong></h1><ul><li><strong>一 系统数据库</strong></li><li><strong>二 数据库操作</strong></li><li><strong>三 命名规范</strong></li><li><strong>四 用户权限</strong></li><li><strong>五.修改密码</strong></li><li><strong>六  忘记密码</strong></li><li><strong>七  中文乱码问题</strong></li></ul><h2 id="一-系统数据库"><a href="#一-系统数据库" class="headerlink" title="一.系统数据库"></a>一.系统数据库</h2><ul><li>information_schema ：虚拟库，不占用磁盘空间，存储的是数据库启动后的一些参数，如用户表信息、列信息、权限信息、字符信息等</li><li>mysql：核心数据库，里面包含用户、权限、关键字等信息。不可以删除</li><li>performance_schema：mysql 5.5版本后添加的新库，主要收集系统性能参数，记录处理查询请求时发生的各种事件、锁等现象 </li><li>sys : mysql5.7版本新增加的库,通过这个库可以快速的了解系统的元数据信息,可以方便DBA发现数据库的很多信息，解决性能瓶颈都提供了巨大帮助</li></ul><h2 id="二-数据库操作"><a href="#二-数据库操作" class="headerlink" title="二.数据库操作"></a>二.数据库操作</h2><p>1.创建数据库</p><pre><code>#语法: CREATE DATABASE db_name charset utf8;</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#创建一个名字为 db_name 的数据库,并指定当前库的编码集为utf8CREATE DATABASE db_name charset utf8;</code></pre><p>示例</p><p>2.查看数据库</p><pre><code>#查询当前用户下所有数据库show databases;#查看创建数据库的信息show create database db_name;#查询当前操作所在的数据库名称select database();</code></pre><p>3.选择数据库</p><pre><code>USE db_name;</code></pre><p>4.删除数据库</p><pre><code>DROP DATABASE db_name;</code></pre><h2 id="三-命名规范"><a href="#三-命名规范" class="headerlink" title="三.命名规范"></a>三.命名规范</h2><pre><code>可以由字母、数字、下划线、＠、＃、＄区分大小写唯一性不能使用关键字如: CREATE SELECT不能单独使用数字最长128位</code></pre><h2 id="四-用户权限"><a href="#四-用户权限" class="headerlink" title="四.用户权限"></a>四.用户权限</h2><p>1.用户管理</p><pre><code>创建用户    create user &apos;用户名&apos;@&apos;IP地址&apos; identified by &apos;密码&apos;;删除用户    drop user &apos;用户名&apos;@&apos;IP地址&apos;;修改用户    rename user &apos;用户名&apos;@&apos;IP地址&apos;; to &apos;新用户名&apos;@&apos;IP地址&apos;;</code></pre><p>2.授权管理</p><pre><code>show grants for &apos;用户&apos;@&apos;IP地址&apos;                  -- 查看权限grant  权限 on 数据库.表 to   &apos;用户&apos;@&apos;IP地址&apos;      -- 授权revoke 权限 on 数据库.表 from &apos;用户&apos;@&apos;IP地址&apos;      -- 取消权限</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#创建新用户create user &apos;alex&apos;@&apos;localhost&apos; identified &apos;123456&apos;;#授权方式一:为alex授权 db1数据库下的所有表的 查询.更新.修改权限grant select,update,delete on db1.*  to &apos;alex&apos;@&apos;localhost&apos;;#授权方式二:为alex 授权 所有库的所有权限(除grant权限外)grant all privileges on *.*  to &apos;alex&apos;@&apos;localhost&apos;;#刷新用户权限flush privileges;</code></pre><p>创建用户及授权例子</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>all privileges  除grant外的所有权限select          仅查权限select,insert   查和插入权限...usage                   无访问权限alter                   使用alter tablealter routine           使用alter procedure和drop procedurecreate                  使用create tablecreate routine          使用create procedurecreate temporary tables 使用create temporary tablescreate user             使用create user、drop user、rename user和revoke  all privilegescreate view             使用create viewdelete                  使用deletedrop                    使用drop tableexecute                 使用call和存储过程file                    使用select into outfile 和 load data infilegrant option            使用grant 和 revokeindex                   使用indexinsert                  使用insertlock tables             使用lock tableprocess                 使用show full processlistselect                  使用selectshow databases          使用show databasesshow view               使用show viewupdate                  使用updatereload                  使用flushshutdown                使用mysqladmin shutdown(关闭MySQL)super                   使用change master、kill、logs、purge、master和set global。还允许mysqladmin调试登陆replication client      服务器位置的访问replication slave       由复制从属使用</code></pre><p>权限列表</p><h2 id="五-修改密码"><a href="#五-修改密码" class="headerlink" title="五.修改密码"></a>五.修改密码</h2><p><strong>方式一:</strong> mysqladmin 命令</p><pre><code>mysqladmin -u用户名 -p密码 password 新密码</code></pre><p><strong>方式二</strong> : 直接设置用户密码</p><pre><code>set password for &apos;用户名&apos;@&apos;IP&apos; = password(&apos;新密码&apos;);flush privileges;</code></pre><p><strong>方式三:</strong> 修改mysql库下的user表</p><pre><code>5.7版本修改密码方式:update mysql.user set authentication_string=password(&apos;新密码&apos;) where user= &apos;用户名&apos;             flush privileges; -- 刷新权限5.6 版本update mysql.user set password = password(&apos;新密码&apos;) where user= &apos;用户名&apos; flush privileges; -- 刷新权限</code></pre><h2 id="六-忘记密码"><a href="#六-忘记密码" class="headerlink" title="六.忘记密码"></a>六.忘记密码</h2><pre><code>在忘记root密码的时候，可以这样:#1.首先打开cmd 窗口,关闭mysql服务    net stop mysql #2.然后跳过权限检查,启动mysql,输入命令    mysqld --skip-grant-tables#3.重新打开一个新的cmd窗口,启动客户端(已跳过权限检查,可以直接登录)    mysql #4.直接进来,修改密码update mysql.user set authentication_string=password(&apos;123456&apos;) where user=&apos;root&apos;;#5. 刷新权限flush privileges;</code></pre><h2 id="七-中文乱码问题"><a href="#七-中文乱码问题" class="headerlink" title="七.中文乱码问题"></a>七.中文乱码问题</h2><p>1.查询字符编码</p><pre><code>SHOW VARIABLES LIKE &apos;char%&apos;;</code></pre><p>2.制服乱码</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#修改方法:#1. 创建my.ini文件,放在mysql根路径下#2. 在该文件中添加以下内容即可:#3.添加此文件后需要重新启动服务,以保证此文件生效------------------------------------------------------------[client]default-character-set=utf8[mysql]#设置mysql客户端默认字符集default-character-set=utf8[mysqld]#设置3306端口port = 3306#允许最大连接数max_connections=200#服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8#创建新表时将使用的默认存储引擎default-storage-engine=INNODB#解决mysql在执行sql语句后出现1055错误,sql_mode = only_full_group_by不相容sql_mode=&apos;NO_ENGINE_SUBSTITUTION&apos;</code></pre><p>乱码已死</p><p> 注意:如果使用的是mysql5.7版本,则需要创建my.ini文件,5.7版本以前数据库自带my,ini文件,直接改动编码即可.</p><p> 目前最稳定与常用的数据库版本为(5.6版本与5.5版本)</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 之 基本概念</title>
      <link href="/2018/02/28/cnblog_8485161/"/>
      <url>/2018/02/28/cnblog_8485161/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-之-基本概念👈的摘要"><a href="#这是👉MySQL-之-基本概念👈的摘要" class="headerlink" title="这是👉MySQL 之 基本概念👈的摘要"></a><a href="/2018/02/28/cnblog_8485161/">这是👉MySQL 之 基本概念👈的摘要</a></h1><a id="more"></a><p><strong>**</strong>一. 概述(了解)**</p><p><strong> 二. 数据库特点(了解)</strong></p><p><strong> 三. 数据库分类</strong></p><p><strong> 四. MySQL介绍</strong></p><p><strong> 五. 下载及安装</strong></p><p><strong> 六. 啥是SQL?</strong></p><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><p><strong>数据库(Database，简称DB)</strong></p><p>数据库技术是计算机应用领域中非常重要的技术，它产生于 20世纪60年代末，是数据管理的最新技术，也是软件技术的一个重要分支。</p><p>简单的说， <strong>数据库</strong><br>就是一个存放数据的仓库，这个仓库是按照一定的数据结构（数据结构是指数据的组织形式或数据之间的联系）来组织、存储的，我们可以通过数据库提供的多种方法来管理数据库里的数据。更简单的形象理解，数据库和我们生活中存放杂物的仓库性质一样，区别只是存放的东西不同。</p><p><strong>数据库表(table)</strong></p><pre><code>　　数据表是关系数据库中一个非常重要的对象，是其它对象的基础，也是一系列 二维数组的集合，用来存储、操作数据的逻辑结构。根据信息的分类情况。  一个数据库中可能包含若干个数据表，每张表是由行和列组成，记录一条数据,数据表就增加一行，每一列是由字段名和字段数据集合组成，列被称之为字段，  每一列还有自己的多个属性，例如是否允许为空、默认值、长度、类型、存储编码、注释等.例如</code></pre><p><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171229150634601-1911319125.png" alt=""></p><p><strong>  数据(data)</strong></p><p>存储在表中的 信息就叫做数据.</p><p><strong>数据库系统有3个主要的组成部分</strong></p><p>1.数据库（Database System）：用于存储数据的地方。</p><p>2.数据库管理系统（Database Management System，DBMS）：用户管理数据库的软件。</p><p>3.数据库应用程序（Database Application）：为了提高数据库系统的处理能力所使用的管理数据库的软件补充。</p><p><strong>数据库的发展史(五个阶段)</strong></p><pre><code>　　　1.文件系统　　　　　　数据库系统的萌芽阶段,通过文件来存取数据.          文件系统是数据库系统的萌芽阶段，出现在上世纪五六十年代，可以提供简单的数据存取功能，但无法提供完整、统一的数据管理功能，例如复杂查询等。所以在管理较少、较简单的数据或者只是用来存取简单数据，没有复杂操作的情况下，会使用文件系统　　　  　　　2.层次型数据库　　　　　　数据库系统真正开始阶段,数据的存储形式类似树形结构,所以也叫树型数据库.　　　  　　　3.网状数据库　　　　　　数据的存储形式类似网状结构.          从二十世纪六十年代开始，第一代数据库系统（层次模型数据库系统、网状模型数据库系统）相继问世，它们为统一管理和共享数据提供了有力的支撑在这个阶段，网状模型数据库由于它的复杂、专用性，没有被广泛使用。而在层次模型数据库中，IBM公司的IMS（Information Management System，信息管理系统）层次模型数据库系统则得到了极大的发展，一度成为最大的数据库管理系统，拥有巨大的客户群　　　4.关系型数据库        二十世纪七十年代初，关系型数据库系统开始走上历史舞台，并一直保持着蓬勃的生命力.关系型数据库系统使用结构化查询语言（Structured Query Language，SQL）作为数据库定义语言DDL和数据库操作语言DML　　  5.面向对象数据库        把面向对象的方法和数据库技术结合起来，可以使数据库系统的分析、设计最大程度地与人们对客观世界的认识相一致，并且能够有效的为面向对象程序提供更好的数据库支撑</code></pre><h2 id="二-数据库的特点"><a href="#二-数据库的特点" class="headerlink" title="二.数据库的特点"></a>二.数据库的特点</h2><p><strong>⑴ 实现数据共享</strong></p><p>数据共享包含所有用户可同时存取数据库中的数据，也包括用户可以用各种方式通过接口使用数据库，并提供数据共享。</p><p><strong>⑵ 减少数据的冗余度</strong></p><p>同文件系统相比，由于数据库实现了数据共享，从而避免了用户各自建立应用文件。减少了大量重复数据，减少了数据冗余，维护了数据的一致性。</p><p><strong><strong>⑶  </strong></strong> <strong>数据一致性和可维护性，以确保数据的安全性和可靠性</strong></p><p>主要包括：①安全性控制：以防止数据丢失、错误更新和越权使用；</p><p>②完整性控制：保证数据的正确性、有效性和相容性；</p><p>③并发控制：使在同一时间周期内，允许对数据实现多路存取，又能防止用户之间的不正常交互作用。</p><p><strong><strong>⑷  </strong></strong> <strong>故障恢复</strong></p><p>由数据库管理系统提供一套方法，可及时发现故障和修复故障，从而防止数据被破坏。数据库系统能尽快恢复数据库系统运行时出现的故障，可能是物理上或是逻辑上的错误。比如对系统的误操作造成的数据错误等。</p><h2 id="三-数据库分类"><a href="#三-数据库分类" class="headerlink" title="三.数据库分类"></a>三.数据库分类</h2><p>在当今的互联网中，最常用的数据库模型主要是两种，即 <strong>关系型数据库</strong> 和 <strong>非关系型数据</strong> 库。</p><p>   1 关系型数据库介绍</p><p>(1) <strong>关系型数据库</strong> : 是把复杂的数据结构归结为简单的 二元关系（即二维表格形式）。</p><p>(2) 目前主流的关系型数据库:MySQL、Oracle 、 Sql server、DB2 。。。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>Oracle 是世界上使用最广泛的数据库,上世纪末随着网络浪潮的到来,Oracle推出9i这个版本,i表示internet，全面支持网络引用。10g,g是grid网格，是Oracle公司为迎接&quot;网格计算&quot;时代的来临而提供的数据库解决方案。MySQL是一个开源的、免费的关系型数据库,。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。SQL Server 微软公司的关系型数据库,一般.NET平台会将其作为首选.DB2是IBM出品的一系列关系型数据库管理系统，分别在不同的操作系统平台上服务。</code></pre><p>主流数据库介绍</p><pre><code>2  非关系型数据库介绍</code></pre><p>(1)非关系型数据库诞生背景</p><pre><code>**非关系型数据库** 也被成为NoSQL数据库，NOSQL的本意是&quot;Not Only SQL&quot;.而不是&quot;No SQL&quot;的意思，因此，NoSQL的产生并不是要彻底地否定非关系型数据库，而是作为传统关系型数据库的一个有效补充。NOSQL数据库在特定的场景下可以发挥出难以想象的高效率和高性能。    随着互联网Web2.0网站的兴起，传统的关系型数据库在应付web2,0网站，特别是对于规模日益扩大的海量数据，超大规模和高并发的微博、微信、SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题。 </code></pre><p>_<br>例如：传统的关系型数据库IO瓶颈、性能瓶颈都难以有效突破，于是出现了大批针对特定场景，以高性能和使用便利为目的功能特异化的数据库产品。NOSQL（非关系型）类的数据就是在这样的情景下诞生并得到了非常迅速的发展<br>_</p><pre><code>(2)  NOSQL非关系型数据库小结：   </code></pre><p>1、NOSQL不是否定关系数据库，而是作为关系数据库的一个重要补充<br>2、NOSQL为了高性能、高并发而生，但是要求对数据一致性要求不能高<br>3、NOSQL典型产品memcached （纯内存,k-v），redis（持久化缓存,k-v），mongodb（文档的数据库,xml-json)</p><h2 id="四-MySQL介绍"><a href="#四-MySQL介绍" class="headerlink" title="四.MySQL介绍"></a>四.MySQL介绍</h2><p>MySQL 数据库:是互联网领域里一款最重要的，深受广大用户欢迎的开源关系型数据库软件之一、由瑞典MySQL AB公司开发与维护。2008年。MySQL<br>AB公司被SUN公司收购，2009年，SUN公司又被传统数据数据库领域大佬甲骨文（oracle）公司收购，因此，MySQL数据库软件目前属于Oracle公司，成为传统数据库领域老大的又一个数据库产品，甲骨文公司收购MySQL后，使得自身在商业数据库与开源软件领域市场占有份额都跃居第一的位置，这样的格局，引起了很多人的担忧，这种担忧直接导致后来的Mysql分支数据库MariaDB的诞生于发展。</p><p><strong>MySQL 发展历史</strong></p><ul><li>1985 年，瑞典的几位志同道合小伙子(David Axmark、Allan Larsson 和Monty Widenius) 成立了一家公司，这就是MySQL AB 的前身。</li><li>1990年，TcX公司的客户中开始有人要求为他的API提供SQL支持。当时有人提议直接使用商用数据库，但是Monty觉得商用数据库的速度难以令人满意。于是，他直接借助于mSQL的代码，将它集成到自己的存储引擎中。令人失望的是，效果并不太令人满意，于是，Monty雄心大起，决心自己重写一个SQL支持。</li><li>1996年，MySQL 1.0发布，它只面向一小拨人，相当于内部发布。</li><li>1996年10月，MySQL 3.11.1发布(MySQL没有2.x版本)，最开始只提供Solaris下的二进制版本。一个月后，Linux版本出现了。</li><li>1999～2000年，MySQL AB公司在瑞典成立。Monty雇了几个人与Sleepycat合作，开发出了Berkeley DB引擎, 因为BDB支持事务处理，所以MySQL从此开始支持事务处理了。</li><li>2003年12月，MySQL 5.0版本发布，提供了视图、存储过程等功能。</li><li>2008年1月16日，Sun（太阳微系统）正式收购MySQL。</li><li>2009年4月20日，甲骨文公司宣布以每股9.50美元，74亿美元的总额收购Sun电脑公司。</li><li>2010年12月，MySQL 5.5发布，其主要新特性包括半同步的复制及对SIGNAL/RESIGNAL的异常处理功能的支持，最重要的是InnoDB存储引擎终于变为当前MySQL的默认存储引擎。</li><li><p>2013年6月18日，甲骨文公司修改MySQL授权协议，移除了GPL。但随后有消息称这是一个bug。</p><p><strong>为什么选择MySQL数据库?</strong></p></li></ul><p>（1） MySQL性能卓越、服务稳定，很少出现异常宕机<br>（2） MySQL开放源代码且无版权制约，自主性及使用成本低<br>   （3） MySQL历史悠久，社区及用户活跃，遇到问题可以解决<br>   （4） MySQL软件体积小，安装使用简单，并且易于维护，安装及维护成本低<br>   （5） MySQL品牌口碑效应，使得企业无需考虑就直接用<br>   （6） MySQL支持多用操作系统，提供多种API接口，支持多用开发语言，特别对流行的语言有很好的支持</p><p><strong>MariaDB 介绍 :</strong></p><p>出现在2009年.<br>MAriaDB数据库管理系统是MySQL数据库的一个分支，主要由开源社区维护，采用GPL授权许可。开发这个MariaDB的原因之一是：甲骨文公司收购了MySQL后，MySQL有闭源的潜在风险，因此MySQL开源社区采用分支的方式来避开这个风险。<a href="https://baike.baidu.com/item/mariaDB/6466119?fr=aladdin" target="_blank" rel="noopener">点击查看详情</a></p><p>MariaDB默认的存储引擎是Maria，不是MyISAM。Maria可以支持事务，但是默认情况下没有打开事务支持，因为事务支持对性能会有影响。可以通过以下语句，转换为支持事务的Maria引擎。ALTER<br>TABLE <code>tablename</code> ENGINE=MARIA TRANSACTIONAL=1;</p><h2 id="五-下载及安装"><a href="#五-下载及安装" class="headerlink" title="五.下载及安装"></a>五.下载及安装</h2><pre><code>a：官网下载mysql安装程序b：安装mysql服务端c：安装mysql客户端d：客户端连接服务端e：通过客户端向服务器发送命令，执行对数据库文件的增删改差操作。　</code></pre><p><strong>Windows版安装</strong></p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code># 1.下载：MySQL Community Server 5.7.20    https://dev.mysql.com/downloads/mysql/#2.解压将官网下载的解压包 解压到指定目录（例如 D：//mysql-5.7.20-winx64）#3.添加环境变量【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --&gt; 【将MySQL的bin目录路径追加到变值值中，用 ； 分割】C:\Program Files (x86)\Parallels\Parallels Tools\Applications;d:\mysql-5.7.16-winx64\bin#4.初始化mysqld --initialize-insecure#5.启动mysql服务mysqld#6.连接mysql服务mysql -uroot -p  回车,有密码输入密码,没有继续回车解压方式安装</code></pre><p>解压方式安装</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>ps:制作服务必须使用全路径方式# 制作MySQL的Windows服务，在终端执行此命令：&quot;c:\mysql-5.7.16-winx64\bin\mysqld&quot; --install# 移除MySQL的Windows服务，在终端执行此命令：&quot;c:\mysql-5.7.16-winx64\bin\mysqld&quot; --remove&apos;# 启动MySQL服务net start mysql(后面不加分号)# 关闭MySQL服务net stop mysql(后面不加分号)</code></pre><p>制作服务</p><p>在启动mysql服务后，打开windows任务管理器，会有一个名为mysqld.exe的进程运行，所以mysqld.exe是MySQL服务器程序。</p><p>退出登录：quit 或 exit 或 \q ;</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>nextnextnext....ps:mis方式安装,会安装的东西比较全,使用起来比较方便</code></pre><p>推荐:mis方式安装</p><p>  <strong>Linux版本</strong></p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code> 1、下载地址：http://dev.mysql.com/downloads/mysql/5.6.html#downloads也可以直接复制64位的下载地址，通过命令下载：wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz2、解压#解压tar -zxvf mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz#复制解压后的mysql目录cp -r mysql-5.6.33-linux-glibc2.5-x86_64 /usr/local/mysql3、添加用户组和用户#添加用户组groupadd mysql#添加用户mysql 到用户组mysqluseradd -g mysql mysql4、安装cd /usr/local/mysql/&lt;br&gt;mkdir ./data/mysqlchown -R mysql:mysql ././scripts/mysql_install_db --user=mysql --datadir=/usr/local/mysql/data/mysqlcp support-files/mysql.server /etc/init.d/mysqldchmod 755 /etc/init.d/mysqldcp support-files/my-default.cnf /etc/my.cnf#修改启动脚本vi /etc/init.d/mysqld#修改项：basedir=/usr/local/mysql/datadir=/usr/local/mysql/data/mysql#启动服务service mysqld start#测试连接./mysql/bin/mysql -uroot#加入环境变量，编辑 /etc/profile，这样可以在任何地方用mysql命令了export PATH=$PATH:/usr/local/mysql//bin&lt;br&gt;source /etc/profile#启动mysqlservice mysqld start#关闭mysqlservice mysqld stop#查看运行状态service mysqld status5、错误5.1 sqlyog连接时，报1130错误，是由于没有给远程连接的用户权限问题解决1:更改 &apos;mysql&apos;数据库&apos;user&apos;表&apos;host&apos;项，从&apos;localhost&apos;改成&apos;%&apos;。use mysql;select &apos;host&apos; from user where user=&apos;root&apos;; update user set host = &apos;%&apos; where user =&apos;root&apos;;flush privileges; 解决2：直接授权GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;youpassword&apos; WITH GRANT OPTION;5.2 安装时的一些错误-bash: ./scripts/mysql_install_db: /usr/bin/perl: bad interpreter: 没有那个文件或目录解决： yum -y install perl perl-develInstalling MySQL system tables..../bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory解决：yum -y install libaio-devel</code></pre><p>linux版本安装</p><p><a href="http://www.cnblogs.com/wangfengming/articles/7880595.html" target="_blank" rel="noopener">参考博客:http://www.cnblogs.com/wangfengming/articles/7880595.html</a></p><h2 id="六-啥是SQL"><a href="#六-啥是SQL" class="headerlink" title="六.啥是SQL?"></a>六.啥是SQL?</h2><p>上面咱们介绍过数据库的组成部分,其中数据库管理系统可以接收一些命令，对数据文件进行添加、删除、修改、查询等操作。那么这些命令就是 SQL .</p><p>SQL：(Structured Query Language)是 <strong>结构化查询语 言</strong>缩写。是一门专门与数据库管理系统打交道的语言。</p><p>SQL语言:是关系型数据库的标准语言, 其主要用于存取数据，查询数据，更新数据和管理数据库系统等操作。</p><p>具体可以把SQL分为4个部分:</p><p><strong>数据控制语言 ( DCL)</strong> ： 主要用于控制用户的访问权限。其中GRANT语句用于给用户增加权限，REVOKE语句用于收回用户的权限</p><p><strong>数据定义语言（DDL）</strong><br>：DROP、CREATE、ALTER等语句；数据库定义语言。主要用于定义数据库，表，视图，索引和触发器等。CREATE语句主要用于创建数据库，创建表，创建视图。ALTER语句主要用于修改表的定义，修改视图的定义。DROP语句主要用于删除数据库，删除表和删除视图等。</p><p><strong>数据操作语言（DML）</strong><br>：INSERT、UPDATE、DELETE语句；数据库操作语言。主要用于插入数据，更新数据，删除数据。INSERT语句用于插入数据，UPDATE语句用于更新数据，DELETE语句用于删除数据.</p><p><strong>数据查询语言（DQL）</strong> ：SELECT语句。主要用于查询数据。</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#1. 操作文件夹        增：create database db1 charset utf8;        查：show databases;        改：alter database db1 charset latin1;        删除: drop database db1;#2. 操作文件    先切换到文件夹下：use db1        增：create table t1(id int,name char);        查：show tables        改：alter table t1 modify name char(3);              alter table t1 change name name1 char(2);        删：drop table t1;#3. 操作文件中的内容/记录        增：insert into t1 values(1,&apos;egon1&apos;),(2,&apos;egon2&apos;),(3,&apos;egon3&apos;);        查：select * from t1;        改：update t1 set name=&apos;sb&apos; where id=2;        删：delete from t1 where id=1;        清空表：            delete from t1; #如果有自增id，新增的数据，仍然是以删除前的最后一样作为起始。            truncate table t1;数据量大，删除速度比上一条快，且直接从零开始，            auto_increment 表示：自增            primary key 表示：约束（不能重复且不能为空）；加速查找</code></pre><p>….</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 练习2</title>
      <link href="/2018/02/27/cnblog_8480101/"/>
      <url>/2018/02/27/cnblog_8480101/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-练习2👈的摘要"><a href="#这是👉MySQL-练习2👈的摘要" class="headerlink" title="这是👉MySQL 练习2👈的摘要"></a><a href="/2018/02/27/cnblog_8480101/">这是👉MySQL 练习2👈的摘要</a></h1><a id="more"></a><h2 id="1-表关系"><a href="#1-表关系" class="headerlink" title="1. 表关系"></a>1. <strong>表关系</strong></h2><p>  <strong><br><img src="https://images2017.cnblogs.com/blog/1284211/201712/1284211-20171227145517941-1937479585.png" alt=""></strong></p><p> 注意:创建表时,根据合理性设置字段的长度和类型.</p><pre><code>CREATE TABLE `person` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(32) NOT NULL,  `age` int(10) DEFAULT NULL,  `salary` int(10) DEFAULT NULL,  `leader` char(1) NOT NULL DEFAULT &apos;0&apos;,  `menpai` varchar(32) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</code></pre><p>创建部门表:</p><pre><code>CREATE TABLE `dept` (  `did` int(11) NOT NULL AUTO_INCREMENT,  `dname` varchar(32) NOT NULL,  `address` varchar(32) NOT NULL,  PRIMARY KEY (`did`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;INSERT INTO dept VALUES(1,&apos;武当&apos;,&apos;湖北&apos;);INSERT INTO dept VALUES(2,&apos;华山&apos;,&apos;陕西&apos;);INSERT INTO dept VALUES(3,&apos;嵩山&apos;,&apos;河南&apos;);INSERT INTO dept VALUES(4,&apos;日月神教&apos;,&apos;黑木崖&apos;);</code></pre><h2 id="2-下面-开始你的表演"><a href="#2-下面-开始你的表演" class="headerlink" title="2.下面:开始你的表演"></a>2.下面:开始你的表演</h2><p>1.查询所有人员信息</p><pre><code>SELECT * FROM person;</code></pre><p>2.只查询人员的姓名和年龄</p><pre><code>SELECT `name`,age FROM person;</code></pre><p>3.查询年龄为20岁的有哪些人员</p><pre><code>SELECT `name`,age FROM person WHERE age=20;</code></pre><p>4.查询60岁以下的人员有哪些人员</p><pre><code>SELECT `name`,age FROM person WHERE age&lt;60;</code></pre><p>5.查询50岁以上并且工资大于8000的人员有哪些</p><pre><code>SELECT `name` FROM person WHERE age&gt;50 AND salary&gt;8000;</code></pre><p>6.查询姓[张]的人员有哪些</p><pre><code>SELECT `name` FROM person WHERE `name` LIKE &apos;张%&apos;;</code></pre><p>7.查询哪些人员属于 武当/华山/嵩山</p><pre><code>SELECT `name` FROM person WHERE menpai=&apos;武当&apos; or menpai=&apos;华山&apos; or menpai=&apos;嵩山&apos;;</code></pre><p>8.查询工资在 5000-8900 的人员有哪些</p><pre><code>SELECT `name` FROM person WHERE salary&gt;5000 and salary&lt;8900;</code></pre><p>9.查询所有人员,要求按工资倒序排列</p><pre><code>SELECT * FROM person ORDER BY salary DESC;</code></pre><p>10.查询令狐冲的领导人是谁</p><pre><code>SELECT * FROM person WHERE menpai=&apos;华山&apos; AND leader=0;</code></pre><p>11.查询人员表中最高工资是多少</p><pre><code>SELECT `name`,MAX(salary) FROM person; </code></pre><p>12.查询人员表中最低工资是多少</p><pre><code>SELECT `name`,MIN(salary) FROM person; </code></pre><p>13.查询所有人员的平均工资是多少</p><pre><code>SELECT ROUND(AVG(salary),2) FROM person; </code></pre><p>14.查询所有人员的工资总和是多少</p><pre><code>SELECT sum(salary) FROM person; </code></pre><p>15.查询目前有多少个人员</p><pre><code>SELECT COUNT(id) FROM person; </code></pre><p>16.查询当前武林中有哪些门派</p><pre><code>SELECT menpai FROM person GROUP BY menpai; </code></pre><p>17.查询 武当派 最高工资是谁</p><pre><code>SELECT `name`,MAX(salary) FROM person WHERE menpai=&apos;武当&apos;;</code></pre><p>18.查询各门派的平均工资是多少</p><p>19.查询当前武林中有哪些门派的平均工资大于8000 并按工资倒序排列</p><p>20.查询当前人员表的中的第3条数据到第7条数据</p><p>21.查询哪些门派下没有弟子</p><p>22.查询武当派下有哪些弟子</p><p>23.查询各门派的工资总和按倒序/正序排列</p><p>24.删除工资重复的人员,请保留年龄最大的一个人</p><p>25.将武当派 张三丰 修改为 张丰</p><p>26.将所有门派大哥工资上调10%,但不包括Alex.</p><p>27.查看哪些人员的门派已登记地理位置.</p><p>28.查询所有人员门派的位置信息,不存在位置信息则不显示</p><p>29.在湖北省内的门派中的人员有哪些.</p><p>30.在陕西省内门派中的工资小于5000,年龄大于20岁的人员有哪些,按主键倒序排列</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 练习</title>
      <link href="/2018/02/27/cnblog_8479171/"/>
      <url>/2018/02/27/cnblog_8479171/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-练习👈的摘要"><a href="#这是👉MySQL-练习👈的摘要" class="headerlink" title="这是👉MySQL 练习👈的摘要"></a><a href="/2018/02/27/cnblog_8479171/">这是👉MySQL 练习👈的摘要</a></h1><a id="more"></a><p><strong>1.创建留言数据库: messagedb;</strong></p><pre><code>mysql&gt; create database messagedb charset = utf8;</code></pre><p><strong>2.在 </strong>messagedb<strong> 数据库中创建留言表message，结构如下:</strong></p><p><strong>表名</strong></p><p>|</p><p><strong>message</strong></p><p>|</p><p><strong>留言信息表</strong>  </p><p>—|—|—  </p><p><strong>序号</strong></p><p>|</p><p><strong>字段名称</strong></p><p>|</p><p><strong>字段说明</strong></p><p>|</p><p><strong>类型</strong></p><p>|</p><p><strong>属性</strong></p><p>|</p><p><strong>备注</strong>  </p><p><strong>1</strong></p><p>|</p><p><strong>id</strong></p><p>|</p><p><strong>编号</strong></p><p>|</p><p><strong>int</strong></p><p>|</p><p><strong>非空</strong></p><p>|</p><p><strong>主键,自增1</strong>  </p><p><strong>2</strong></p><p>|</p><p><strong>title</strong></p><p>|</p><p><strong>标题</strong></p><p>|</p><p><strong>varchar(32)</strong></p><p>|</p><p><strong>非空</strong></p><p>|</p><hr><p><strong>3</strong></p><p>|</p><p><strong>author</strong></p><p>|</p><p><strong>作者</strong></p><p>|</p><p><strong>varchar(16)</strong></p><p>|</p><p><strong>可以空</strong></p><p>|</p><hr><p><strong>4</strong></p><p>|</p><p><strong>addtime</strong></p><p>|</p><p><strong>留言时间</strong></p><p>|</p><p><strong>datetime</strong></p><p>|</p><p><strong>非空</strong></p><p>|</p><hr><p><strong>5</strong></p><p>|</p><p><strong>content</strong></p><p>|</p><p><strong>留言内容</strong></p><p>|</p><p><strong>text</strong></p><p>|</p><p><strong>非空</strong></p><p>|</p><hr><p><strong>6</strong></p><p>|</p><p><strong>isdelete</strong></p><p>|</p><p><strong>是否删除</strong></p><p>|</p><p><strong>char(1)</strong></p><p>|</p><p><strong>非空</strong></p><p>|</p><p><strong>默认值 0</strong>  </p><pre><code> CREATE TABLE `message` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `title` varchar(32) NOT NULL,  `author` varchar(16) DEFAULT NULL,  `addtime` datetime DEFAULT NULL,  `content` text,  `status` char(1) NOT NULL DEFAULT &apos;0&apos;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</code></pre><p><strong>3.在留言表最后添加一列状态（status   char(1)  默认值为0）</strong></p><p><strong>4.修改留言表author的默认值为 ‘youku’,设为非空</strong></p><p><strong>5.删除message表中的isdelete字段</strong></p><p><strong>6.为留言表添加 &gt;5条测试数据</strong></p><pre><code>INSERT INTO `message` VALUES (&apos;1&apos;, &apos;介绍&apos;, &apos;大雄&apos;, &apos;2017-02-14 09:59:37&apos;, &apos;哥不是一匹好马，但也不是一头普通的毛驴&apos;, &apos;0&apos;);INSERT INTO `message` VALUES (&apos;2&apos;, &apos;叮当猫&apos;, &apos;熊熊&apos;, &apos;2016-02-16 09:59:44&apos;, &apos;你牙缝里有韭菜，扣出来贼哥吃&apos;, &apos;0&apos;);INSERT INTO `message` VALUES (&apos;3&apos;, &apos;花花&apos;, &apos;苗苗&apos;, &apos;2017-05-28 09:59:52&apos;, &apos;苗苗问花花:卖萌是褒义词还是贬义词？&apos;, &apos;0&apos;);INSERT INTO `message` VALUES (&apos;4&apos;, &apos;霞哥&apos;, &apos;大雄&apos;, &apos;2017-08-29 09:59:57&apos;, &apos;斗战色佛&apos;, &apos;0&apos;);INSERT INTO `message` VALUES (&apos;5&apos;, &apos;晨晨&apos;, &apos;逗比&apos;, &apos;2010-06-22 10:00:03&apos;, &apos;你笑起来像一朵菊花,菊花残，man腚伤&apos;, &apos;0&apos;); ****</code></pre><p><strong>7. 要求将id值大于3的信息中author字段值改为admin</strong></p><pre><code>update message set author= &apos;admin&apos; where id&gt;3;</code></pre><p><strong>8. 删除id号为4的数据。</strong></p><pre><code>delete  from message where id=4;</code></pre><ul><li><strong>为留言表添加 &gt;15条测试数据，要求分三个用户添加</strong></li><li><p>INSERT INTO <code>message</code> VALUES (‘6’, ‘晨晨’, ‘逗比’, ‘2010-06-22 10:00:03’, ‘你笑起来像一朵菊花,菊花残，man腚伤’, ‘1’);</p></li><li><p><strong>查询所有留言信息</strong></p></li><li><p>select *  from message;</p></li><li><p><strong>查询某一用户的留言信息。</strong></p></li><li><p>select *  from message where author=’用户名’;</p></li><li><p><strong>查询所有数据，按时间降序排序。</strong></p></li><li><p>select *  from message order by addtime desc;</p></li><li><p><strong>获取id在2到6之间的留言信息，并按时间降序排序</strong></p></li><li><p>select *  from message where id&gt;2 and id&lt;6 order by addtime desc;</p></li><li><p><strong>统计每个用户留了多少条留言，并对数量按从小到大排序。</strong></p></li><li><p>select author,COUNT(id) as ‘留言条数’ FROM message GROUP BY author ORDER BY COUNT(id) ASC;</p></li><li><p><strong>将id为8、9的两条数据的作者改为 ‘doudou’.</strong></p></li><li><p>update message set author=’doudou’ where id=8 or id=9;</p></li><li><p><strong><strong>取出最新的三条留言。</strong></strong></p></li><li><p>select * from message order by addtime desc limit 3;</p></li><li><p><strong>查询留言者中包含 “a”字母的留言信息，并按留言时间从小到大排序</strong></p></li><li><p>select * from message where author like ‘%a%’ order by ‘addtime’ desc;</p></li><li><p><strong>删除 “作者”重复的数据,并保留id最大的一个作者</strong></p></li><li>delete from message where author in(<br>select author from (select author from message group by author having count(1)&gt;1) a<br>)<br>and id not in(<br>select id from (select max(id) id from message group by author having count(1)&gt;1) b<br>)</li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 环境搭建之解压方式安装</title>
      <link href="/2018/02/26/cnblog_8474477/"/>
      <url>/2018/02/26/cnblog_8474477/</url>
      <content type="html"><![CDATA[<h1 id="这是👉MySQL-环境搭建之解压方式安装👈的摘要"><a href="#这是👉MySQL-环境搭建之解压方式安装👈的摘要" class="headerlink" title="这是👉MySQL 环境搭建之解压方式安装👈的摘要"></a><a href="/2018/02/26/cnblog_8474477/">这是👉MySQL 环境搭建之解压方式安装👈的摘要</a></h1><a id="more"></a><h2 id="一-MySQL服务-安装"><a href="#一-MySQL服务-安装" class="headerlink" title="一 .MySQL服务 安装"></a>一 .MySQL服务 安装</h2><h4 id="1-下载："><a href="#1-下载：" class="headerlink" title="1.下载："></a>1.下载：</h4><pre><code>http://dev.mysql.com/downloads/mysql</code></pre><p><img src="https://images2018.cnblogs.com/blog/1301576/201802/1301576-20180226174736789-869674935.png" alt=""></p><p><strong>2.安装：</strong></p><p>将下载的mysql-5.7.21-winx64压缩包解压后的整个目录放在自己喜欢的位置，我的放在C:\Users\wilson\Software\目录下</p><p><img src="https://images2018.cnblogs.com/blog/1301576/201802/1301576-20180226174910419-1251653180.png" alt=""></p><p>  <strong>3. </strong>初始化操作<strong><br>解压后进入当前文件夹的bin目录下,可以看到很多执行文件,在该目录下执行初始化操作：</strong></p><pre><code>mysqld --initialize -insecureps:进行初始化操作,当前操作会在mysql-5.7.20-winx64目录下创建一个data文件夹</code></pre><p><img src="https://images2018.cnblogs.com/blog/1301576/201802/1301576-20180226175042457-1949771749.png" alt=""></p><p><img src="https://images2018.cnblogs.com/blog/1301576/201802/1301576-20180226175225399-1440413569.png" alt=""></p><p>添加环境变量</p><p>【右键计算机】–》【属性】–》【高级系统设置】–》【高级】–》【环境变量】–》【在第二个内容框中找到 变量名为Path 的一行，双击】 –&gt;<br>【将MySQL的bin目录路径追加到变值值中，用 ； 分割】</p><p><img src="https://images2018.cnblogs.com/blog/1301576/201802/1301576-20180226175600315-1306408587.png" alt=""></p><p> 如此一来，以后再启动服务并连接时，仅需：</p><pre><code># 启动MySQL服务，在终端输入mysqld# 连接MySQL服务，在终端输入：mysql -u root -p</code></pre><p>效果如下:</p><p><img src="https://images2018.cnblogs.com/blog/1301576/201802/1301576-20180226175808603-164509861.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python3 下载必应每日壁纸（三）</title>
      <link href="/2018/02/26/cnblog_8474376/"/>
      <url>/2018/02/26/cnblog_8474376/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python3-下载必应每日壁纸（三）👈的摘要"><a href="#这是👉python3-下载必应每日壁纸（三）👈的摘要" class="headerlink" title="这是👉python3 下载必应每日壁纸（三）👈的摘要"></a><a href="/2018/02/26/cnblog_8474376/">这是👉python3 下载必应每日壁纸（三）👈的摘要</a></h1><a id="more"></a><p>在第二篇文章时,<a href="/2018/01/30/cnblog_8386624/" title="python3 下载必应每日壁纸（二）">python3 下载必应每日壁纸（二）</a>已经设置过自动任务,但是有一点不友好,</p><p>就是在自动计划任务在执行的过程中会有命令行窗口,so在写个把它隐藏起来</p><p>写个vbs脚本,隐藏命令行窗口</p><figure class="hljs highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">'down bing wallpaper<br>'下载每日必应壁纸,隐藏命令行,参数为1显示命令行<br>DIM objShell  <br>set objShell=wscript.createObject("wscript.shell")  <br>iReturn=objShell.Run("cmd.exe /C C:<span class="hljs-symbol">\P</span>ython<span class="hljs-symbol">\P</span>ython36<span class="hljs-symbol">\p</span>ython3.exe D:<span class="hljs-symbol">\w</span>ilson<span class="hljs-symbol">\P</span>ictures<span class="hljs-symbol">\D</span>esktopBackGround<span class="hljs-symbol">\B</span>ingWallpaper.py", 0, TRUE)<br></code></pre></td></tr></table></figure><p>然后,在计划任务中,直接执行vbs脚本即可!</p><p>完美隐藏命令行</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 生产者与消费者模式</title>
      <link href="/2018/02/05/cnblog_8418906/"/>
      <url>/2018/02/05/cnblog_8418906/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-生产者与消费者模式👈的摘要"><a href="#这是👉python-生产者与消费者模式👈的摘要" class="headerlink" title="这是👉python 生产者与消费者模式👈的摘要"></a><a href="/2018/02/05/cnblog_8418906/">这是👉python 生产者与消费者模式👈的摘要</a></h1><a id="more"></a><h1 id="生产者与消费者模式"><a href="#生产者与消费者模式" class="headerlink" title="生产者与消费者模式"></a>生产者与消费者模式</h1><h2 id="1-队列"><a href="#1-队列" class="headerlink" title="1. 队列"></a>1. 队列</h2><p>先进先出</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201802/1301576-20180205182912951-1255608650.png" alt=""></p><p><img src="file:///H:/Python/02-Python%E8%AF%BE%E4%BB%B6/04-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%8C%E6%95%B4%E8%AF%BE%E4%BB%B6/Images/113992901.jpg" alt=""></p><h2 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h2><p>先进后出</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201802/1301576-20180205182928701-618370481.png" alt=""></p><p><img src="file:///H:/Python/02-Python%E8%AF%BE%E4%BB%B6/04-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%8C%E6%95%B4%E8%AF%BE%E4%BB%B6/Images/476e440adf9a0b538b45e.jpeg" alt=""></p><p>Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么就做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。</p><p>用FIFO队列实现上述生产者与消费者问题的代码如下：</p><p>​<br><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">global</span> queue<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:<br>            <span class="hljs-keyword">if</span> queue.qsize() &lt; <span class="hljs-number">1000</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>                    count = count +<span class="hljs-number">1</span><br>                    msg = <span class="hljs-string">'生成产品'</span>+str(count)<br>                    queue.put(msg)<br>                    print(msg)<br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">global</span> queue<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:<br>            <span class="hljs-keyword">if</span> queue.qsize() &gt; <span class="hljs-number">100</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>                    msg = self.name + <span class="hljs-string">'消费了 '</span>+queue.get()<br>                    print(msg)<br>            time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    queue = Queue()<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">500</span>):<br>        queue.put(<span class="hljs-string">'初始产品'</span>+str(i))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        p = Producer()<br>        p.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        c = Consumer()<br>        c.start()<br></code></pre></td></tr></table></figure></p><h2 id="3-Queue的说明"><a href="#3-Queue的说明" class="headerlink" title="3. Queue的说明"></a>3. Queue的说明</h2><ol><li>对于Queue，在多线程通信之间扮演重要的角色</li><li>添加数据到队列中，使用put()方法</li><li>从队列中取数据，使用get()方法</li><li>判断队列中是否还有数据，使用qsize()方法</li></ol><h2 id="4-生产者消费者模式的说明"><a href="#4-生产者消费者模式的说明" class="headerlink" title="4. 生产者消费者模式的说明"></a>4. 生产者消费者模式的说明</h2><ul><li>为什么要使用生产者和消费者模式</li></ul><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</p><ul><li>什么是生产者消费者模式</li></ul><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><p>这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一个第三者出来进行解耦，</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python3 下载必应每日壁纸（二）</title>
      <link href="/2018/01/30/cnblog_8386624/"/>
      <url>/2018/01/30/cnblog_8386624/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python3-下载必应每日壁纸（二）👈的摘要"><a href="#这是👉python3-下载必应每日壁纸（二）👈的摘要" class="headerlink" title="这是👉python3 下载必应每日壁纸（二）👈的摘要"></a><a href="/2018/01/30/cnblog_8386624/">这是👉python3 下载必应每日壁纸（二）👈的摘要</a></h1><a id="more"></a><h3 id="python3-下载必应每日壁纸（一）"><a href="#python3-下载必应每日壁纸（一）" class="headerlink" title="python3 下载必应每日壁纸（一）"></a><a href="/2018/01/30/cnblog_8386598/">python3 下载必应每日壁纸（一）</a></h3><p>脚本写好了，执行就会获取当天必应图片，使用win10的计划任务，设置每天执行，就能获取每天的壁纸了</p><p>打开win10任务计划</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180130185646921-1459893913.png" alt=""></p><p>在右边点击创建任务</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180130185742140-1642423603.png" alt=""></p><p>设置触发器</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180130185811421-508095367.png" alt=""></p><p>最重要的，设置执行脚本</p><p>我的脚本路径</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180130185853796-1449325351.png" alt=""></p><p>程序填python解释器路径</p><p>添加参数，填需要执行的脚本路径，比如我的， G:\Pictures\DesktoBackGround\BingWallpaper.py</p><p>然后点完成就ok了</p><p>是不是很简单啊</p><p>哈哈哈</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python3 下载必应每日壁纸（一）</title>
      <link href="/2018/01/30/cnblog_8386598/"/>
      <url>/2018/01/30/cnblog_8386598/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python3-下载必应每日壁纸（一）👈的摘要"><a href="#这是👉python3-下载必应每日壁纸（一）👈的摘要" class="headerlink" title="这是👉python3 下载必应每日壁纸（一）👈的摘要"></a><a href="/2018/01/30/cnblog_8386598/">这是👉python3 下载必应每日壁纸（一）👈的摘要</a></h1><a id="more"></a><h1 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h1><h3 id="win10，python3"><a href="#win10，python3" class="headerlink" title="win10，python3"></a>win10，python3</h3><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>想换壁纸了，so，搜搜github,发现有有人用python写的获取必应每日壁纸，看了看，也不难，就自己也写了一个</p><p>首先：找到了一个必应的API  </p><pre><code>json_url = &quot;http://cn.bing.com/HPImageArchive.aspx?format=js&amp;n=1&amp;idx=0&quot;</code></pre><p>改api返回json数据，</p><p>参数n代表返回几条</p><p>参数idx代表返回那一天的，0是今天的，-1是明天的，1是昨天的</p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><p>获取json数据解析出时间，文件名，图片url</p><p>然后下载</p><p>code</p><pre><code>import jsonfrom urllib import requestimport osclass BingWallpaper():    &quot;&quot;&quot;下载必应壁纸&quot;&quot;&quot;    def __init__(self):        self.filePath = &quot;G:\Pictures\DesktoBackGround&quot;        self.hosts = &quot;http://cn.bing.com&quot;        self.imgDate = &quot;&quot;        self.imgUrl = &quot;&quot;        self.imgFileName = &quot;&quot;    def __get_json_data(self, idx = 0):        # idx = 0是今天的，-1明天，1昨天        json_url = self.hosts+&quot;/HPImageArchive.aspx?format=js&amp;n=1&amp;idx={}&quot;.format(idx)        try:            data = request.urlopen(json_url).read().decode(&quot;utf-8&quot;)            json_data = json.loads(data)            self.imgDate = json_data[&quot;images&quot;][0][&quot;enddate&quot;]            self.imgUrl = self.hosts + json_data[&quot;images&quot;][0][&quot;url&quot;]            self.imgFileName = self.imgDate+&quot;_&quot;+json_data[&quot;images&quot;][0][&quot;url&quot;].split(&quot;/&quot;)[4]        except Exception as f:            print(&quot;get_json_data:&quot;,f)    def __down_img(self):        with request.urlopen(self.imgUrl) as f:            data = f.read()  　　　　　　　# 图片存的路径为 G:\Pictures\DesktoBackGround目录            with open(str(self.filePath+os.sep+self.imgFileName), mode=&quot;wb&quot;) as f:                f.write(data)    def save_img(self, idx = 0):        self.__get_json_data(idx)        self.__down_img()        print(&quot;{}download!&quot;.format(self.imgFileName))if __name__ == &apos;__main__&apos;:    print(&quot;path:&quot;,__file__)    print(&quot;run...&quot;)    wall = BingWallpaper()    wall.save_img()    print(&quot;end!&quot;)    exit = input(&quot;please enter any key to exit...&quot;)</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python struct模块</title>
      <link href="/2018/01/29/cnblog_8377304/"/>
      <url>/2018/01/29/cnblog_8377304/</url>
      <content type="html"><![CDATA[<h1 id="这是👉Python-struct模块👈的摘要"><a href="#这是👉Python-struct模块👈的摘要" class="headerlink" title="这是👉Python struct模块👈的摘要"></a><a href="/2018/01/29/cnblog_8377304/">这是👉Python struct模块👈的摘要</a></h1><a id="more"></a><h1 id="转载-http-blog-csdn-net-lis-12-article-details-52777983"><a href="#转载-http-blog-csdn-net-lis-12-article-details-52777983" class="headerlink" title="转载(http://blog.csdn.net/lis_12/article/details/52777983)."></a>转载(<a href="http://blog.csdn.net/lis_12/article/details/52777983" target="_blank" rel="noopener">http://blog.csdn.net/lis_12/article/details/52777983</a>).</h1><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ol><li>按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;</li><li>按照指定格式将字节流转换为Python指定的数据类型;</li><li>处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文件;</li><li>处理c语言中的结构体;</li></ol><h2 id="struct模块中的函数"><a href="#struct模块中的函数" class="headerlink" title="struct模块中的函数"></a>struct模块中的函数</h2><table><thead><tr><th>函数</th><th>return</th><th>explain  </th></tr></thead><tbody><tr><td>pack(fmt,v1,v2…)</td><td>string</td><td>按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回.  </td></tr><tr><td>pack_into(fmt,buffer,offset,v1,v2…)</td><td>None</td><td></td></tr></tbody></table><p>按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块)<br>unpack(fmt,v1,v2…..) | tuple | 按照给定的格式(fmt)解析字节流,并返回解析结果<br>pack_from(fmt,buffer,offset) | tuple | 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果<br>calcsize(fmt) | size of fmt | 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式  </p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>当打包或者解包的时,需要按照特定的方式来打包或者解包.该方式就是格式化字符串,它指定了数据类型,除此之外,还有用于控制字节顺序、大小和对齐方式的特殊字符.</p><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><p>为了同c中的结构体交换数据，还要考虑c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下</p><table><thead><tr><th>Character</th><th>Byte order</th><th>Size</th><th>Alignment  </th></tr></thead><tbody><tr><td>@(默认)</td><td>本机</td><td>本机</td><td>本机,凑够4字节  </td></tr><tr><td>=</td><td>本机</td><td>标准</td><td>none,按原字节数  </td></tr><tr><td>&lt;</td><td>小端</td><td>标准</td><td>none,按原字节数  </td></tr><tr><td>&gt;</td><td>大端</td><td>标准</td><td>none,按原字节数  </td></tr><tr><td>!</td><td>network(大端)</td><td>标准</td><td>none,按原字节数  </td></tr></tbody></table><p>如果不懂大小端,见<a href="http://blog.csdn.net/lis_12/article/details/52698634" target="_blank" rel="noopener">大小端参考网址</a>.</p><h3 id="格式符"><a href="#格式符" class="headerlink" title="格式符"></a>格式符</h3><table><thead><tr><th>格式符</th><th>C语言类型</th><th>Python类型</th><th>Standard size  </th></tr></thead><tbody><tr><td>x</td><td>pad byte(填充字节)</td><td>no value</td><td></td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1  </td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1  </td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1  </td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1  </td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2  </td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2  </td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4  </td></tr><tr><td>I(大写的i)</td><td>unsigned int</td><td>integer</td><td>4  </td></tr><tr><td>l(小写的L)</td><td>long</td><td>integer</td><td>4  </td></tr><tr><td>L</td><td>unsigned long</td><td>long</td><td>4  </td></tr><tr><td>q</td><td>long long</td><td>long</td><td>8  </td></tr><tr><td>Q</td><td>unsigned long long</td><td>long</td><td>8  </td></tr><tr><td>f</td><td>float</td><td>float</td><td>4  </td></tr><tr><td>d</td><td>double</td><td>float</td><td>8  </td></tr><tr><td>s</td><td>char[]</td><td>string</td><td></td></tr><tr><td>p</td><td>char[]</td><td>string</td><td></td></tr><tr><td>P</td><td>void *</td><td>long</td><td></td></tr></tbody></table><p>注- -!</p><ol><li>_Bool在C99中定义,如果没有这个类型,则将这个类型视为char,一个字节;</li><li>q和Q只适用于64位机器;</li><li>每个格式前可以有一个数字,表示这个类型的个数,如s格式表示一定长度的字符串,4s表示长度为4的字符串;4i表示四个int;</li><li>P用来转换一个指针,其长度和计算机相关;</li><li>f和d的长度和计算机相关;</li></ol>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python Tkinter基础 Button bg 设置按钮的背景颜色</title>
      <link href="/2018/01/24/cnblog_8343470/"/>
      <url>/2018/01/24/cnblog_8343470/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-Tkinter基础-Button-bg-设置按钮的背景颜色👈的摘要"><a href="#这是👉python-Tkinter基础-Button-bg-设置按钮的背景颜色👈的摘要" class="headerlink" title="这是👉python Tkinter基础 Button bg 设置按钮的背景颜色👈的摘要"></a><a href="/2018/01/24/cnblog_8343470/">这是👉python Tkinter基础 Button bg 设置按钮的背景颜色👈的摘要</a></h1><a id="more"></a><p>code:</p><pre><code># Tkinter基础 Button bg 设置按钮的背景颜色import tkinter as tkclass App():    def __init__(self, master):        frame = tk.Frame(master)        frame.pack()        self.testButton = tk.Button(frame, text = &quot;hello&quot;, fg = &quot;red&quot;, bg = &quot;blue&quot;, command = self.testPrint)        self.testButton.pack()    def testPrint(self):        print(&quot;test&quot;)root = tk.Tk()app = App(root)root.mainloop()</code></pre><p>结果：</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180124202807147-821992255.png" alt=""></p><p>注：</p><h3 id="fg-前景色"><a href="#fg-前景色" class="headerlink" title="fg:前景色"></a>fg:前景色</h3><p>参数：颜色</p><h3 id="bg-背景色"><a href="#bg-背景色" class="headerlink" title="bg:背景色"></a>bg:背景色</h3><p>参数：颜色</p><p>tkinter 颜色</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180124204020803-183422540.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python Tkinter基础 Button command在窗体中添加一个按钮，单击按钮 在IDLE中打印一行字</title>
      <link href="/2018/01/24/cnblog_8343298/"/>
      <url>/2018/01/24/cnblog_8343298/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-Tkinter基础-Button-command在窗体中添加一个按钮，单击按钮-在IDLE中打印一行字👈的摘要"><a href="#这是👉python-Tkinter基础-Button-command在窗体中添加一个按钮，单击按钮-在IDLE中打印一行字👈的摘要" class="headerlink" title="这是👉python Tkinter基础 Button command在窗体中添加一个按钮，单击按钮 在IDLE中打印一行字👈的摘要"></a><a href="/2018/01/24/cnblog_8343298/">这是👉python Tkinter基础 Button command在窗体中添加一个按钮，单击按钮 在IDLE中打印一行字👈的摘要</a></h1><a id="more"></a><p>code</p><pre><code># Tkinter基础 Button command在窗体中添加一个按钮，单击按钮 在IDLE中打印一行字import tkinter as tkclass App():    def __init__(self, master):        frame = tk.Frame(master)        frame.pack()        self.testButton = tk.Button(frame, text = &quot;hello&quot;, fg = &quot;blue&quot;, command = self.testPrint)        self.testButton.pack()    def testPrint(self):        print(&quot;测试消息！！！！&quot;)root = tk.Tk()app = App(root)root.mainloop()</code></pre><p>结果：</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180124195615990-120361847.png" alt=""></p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180124195632131-673244014.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python Tkinter 基础添加一个按钮，在按钮上显示文字，并设置文字颜色</title>
      <link href="/2018/01/24/cnblog_8343266/"/>
      <url>/2018/01/24/cnblog_8343266/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-Tkinter-基础添加一个按钮，在按钮上显示文字，并设置文字颜色👈的摘要"><a href="#这是👉python-Tkinter-基础添加一个按钮，在按钮上显示文字，并设置文字颜色👈的摘要" class="headerlink" title="这是👉python Tkinter 基础添加一个按钮，在按钮上显示文字，并设置文字颜色👈的摘要"></a><a href="/2018/01/24/cnblog_8343266/">这是👉python Tkinter 基础添加一个按钮，在按钮上显示文字，并设置文字颜色👈的摘要</a></h1><a id="more"></a><p>code;</p><pre><code># Tkinter 基础添加一个按钮，在按钮上显示文字，并设置文字颜色import tkinter as tk# 面向对象编程class App():    def __init__(self, master):        frame = tk.Frame(master)  # 框架？？不是很理解        frame.pack()        # 创建一个按钮，fg前景色：蓝色        self.testButton = tk.Button(frame, text = &quot;hello&quot;, fg = &quot;blue&quot;)        self.testButton.pack()root = tk.Tk()app = App(root)root.mainloop()</code></pre><p>结果：</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180124194919334-1331569246.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python Tkinter 基础 创建一行文字的窗体并设置窗体的标题 Label,title</title>
      <link href="/2018/01/24/cnblog_8343168/"/>
      <url>/2018/01/24/cnblog_8343168/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-Tkinter-基础-创建一行文字的窗体并设置窗体的标题-Label-title👈的摘要"><a href="#这是👉python-Tkinter-基础-创建一行文字的窗体并设置窗体的标题-Label-title👈的摘要" class="headerlink" title="这是👉python Tkinter 基础 创建一行文字的窗体并设置窗体的标题 Label,title👈的摘要"></a><a href="/2018/01/24/cnblog_8343168/">这是👉python Tkinter 基础 创建一行文字的窗体并设置窗体的标题 Label,title👈的摘要</a></h1><a id="more"></a><pre><code># Tkinter 基础 创建一行文字的窗体并设置窗体的标题 Label,titleimport tkinter as tkapp = tk.Tk()  # 实例化一个TK 用于容纳整个GUI程序app.title(&quot;test01&quot;) # 设置窗体的标题栏# 设置label主键 ， 显示文本，图标与图片theLabel = tk.Label(app, text = &quot;这是一个窗口&quot;)theLabel.pack() # 自动调节 主键的尺寸与位置# 窗口的主时间循环，有tkiner接管app.mainloop()</code></pre><p>结果：</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180124191939272-2122157177.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python logging模块</title>
      <link href="/2018/01/24/cnblog_8342302/"/>
      <url>/2018/01/24/cnblog_8342302/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-logging模块👈的摘要"><a href="#这是👉python-logging模块👈的摘要" class="headerlink" title="这是👉python logging模块👈的摘要"></a><a href="/2018/01/24/cnblog_8342302/">这是👉python logging模块👈的摘要</a></h1><a id="more"></a><h3 id="函数式简单配置"><a href="#函数式简单配置" class="headerlink" title="函数式简单配置"></a>函数式简单配置</h3><pre><code>import logging  logging.debug(&apos;debug message&apos;)  logging.info(&apos;info message&apos;)  logging.warning(&apos;warning message&apos;)  logging.error(&apos;error message&apos;)  logging.critical(&apos;critical message&apos;) </code></pre><p>默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL</p><blockquote><p>ERROR &gt; WARNING &gt; INFO &gt; DEBUG），默认的日志格式为日志级别：Logger名称：用户输出消息。</p></blockquote><p><strong>灵活配置日志级别，日志格式，输出位置:</strong></p><pre><code> import logging  logging.basicConfig(level=logging.DEBUG,                      format=&apos;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;,                      datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;,                      filename=&apos;/tmp/test.log&apos;,                      filemode=&apos;w&apos;)  logging.debug(&apos;debug message&apos;)  logging.info(&apos;info message&apos;)  logging.warning(&apos;warning message&apos;)  logging.error(&apos;error message&apos;)  logging.critical(&apos;critical message&apos;)</code></pre><p>配置参数：</p><pre><code>logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。filemode：文件打开方式，在指定了filename时使用这个参数，默认值为&quot;a&quot;还可指定为&quot;w&quot;。format：指定handler使用的日志显示格式。datefmt：指定日期时间格式。level：设置rootlogger（后边会讲解具体概念）的日志级别stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(&apos;test.log&apos;,&apos;w&apos;))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。format参数中可能用到的格式化串：%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 &quot;2003-07-08 16:49:45,896&quot;。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s用户输出的消息</code></pre><h3 id="logger对象配置"><a href="#logger对象配置" class="headerlink" title="logger对象配置"></a>logger对象配置</h3><pre><code>import logginglogger = logging.getLogger()# 创建一个handler，用于写入日志文件fh = logging.FileHandler(&apos;test.log&apos;,encoding=&apos;utf-8&apos;) # 再创建一个handler，用于输出到控制台 ch = logging.StreamHandler() formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;)fh.setLevel(logging.DEBUG)fh.setFormatter(formatter) ch.setFormatter(formatter) logger.addHandler(fh) #logger对象可以添加多个fh和ch对象 logger.addHandler(ch) logger.debug(&apos;logger debug message&apos;) logger.info(&apos;logger info message&apos;) logger.warning(&apos;logger warning message&apos;) logger.error(&apos;logger error message&apos;) logger.critical(&apos;logger critical message&apos;)</code></pre><p>logging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。另外，可以通过：logger.setLevel(logging.Debug)设置级别,当然，也可以通过</p><p>fh.setLevel(logging.Debug)单对文件流设置某个级别。</p><h3 id="字典配置法："><a href="#字典配置法：" class="headerlink" title="字典配置法："></a>字典配置法：</h3><pre><code>import osimport logging.config# 记录文件日志输出的格式standard_format = &apos;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&apos; \                  &apos;[%(levelname)s][%(message)s]&apos; #其中name为getlogger指定的名字# 终端日志输出的格式simple_format = &apos;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s:%(message)s&apos;logfile_dir = r&apos;%s\log&apos; %os.path.dirname(os.path.dirname(os.path.abspath(__file__)))  # log文件的目录logfile_name = &apos;log.log&apos;  # log文件名# 如果不存在定义的日志目录就创建一个if not os.path.isdir(logfile_dir):    os.mkdir(logfile_dir)# log文件的全路径logfile_path = os.path.join(logfile_dir, logfile_name)# log配置字典LOGGING_DIC = {    &apos;version&apos;: 1,    &apos;disable_existing_loggers&apos;: False,    &apos;formatters&apos;: {        &apos;standard&apos;: {            &apos;format&apos;: standard_format        },        &apos;simple&apos;: {            &apos;format&apos;: simple_format        },    },    &apos;filters&apos;: {},    &apos;handlers&apos;: {        #打印到终端的日志        &apos;console&apos;: {            &apos;level&apos;: &apos;DEBUG&apos;,            &apos;class&apos;: &apos;logging.StreamHandler&apos;,  # 打印到屏幕            &apos;formatter&apos;: &apos;simple&apos;        },        #打印到文件的日志,收集info及以上的日志        &apos;default&apos;: {            &apos;level&apos;: &apos;DEBUG&apos;,            &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;,  # 保存到文件            &apos;formatter&apos;: &apos;standard&apos;,            &apos;filename&apos;: logfile_path,  # 日志文件            &apos;maxBytes&apos;: 1024*1024*5,  # 日志大小 5M            &apos;backupCount&apos;: 5,            &apos;encoding&apos;: &apos;utf-8&apos;,  # 日志文件的编码，再也不用担心中文log乱码了        },    },    &apos;loggers&apos;: {        #logging.getLogger(__name__)拿到的logger配置        &apos;&apos;: {            &apos;handlers&apos;: [&apos;default&apos;, &apos;console&apos;],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕            &apos;level&apos;: &apos;DEBUG&apos;,            &apos;propagate&apos;: True,  # 向上（更高level的logger）传递        },    },}def load_my_logging_cfg():    logging.config.dictConfig(LOGGING_DIC)  # 导入上面定义的logging配置if __name__ == &apos;__main__&apos;:    load_my_logging_cfg()    logger = logging.getLogger(__name__)  # 生成一个log实例    logger.info(&apos;info message&apos;)    logger.debug(&apos;debug message&apos;)    logger.warning(&apos;warning message&apos;)    logger.error(&apos;error message&apos;)    logger.critical(&apos;critical message&apos;)</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 面向对象进阶之对象内置方法</title>
      <link href="/2018/01/22/cnblog_8329568/"/>
      <url>/2018/01/22/cnblog_8329568/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-面向对象进阶之对象内置方法👈的摘要"><a href="#这是👉python-面向对象进阶之对象内置方法👈的摘要" class="headerlink" title="这是👉python 面向对象进阶之对象内置方法👈的摘要"></a><a href="/2018/01/22/cnblog_8329568/">这是👉python 面向对象进阶之对象内置方法👈的摘要</a></h1><a id="more"></a><h1 id="反射相关"><a href="#反射相关" class="headerlink" title="反射相关"></a>反射相关</h1><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180122191244381-564997212.png" alt=""></p><p>常用的就是hasattr,getattr</p><pre><code>class A():    def __init__(self):        pass    def func(self):        print(&quot;func&quot;)a = A()a.name = &quot;123&quot;a.age = 123print(getattr(a,&quot;name&quot;))getattr(a, &quot;func&quot;)()print(hasattr(a, &quot;ame&quot;))</code></pre><p> setattr,delattr，用于设置变量和删除变量，不常用</p><p> 用于对象的一些内置方法：</p><h1 id="str"><a href="#str" class="headerlink" title="str"></a><strong>str</strong></h1><p>调用对象，自动输出</p><pre><code>class B:    def __str__(self):        return &apos;str : class B&apos;    def __repr__(self):        return &apos;repr : class B&apos;b = B()print(&apos;%s&apos; % b)print(&apos;%r&apos; % b)</code></pre><h1 id="getitem-setitem-delitem"><a href="#getitem-setitem-delitem" class="headerlink" title="getitem, setitem, delitem"></a><strong>getitem</strong>, <strong>setitem</strong>, <strong>delitem</strong></h1><p>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p><pre><code>class C(object):      def __init__(self):        self.value = {}        self.name = &apos;test&apos;    def __getitem__(self, item):        print &apos;__getitem__&apos;, item        return self.value[item]    def __setitem__(self, key, value):        print &apos;__setitem__&apos;, key, value        self.value[key] = value    def __delitem__(self, key):        print &apos;__delitem__&apos;, key        del self.value[key]    def __len__(self):        return len(self.value)print C.__doc__c = C()#print c#result = c[&apos;k1&apos;]c[&apos;k2&apos;] = 5c[&apos;k1&apos;] = &quot;Hello&quot;print c[&apos;k2&apos;]print len(c)</code></pre><h1 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h1><p>对象后面加括号，触发执行。</p><p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p><pre><code>class Foo:    def __init__(self):        pass    def __call__(self, *args, **kwargs):        print(&apos;__call__&apos;)obj = Foo() # 执行 __init__obj()       # 执行 __call__</code></pre><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a><strong>hash</strong></h1><p>外部哈希，依赖与内置<strong>hash</strong>方法</p><pre><code>class A():    def __init__(self):        self.a = 1        self.b = 2    def __hash__(self):        return hash(str(self.a)+str(self.b))a = A()print(hash(a))</code></pre><h1 id="eq方法"><a href="#eq方法" class="headerlink" title="eq方法"></a><strong>eq</strong>方法</h1><p>用与判断两个对象是否相等，因为 == 默认是比较内存地址</p><pre><code>class A():    def __init__(self, name):        self.name = name    def __eq__(self, other):        if (self.__dict__ == other.__dict__):            return Truea = A(&quot;test&quot;)b = A(&quot;test&quot;)print(a == b)</code></pre><h1 id="set（）对象去重，依赖于hash，eq方法"><a href="#set（）对象去重，依赖于hash，eq方法" class="headerlink" title="set（）对象去重，依赖于hash，eq方法"></a>set（）对象去重，依赖于hash，eq方法</h1><pre><code>class Person:    def __init__(self,name,age,sex):        self.name = name        self.age = age        self.sex = sex    def __hash__(self):        return hash(self.name+self.sex)    def __eq__(self, other):        if self.name == other.name and self.sex == other.sex:return Truep_lst = []for i in range(84):    p_lst.append(Person(&apos;egon&apos;,i,&apos;male&apos;))print(p_lst)print(set(p_lst))</code></pre><h1 id="del-方法"><a href="#del-方法" class="headerlink" title="__del__()方法"></a><code>__del__()</code>方法</h1><p>创建对象后，python解释器默认调用<code>__init__()</code>方法；</p><p>当删除一个对象时，python解释器也会默认调用一个方法，这个方法为<code>__del__()</code>方法</p><pre><code>import timeclass Animal(object):    # 初始化方法    # 创建完对象后会自动被调用    def __init__(self, name):        print(&apos;__init__方法被调用&apos;)        self.__name = name    # 析构方法    # 当对象被删除时，会自动被调用    def __del__(self):        print(&quot;__del__方法被调用&quot;)        print(&quot;%s对象马上被干掉了...&quot;%self.__name)# 创建对象dog = Animal(&quot;哈皮狗&quot;)# 删除对象del dogcat = Animal(&quot;波斯猫&quot;)cat2 = catcat3 = catprint(&quot;---马上 删除cat对象&quot;)del catprint(&quot;---马上 删除cat2对象&quot;)del cat2print(&quot;---马上 删除cat3对象&quot;)del cat3print(&quot;程序2秒钟后结束&quot;)time.sleep(2)</code></pre><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180122193353975-1713486157.png" alt=""></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>当有1个变量保存了对象的引用时，此对象的引用计数就会加1</li><li>当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除</li></ul><h1 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h1><p>现在我们终于明白了，动态语言与静态语言的不同</p><p>动态语言：可以在运行的过程中，修改代码</p><p>静态语言：编译时已经确定好代码，运行过程中不能修改</p><p>如果我们想要限制实例的属性怎么办？比如，只允许对Person实例添加name和age属性。</p><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性：</p><pre><code>&gt;&gt;&gt; class Person(object):    __slots__ = (&quot;name&quot;, &quot;age&quot;)&gt;&gt;&gt; P = Person()&gt;&gt;&gt; P.name = &quot;老王&quot;&gt;&gt;&gt; P.age = 20&gt;&gt;&gt; P.score = 100Traceback (most recent call last):  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;AttributeError: Person instance has no attribute &apos;score&apos;&gt;&gt;&gt;</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ul><li>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</li></ul><pre><code>In [67]: class Test(Person):    ...:     pass    ...:In [68]: t = Test()In [69]: t.score = 100</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XMind 8 pro安装破解</title>
      <link href="/2018/01/20/cnblog_8321674/"/>
      <url>/2018/01/20/cnblog_8321674/</url>
      <content type="html"><![CDATA[<h1 id="这是👉XMind-8-pro安装破解👈的摘要"><a href="#这是👉XMind-8-pro安装破解👈的摘要" class="headerlink" title="这是👉XMind 8 pro安装破解👈的摘要"></a><a href="/2018/01/20/cnblog_8321674/">这是👉XMind 8 pro安装破解👈的摘要</a></h1><a id="more"></a><h1 id="XMind-8-pro安装破解"><a href="#XMind-8-pro安装破解" class="headerlink" title="XMind 8 pro安装破解"></a>XMind 8 pro安装破解</h1><hr><p>资源下载：</p><p>链接: <a href="https://pan.baidu.com/s/1bqQSnAv" target="_blank" rel="noopener">https://pan.baidu.com/s/1bqQSnAv</a> 密码: 94rb</p><p>Step 1：下载上述资源，解压，安装XMind 默认安装路径为 C:\Program Files (x86)\XMind</p><p>Step 2：安装完毕后，将破解工具XMindCrack.zip 内的文件解压到 Xmind 的安装目录，默认安装路径为 C:\Program Files<br>(x86)\XMind</p><p>Step 3：将XMindCrack.jar 复制到 D 盘根目录</p><p>Step 4：将 Xmind 安装目录下的<br>XMind.ini使用记事本打开增加一行”-javaagent:D:/XMindCrack.jar”（引号内的内容，引号无需复制，作用就是去执行Step<br>3，把激活文件的路径加进去，让其离线激活），保存</p><p>Step 5：断开网络, 或者使用防火墙阻止 XMind 联网, 或者在 hosts 中添加</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">0<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.xmind</span><span class="hljs-selector-class">.net</span><br></code></pre></td></tr></table></figure><p>（建议采用断网或者增加hosts记录法，优选修改hosts法，推荐一个小工具-使用SwitchHosts小工具随心所欲地更改hosts文件）。</p><p>Step 6：打开 XMind, “帮助-序列号”，随便输入邮箱地址和下面的序列号激活软件。序列号：<br><figure class="hljs highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">XAka<span class="hljs-number">34</span>A<span class="hljs-number">2</span>rVRYJ<span class="hljs-number">4</span>XBIU<span class="hljs-number">35</span>UZMUEEF<span class="hljs-number">64</span>CMMIYZCK<span class="hljs-number">2</span>FZZUQ<span class="hljs-symbol">NODEKUHGJLFMSLIQMQUCUBXRENLK6</span><span class="hljs-symbol">NZL37</span>JXP<span class="hljs-number">4</span>PZXQFILMQ<span class="hljs-number">2</span>R<span class="hljs-name">G5</span>R<span class="hljs-number">7</span><span class="hljs-name">G4</span>Q<span class="hljs-symbol">NDO3</span>PSOEUBOCDRYSSXZGRARV<span class="hljs-number">6</span>MGA<span class="hljs-number">33</span>T<span class="hljs-symbol">N2</span>AMUBHEL<span class="hljs-number">4</span>FXMWYTTJDEI<span class="hljs-symbol">NJXUAV4</span>BAYKBDCZQWVF<span class="hljs-number">3</span>LWYXSDCXY<span class="hljs-number">546</span>U<span class="hljs-number">3</span><span class="hljs-symbol">NBGOI3</span>ZPAP<span class="hljs-number">2</span>S<span class="hljs-meta">O3</span>CSQF<span class="hljs-symbol">NB7</span>VVIY<span class="hljs-number">123456789012345</span><br></code></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 面向对象之继承</title>
      <link href="/2018/01/18/cnblog_8310762/"/>
      <url>/2018/01/18/cnblog_8310762/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-面向对象之继承👈的摘要"><a href="#这是👉python-面向对象之继承👈的摘要" class="headerlink" title="这是👉python 面向对象之继承👈的摘要"></a><a href="/2018/01/18/cnblog_8310762/">这是👉python 面向对象之继承👈的摘要</a></h1><a id="more"></a><h1 id="继承介绍以及单继承"><a href="#继承介绍以及单继承" class="headerlink" title="继承介绍以及单继承"></a>继承介绍以及单继承</h1><h2 id="1-继承的概念"><a href="#1-继承的概念" class="headerlink" title="1. 继承的概念"></a>1. 继承的概念</h2><p>在现实生活中，继承一般指的是子女继承父辈的财产，如下图</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180118161133912-1761770035.png" alt=""></p><p>搞不好,结果如下..</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180118161141459-1921844836.png" alt=""></p><p>在程序中，继承描述的是事物之间的所属关系，例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物；同理，波斯猫和巴厘猫都继承自猫，而沙皮狗和斑点狗都继承足够，如下如所示：</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180118161148146-1415549914.png" alt=""></p><h2 id="2-继承示例"><a href="#2-继承示例" class="headerlink" title="2. 继承示例"></a>2. 继承示例</h2><p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code># 定义一个父类，如下:class Cat(object):    def __init__(self, name, color=&quot;白色&quot;):        self.name = name        self.color = color    def run(self):        print(&quot;%s--在跑&quot;%self.name)# 定义一个子类，继承Cat类如下:class Bosi(Cat):    def setNewName(self, newName):        self.name = newName    def eat(self):        print(&quot;%s--在吃&quot;%self.name)bs = Bosi(&quot;印度猫&quot;)print(&apos;bs的名字为:%s&apos;%bs.name)print(&apos;bs的颜色为:%s&apos;%bs.color)bs.eat()bs.setNewName(&apos;波斯&apos;)bs.run()</code></pre><p>View Code</p><p>运行结果:</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180118161243053-502102214.png" alt=""></p><p>说明：</p><ul><li>虽然子类没有定义<code>__init__</code>方法，但是父类有，所以在子类继承父类的时候这个方法就被继承了，所以只要创建Bosi的对象，就默认执行了那个继承过来的<code>__init__</code>方法</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>子类在继承的时候，在定义类时，小括号()中为父类的名字</li><li>父类的属性、方法，会被继承给子类</li></ul><h2 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h2><p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>class Animal(object):    def __init__(self, name=&apos;动物&apos;, color=&apos;白色&apos;):        self.__name = name        self.color = color    def __test(self):        print(self.__name)        print(self.color)    def test(self):        print(self.__name)        print(self.color)class Dog(Animal):    def dogTest1(self):        #print(self.__name) #不能访问到父类的私有属性        print(self.color)    def dogTest2(self):        #self.__test() #不能访问父类中的私有方法        self.test()A = Animal()#print(A.__name) #程序出现异常，不能访问私有属性print(A.color)#A.__test() #程序出现异常，不能访问私有方法A.test()print(&quot;------分割线-----&quot;)D = Dog(name = &quot;小花狗&quot;, color = &quot;黄色&quot;)D.dogTest1()D.dogTest2()</code></pre><p>View Code</p><ul><li>私有的属性，不能通过对象直接访问，但是可以通过方法访问</li><li>私有的方法，不能通过对象直接访问</li><li>私有的属性、方法，不会被子类继承，也不能被访问</li><li>一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用</li></ul><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><h2 id="1-多继承"><a href="#1-多继承" class="headerlink" title="1. 多继承"></a>1. 多继承</h2><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180118161455396-104729984.png" alt=""></p><p>从图中能够看出，所谓多继承，即子类有多个父类，并且具有它们的特征</p><p>Python中多继承的格式如下:</p><p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code># 定义一个父类class A:    def printA(self):        print(&apos;----A----&apos;)# 定义一个父类class B:    def printB(self):        print(&apos;----B----&apos;)# 定义一个子类，继承自A、Bclass C(A,B):    def printC(self):        print(&apos;----C----&apos;)obj_C = C()obj_C.printA()obj_C.printB()</code></pre><p>View Code</p><p>运行结果:</p><pre><code>----A--------B----</code></pre><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>python中是可以多继承的</li><li>父类中的方法、属性，子类会继承</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><blockquote><p>如果在上面的多继承例子中，如果父类A和父类B中，有一个同名的方法，那么通过子类去调用的时候，调用哪个？</p></blockquote><p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#coding=utf-8class base(object):    def test(self):        print(&apos;----base test----&apos;)class A(base):    def test(self):        print(&apos;----A test----&apos;)# 定义一个父类class B(base):    def test(self):        print(&apos;----B test----&apos;)# 定义一个子类，继承自A、Bclass C(A,B):    passobj_C = C()obj_C.test()print(C.__mro__) #可以查看C类的对象搜索方法时的先后顺序</code></pre><p>View Code</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 面向对象之老王开枪</title>
      <link href="/2018/01/18/cnblog_8310708/"/>
      <url>/2018/01/18/cnblog_8310708/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-面向对象之老王开枪👈的摘要"><a href="#这是👉python-面向对象之老王开枪👈的摘要" class="headerlink" title="这是👉python 面向对象之老王开枪👈的摘要"></a><a href="/2018/01/18/cnblog_8310708/">这是👉python 面向对象之老王开枪👈的摘要</a></h1><a id="more"></a><h1 id="老王开枪"><a href="#老王开枪" class="headerlink" title="老王开枪"></a>老王开枪</h1><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180118160430068-1998370869.png" alt=""></p><h3 id="1-人类"><a href="#1-人类" class="headerlink" title="1. 人类"></a>1. 人类</h3><ul><li>属性 <ul><li>姓名</li><li>血量</li><li>持有的枪</li></ul></li><li>方法 <ul><li>安子弹</li><li>安弹夹</li><li>拿枪（持有抢）</li><li>开枪</li></ul></li></ul><h3 id="2-子弹类"><a href="#2-子弹类" class="headerlink" title="2. 子弹类"></a>2. 子弹类</h3><ul><li>属性 <ul><li>杀伤力</li></ul></li><li>方法 <ul><li>伤害敌人(让敌人掉血)</li></ul></li></ul><h3 id="3-弹夹类"><a href="#3-弹夹类" class="headerlink" title="3. 弹夹类"></a>3. 弹夹类</h3><ul><li>属性 <ul><li>容量（子弹存储的最大值）</li><li>当前保存的子弹</li></ul></li><li>方法 <ul><li>保存子弹（安装子弹的时候）</li><li>弹出子弹（开枪的时候）</li></ul></li></ul><h3 id="4-枪类"><a href="#4-枪类" class="headerlink" title="4. 枪类"></a>4. 枪类</h3><ul><li>属性 <ul><li>弹夹（默认没有弹夹，需要安装）</li></ul></li><li>方法 <ul><li>连接弹夹（保存弹夹）</li><li>射子弹</li></ul></li></ul><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>#人类class Ren:    def __init__(self,name):        self.name = name        self.xue = 100        self.qiang = None    def __str__(self):        return self.name + &quot;剩余血量为:&quot; + str(self.xue)    def anzidan(self,danjia,zidan):        danjia.baocunzidan(zidan)    def andanjia(self,qiang,danjia):        qiang.lianjiedanjia(danjia)    def naqiang(self,qiang):        self.qiang = qiang    def kaiqiang(self,diren):        self.qiang.she(diren)    def diaoxue(self,shashangli):        self.xue -= shashangli#弹夹类class Danjia:    def __init__(self, rongliang):        self.rongliang = rongliang        self.rongnaList = []    def __str__(self):        return &quot;弹夹当前的子弹数量为:&quot; + str(len(self.rongnaList)) + &quot;/&quot; + str(self.rongliang)    def baocunzidan(self,zidan):        if len(self.rongnaList) &lt; self.rongliang:            self.rongnaList.append(zidan)    def chuzidan(self):        #判断当前弹夹中是否还有子弹        if len(self.rongnaList) &gt; 0:            #获取最后压入到单间中的子弹            zidan = self.rongnaList[-1]            self.rongnaList.pop()            return zidan        else:            return None#子弹类class Zidan:    def __init__(self,shashangli):        self.shashangli = shashangli    def shanghai(self,diren):        diren.diaoxue(self.shashangli)#枪类class Qiang:    def __init__(self):        self.danjia = None    def __str__(self):        if self.danjia:            return &quot;枪当前有弹夹&quot;        else:            return &quot;枪没有弹夹&quot;    def lianjiedanjia(self,danjia):        if not self.danjia:            self.danjia = danjia    def she(self,diren):        zidan = self.danjia.chuzidan()        if zidan:            zidan.shanghai(diren)        else:            print(&quot;没有子弹了，放了空枪....&quot;)#创建一个人对象laowang = Ren(&quot;老王&quot;)#创建一个弹夹danjia = Danjia(20)print(danjia)#循环的方式创建一颗子弹，然后让老王把这颗子弹压入到弹夹中i=0while i&lt;5:    zidan = Zidan(5)    laowang.anzidan(danjia,zidan)    i+=1#测试一下，安装完子弹后，弹夹中的信息print(danjia)#创建一个枪对象qiang = Qiang()print(qiang)#让老王，把弹夹连接到枪中laowang.andanjia(qiang,danjia)print(qiang)#创建一个敌人diren = Ren(&quot;敌人&quot;)print(diren)#让老王拿起枪laowang.naqiang(qiang)#老王开枪射敌人laowang.kaiqiang(diren)print(diren)print(danjia)laowang.kaiqiang(diren)print(diren)print(danjia)</code></pre><p>View Code</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 面向对象</title>
      <link href="/2018/01/15/cnblog_8286595/"/>
      <url>/2018/01/15/cnblog_8286595/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-面向对象👈的摘要"><a href="#这是👉python-面向对象👈的摘要" class="headerlink" title="这是👉python 面向对象👈的摘要"></a><a href="/2018/01/15/cnblog_8286595/">这是👉python 面向对象👈的摘要</a></h1><a id="more"></a><ul><li>面向过程：根据业务逻辑从上到下写代码</li><li>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</li></ul><h1 id="用面向对象的思维解决问题的重点"><a href="#用面向对象的思维解决问题的重点" class="headerlink" title="用面向对象的思维解决问题的重点"></a>用面向对象的思维解决问题的重点</h1><ul><li><p>当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程</p></li><li><p>应该找一个专门做这个事的人来做</p></li><li><p>面向对象是基于面向过程的</p></li></ul><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>面向对象编程的2个非常重要的概念：类和对象</p><p>对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念—-类</p><p>类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>​    人以类聚 物以群分。<br>​    具有相似内部状态和运动规律的实体的集合(或统称、抽象)。<br>​    具有相同属性和行为事物的统称</p><p>类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180115162152209-460201054.png" alt=""></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。可以是直接使用的</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180115162154599-549314831.png" alt=""></p><h2 id="类和对象之间的关系"><a href="#类和对象之间的关系" class="headerlink" title="类和对象之间的关系"></a>类和对象之间的关系</h2><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180115162202209-83368123.png" alt=""></p><p>类就是创建对象的模板</p><h2 id="区分类和对象"><a href="#区分类和对象" class="headerlink" title="区分类和对象"></a>区分类和对象</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">奔驰汽车 类<br>奔驰smart 类 <br>张三的那辆奔驰smart 对象<br>狗 类<br>大黄狗 类 <br>李四家那只大黄狗 对象 <br>水果 类<br>苹果 类 <br>红苹果 类 红富士苹果 类 <br>我嘴里吃了一半的苹果 对象<br></code></pre></td></tr></table></figure><h2 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h2><p>类(Class) 由3个部分构成</p><ul><li>类的名称:类名</li><li>类的属性:一组数据</li><li>类的方法:允许对进行操作的方法 (行为)</li></ul><h3 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h3><p>1）人的类设计,只关心3样东西:</p><ul><li>事物名称(类名):人(Person)</li><li>属性:身高(height)、年龄(age)</li><li>方法(行为/功能):跑(run)、打架(fight)</li></ul><p>2）狗类的设计</p><ul><li>类名:狗(Dog)</li><li>属性:品种 、毛色、性别、名字、 腿儿的数量</li><li>方法(行为/功能):叫 、跑、咬人、吃、摇尾巴</li></ul><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180115162113068-891529604.png" alt=""></p><h2 id="类的抽象"><a href="#类的抽象" class="headerlink" title="类的抽象"></a>类的抽象</h2><p>如何把日常生活中的事物抽象成程序中的类?<br>拥有相同(或者类似)属性和行为的对象都可以抽像出一个类<br>一般名词都是类(名词提炼法)</p><h3 id="坦克发射3颗炮弹轰掉了2架飞机"><a href="#坦克发射3颗炮弹轰掉了2架飞机" class="headerlink" title=" 坦克发射3颗炮弹轰掉了2架飞机"></a><1> 坦克发射3颗炮弹轰掉了2架飞机</1></h3><ul><li>坦克–》可以抽象成 类</li><li>炮弹–》可以抽象成类</li><li>飞机-》可以抽象成类<h3 id="小明在公车上牵着一条叼着热狗的狗"><a href="#小明在公车上牵着一条叼着热狗的狗" class="headerlink" title=" 小明在公车上牵着一条叼着热狗的狗"></a><2> 小明在公车上牵着一条叼着热狗的狗</2></h3></li><li>小明–》 人类</li><li>公车–》 交通工具类</li><li>热狗–》 食物类</li><li>狗–》 狗类</li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python os模块</title>
      <link href="/2018/01/12/cnblog_8277029/"/>
      <url>/2018/01/12/cnblog_8277029/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-os模块👈的摘要"><a href="#这是👉python-os模块👈的摘要" class="headerlink" title="这是👉python os模块👈的摘要"></a><a href="/2018/01/12/cnblog_8277029/">这是👉python os模块👈的摘要</a></h1><a id="more"></a><h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><figure class="hljs highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">os</span>.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径<br><span class="hljs-built_in">os</span>.chdir(<span class="hljs-string">"dirname"</span>)  改变当前脚本工作目录；相当于shell下cd<br><span class="hljs-built_in">os</span>.curdir  返回当前目录: (<span class="hljs-string">'.'</span>)<br><span class="hljs-built_in">os</span>.pardir  获取当前目录的父目录字符串名：(<span class="hljs-string">'..'</span>)<br><span class="hljs-built_in">os</span>.makedirs(<span class="hljs-string">'dirname1/dirname2'</span>)    可生成多层递归目录<br><span class="hljs-built_in">os</span>.removedirs(<span class="hljs-string">'dirname1'</span>)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推<br><span class="hljs-built_in">os</span>.mkdir(<span class="hljs-string">'dirname'</span>)    生成单级目录；相当于shell中mkdir dirname<br><span class="hljs-built_in">os</span>.rmdir(<span class="hljs-string">'dirname'</span>)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname<br><span class="hljs-built_in">os</span>.listdir(<span class="hljs-string">'dirname'</span>)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印<br><span class="hljs-built_in">os</span>.remove()  删除一个文件<br><span class="hljs-built_in">os</span>.rename(<span class="hljs-string">"oldname"</span>,<span class="hljs-string">"newname"</span>)  重命名文件/目录<br><span class="hljs-built_in">os</span>.stat(<span class="hljs-string">'path/filename'</span>)  获取文件/目录信息<br><span class="hljs-built_in">os</span>.sep    输出操作系统特定的路径分隔符，win下为<span class="hljs-string">"\\"</span>,Linux下为<span class="hljs-string">"/"</span><br><span class="hljs-built_in">os</span>.linesep    输出当前平台使用的行终止符，win下为<span class="hljs-string">"\t\n"</span>,Linux下为<span class="hljs-string">"\n"</span><br><span class="hljs-built_in">os</span>.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:<br><span class="hljs-built_in">os</span>.name    输出字符串指示当前使用平台。win-&gt;<span class="hljs-string">'nt'</span>; Linux-&gt;<span class="hljs-string">'posix'</span><br><span class="hljs-built_in">os</span>.system(<span class="hljs-string">"bash command"</span>)  运行shell命令，直接显示<br><span class="hljs-built_in">os</span>.popen(<span class="hljs-string">"bash command).read()  运行shell命令，获取执行结果<br>os.environ  获取系统环境变量</span><br></code></pre></td></tr></table></figure><h2 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h2><figure class="hljs highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(<span class="hljs-built_in">path</span>) 返回<span class="hljs-built_in">path</span>规范化的绝对路径 <br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">path</span>) 将<span class="hljs-built_in">path</span>分割成目录和文件名二元组返回 <br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.dirname(<span class="hljs-built_in">path</span>) 返回<span class="hljs-built_in">path</span>的目录。其实就是<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">path</span>)的第一个元素    <br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.basename(<span class="hljs-built_in">path</span>) 返回<span class="hljs-built_in">path</span>最后的文件名。如何<span class="hljs-built_in">path</span>以／或\结尾，那么就会返回空值。即<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">path</span>)的第二个元素<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.exists(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>存在，返回True；如果<span class="hljs-built_in">path</span>不存在，返回False<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isabs(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>是绝对路径，返回True<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isfile(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>是一个存在的文件，返回True。否则返回False<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(<span class="hljs-built_in">path</span>)  如果<span class="hljs-built_in">path</span>是一个存在的目录，则返回True。否则返回False<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.getatime(<span class="hljs-built_in">path</span>)  返回<span class="hljs-built_in">path</span>所指向的文件或者目录的最后访问时间<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.getmtime(<span class="hljs-built_in">path</span>)  返回<span class="hljs-built_in">path</span>所指向的文件或者目录的最后修改时间<br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.getsize(<span class="hljs-built_in">path</span>) 返回<span class="hljs-built_in">path</span>的大小<br></code></pre></td></tr></table></figure><p>注意：os.stat(‘path/filename’)  获取文件/目录信息 的结构说明</p><figure class="hljs highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-symbol">st_mode:</span> inode 保护模式<br><span class="hljs-symbol">st_ino:</span> inode 节点号。<br><span class="hljs-symbol">st_dev:</span> inode 驻留的设备。<br><span class="hljs-symbol">st_nlink:</span> inode 的链接数。<br><span class="hljs-symbol">st_uid:</span> 所有者的用户ID。<br><span class="hljs-symbol">st_gid:</span> 所有者的组ID。<br><span class="hljs-symbol">st_size:</span> 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。<br><span class="hljs-symbol">st_atime:</span> 上次访问的时间。<br><span class="hljs-symbol">st_mtime:</span> 最后一次修改的时间。<br><span class="hljs-symbol">st_ctime:</span> 由操作系统报告的<span class="hljs-string">"ctime"</span>。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。<br></code></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 时间模块time</title>
      <link href="/2018/01/10/cnblog_8258730/"/>
      <url>/2018/01/10/cnblog_8258730/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-时间模块time👈的摘要"><a href="#这是👉python-时间模块time👈的摘要" class="headerlink" title="这是👉python 时间模块time👈的摘要"></a><a href="/2018/01/10/cnblog_8258730/">这是👉python 时间模块time👈的摘要</a></h1><a id="more"></a><h1 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h1><h3 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h3><h3 id="1-思维导图"><a href="#1-思维导图" class="headerlink" title="1 思维导图"></a>1 思维导图</h3><p><a href="https://www.processon.com/view/link/5a548e2ee4b010a6e70c13d6" title="python 模块" target="_blank" rel="noopener"><img src="http://on-img.com/chart_image/5a5441d4e4b0abe85d46b5f4.png" alt="python 模块"></a></p><p>和时间有关系的我们就要用到时间模块。在使用模块之前，应该首先导入这个模块。</p><pre><code>#常用方法1.time.sleep(secs)(线程)推迟指定的时间运行。单位为秒。2.time.time()获取当前时间戳</code></pre><p><strong>表示时间的三种方式</strong></p><p>在Python中，通常有这三种方式来表示时间：时间戳、元组(struct_time)、格式化的时间字符串：</p><p>(1)时间戳(timestamp)<br>：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行”type(time.time())”，返回的是float类型。</p><p>(2)格式化的时间字符串(Format String)： ‘1999-12-06’</p><p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>%y 两位数的年份表示（00-99）%Y 四位数的年份表示（000-9999）%m 月份（01-12）%d 月内中的一天（0-31）%H 24小时制小时数（0-23）%I 12小时制小时数（01-12）%M 分钟数（00=59）%S 秒（00-59）%a 本地简化星期名称%A 本地完整星期名称%b 本地简化的月份名称%B 本地完整的月份名称%c 本地相应的日期表示和时间表示%j 年内的一天（001-366）%p 本地A.M.或P.M.的等价符%U 一年中的星期数（00-53）星期天为星期的开始%w 星期（0-6），星期天为星期的开始%W 一年中的星期数（00-53）星期一为星期的开始%x 本地相应的日期表示%X 本地相应的时间表示%Z 当前时区的名称%% %号本身</code></pre><p>View Code</p><p>(3)元组(struct_time) ：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等）</p><table><thead><tr><th>索引（Index）</th><th>属性（Attribute）</th><th>值（Values）  </th></tr></thead><tbody><tr><td>0</td><td>tm_year（年）</td><td>比如2011  </td></tr><tr><td>1</td><td>tm_mon（月）</td><td>1 - 12  </td></tr><tr><td>2</td><td>tm_mday（日）</td><td>1 - 31  </td></tr><tr><td>3</td><td>tm_hour（时）</td><td>0 - 23  </td></tr><tr><td>4</td><td>tm_min（分）</td><td>0 - 59  </td></tr><tr><td>5</td><td>tm_sec（秒）</td><td>0 - 60  </td></tr><tr><td>6</td><td>tm_wday（weekday）</td><td>0 - 6（0表示周一）  </td></tr><tr><td>7</td><td>tm_yday（一年中的第几天）</td><td>1 - 366  </td></tr><tr><td>8</td><td>tm_isdst（是否是夏令时）</td><td>默认为0  </td></tr></tbody></table><p> 首先，我们先导入time模块，来认识一下python中表示时间的几种格式：</p><pre><code>#导入时间模块&gt;&gt;&gt;import time#时间戳&gt;&gt;&gt;time.time()1500875844.800804#时间字符串&gt;&gt;&gt;time.strftime(&quot;%Y-%m-%d %X&quot;)&apos;2017-07-24 13:54:37&apos;&gt;&gt;&gt;time.strftime(&quot;%Y-%m-%d %H-%M-%S&quot;)&apos;2017-07-24 13-55-04&apos;#时间元组:localtime将一个时间戳转换为当前时区的struct_timetime.localtime()time.struct_time(tm_year=2017, tm_mon=7, tm_mday=24,　　　　　　　　　　tm_hour=13, tm_min=59, tm_sec=37,                  tm_wday=0, tm_yday=205, tm_isdst=0)</code></pre><p>小结：时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的</p><p><strong>几种格式之间的转换</strong></p><p><img src="https://images2015.cnblogs.com/blog/827651/201707/827651-20170724144151992-1508626640.png" alt=""></p><pre><code>#时间戳--&gt;结构化时间#time.gmtime(时间戳)    #UTC时间，与英国伦敦当地时间一致#time.localtime(时间戳) #当地时间。例如我们现在在北京执行这个方法：与UTC时间相差8小时，UTC时间+8小时 = 北京时间 &gt;&gt;&gt;time.gmtime(1500000000)time.struct_time(tm_year=2017, tm_mon=7, tm_mday=14, tm_hour=2, tm_min=40, tm_sec=0, tm_wday=4, tm_yday=195, tm_isdst=0)&gt;&gt;&gt;time.localtime(1500000000)time.struct_time(tm_year=2017, tm_mon=7, tm_mday=14, tm_hour=10, tm_min=40, tm_sec=0, tm_wday=4, tm_yday=195, tm_isdst=0)#结构化时间--&gt;时间戳　#time.mktime(结构化时间)&gt;&gt;&gt;time_tuple = time.localtime(1500000000)&gt;&gt;&gt;time.mktime(time_tuple)1500000000.0#结构化时间--&gt;字符串时间#time.strftime(&quot;格式定义&quot;,&quot;结构化时间&quot;)  结构化时间参数若不传，则现实当前时间&gt;&gt;&gt;time.strftime(&quot;%Y-%m-%d %X&quot;)&apos;2017-07-24 14:55:36&apos;&gt;&gt;&gt;time.strftime(&quot;%Y-%m-%d&quot;,time.localtime(1500000000))&apos;2017-07-14&apos;#字符串时间--&gt;结构化时间#time.strptime(时间字符串,字符串对应格式)&gt;&gt;&gt;time.strptime(&quot;2017-03-16&quot;,&quot;%Y-%m-%d&quot;)time.struct_time(tm_year=2017, tm_mon=3, tm_mday=16, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=75, tm_isdst=-1)&gt;&gt;&gt;time.strptime(&quot;07/24/2017&quot;,&quot;%m/%d/%Y&quot;)time.struct_time(tm_year=2017, tm_mon=7, tm_mday=24, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=205, tm_isdst=-1)</code></pre><p><img src="https://images2015.cnblogs.com/blog/827651/201707/827651-20170724144235883-1963884021.png" alt=""></p><pre><code>#结构化时间 --&gt; %a %b %d %H:%M:%S %Y串#time.asctime(结构化时间) 如果不传参数，直接返回当前时间的格式化串&gt;&gt;&gt;time.asctime(time.localtime(1500000000))&apos;Fri Jul 14 10:40:00 2017&apos;&gt;&gt;&gt;time.asctime()&apos;Mon Jul 24 15:18:33 2017&apos;#%a %d %d %H:%M:%S %Y串 --&gt; 结构化时间#time.ctime(时间戳)  如果不传参数，直接返回当前时间的格式化串&gt;&gt;&gt;time.ctime()&apos;Mon Jul 24 15:19:07 2017&apos;&gt;&gt;&gt;time.ctime(1500000000)&apos;Fri Jul 14 10:40:00 2017&apos; </code></pre><p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p><pre><code>import timetrue_time=time.mktime(time.strptime(&apos;2017-09-11 08:30:00&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;))time_now=time.mktime(time.strptime(&apos;2017-09-12 11:00:00&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;))dif_time=time_now-true_timestruct_time=time.gmtime(dif_time)print(&apos;过去了%d年%d月%d天%d小时%d分钟%d秒&apos;%(struct_time.tm_year-1970,struct_time.tm_mon-1,                                       struct_time.tm_mday-1,struct_time.tm_hour,                                       struct_time.tm_min,struct_time.tm_sec))</code></pre><p>View Code</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python re模块</title>
      <link href="/2018/01/09/cnblog_8249990/"/>
      <url>/2018/01/09/cnblog_8249990/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-re模块👈的摘要"><a href="#这是👉python-re模块👈的摘要" class="headerlink" title="这是👉python re模块👈的摘要"></a><a href="/2018/01/09/cnblog_8249990/">这是👉python re模块👈的摘要</a></h1><a id="more"></a><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><h3 id="1-正则表达式概述"><a href="#1-正则表达式概述" class="headerlink" title="1.正则表达式概述"></a>1.正则表达式概述</h3><p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular<br>Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p>Regular<br>Expression的”Regular”一般被译为”正则”、”正规”、”常规”。此处的”Regular”即是”规则”、”规律”的意思，Regular<br>Expression即”描述某种规则的表达式”之意。</p><h3 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2 思维导图"></a>2 思维导图</h3><p><a href="https://www.processon.com/view/link/5a548e2ee4b010a6e70c13d6" title="python 模块" target="_blank" rel="noopener"><img src="http://on-img.com/chart_image/5a5441d4e4b0abe85d46b5f4.png" alt="python 模块"></a></p><h3 id="3表示方法"><a href="#3表示方法" class="headerlink" title="3表示方法"></a>3表示方法</h3><h4 id="re模块的使用过程"><a href="#re模块的使用过程" class="headerlink" title="re模块的使用过程"></a>re模块的使用过程</h4><pre><code># 导入re模块import re# 使用match方法进行匹配操作result = re.match(正则表达式,要匹配的字符串)# 如果上一步匹配到数据的话，可以使用group方法来提取数据result.group()</code></pre><h4 id="re-match是用来进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match"><a href="#re-match是用来进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match" class="headerlink" title="re.match是用来进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match"></a>re.match是用来进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match</h4><p>Object），否则返回None（注意不是空字符串””）。</p><h4 id="匹配对象Macth-Object具有group方法，用来返回字符串的匹配部分"><a href="#匹配对象Macth-Object具有group方法，用来返回字符串的匹配部分" class="headerlink" title="匹配对象Macth Object具有group方法，用来返回字符串的匹配部分"></a>匹配对象Macth Object具有group方法，用来返回字符串的匹配部分</h4><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python urllib https抓取网页的问题</title>
      <link href="/2018/01/08/cnblog_8244143/"/>
      <url>/2018/01/08/cnblog_8244143/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-urllib-https抓取网页的问题👈的摘要"><a href="#这是👉python-urllib-https抓取网页的问题👈的摘要" class="headerlink" title="这是👉python urllib https抓取网页的问题👈的摘要"></a><a href="/2018/01/08/cnblog_8244143/">这是👉python urllib https抓取网页的问题👈的摘要</a></h1><a id="more"></a><pre><code>from urllib import requestimport ssl# ssl._create_default_https_context = ssl._create_unverified_contextdef getHtml():    # url = &quot;https://m.80s.tw&quot;    url = &quot;https://www.80s.tw&quot;    data = request.urlopen(url).read().decode(&quot;utf-8&quot;)    return dataprint(getHtml())</code></pre><p>获取HTTPS的网页源码，是返回错误，</p><p>urllib.error.URLError: <urlopen error="" [ssl:="" certificate_verify_failed]="" certificate="" verify="" failed="" (_ssl.c:777)=""></urlopen></p><p>然后加上下面代码就可以了🙃</p><pre><code>import sslssl._create_default_https_context=ssl._create_unverified_context</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 匿名函数</title>
      <link href="/2018/01/08/cnblog_8241193/"/>
      <url>/2018/01/08/cnblog_8241193/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-匿名函数👈的摘要"><a href="#这是👉python-匿名函数👈的摘要" class="headerlink" title="这是👉python 匿名函数👈的摘要"></a><a href="/2018/01/08/cnblog_8241193/">这是👉python 匿名函数👈的摘要</a></h1><a id="more"></a><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。</p><p>lambda函数的语法只包含一个语句，如下：</p><pre><code>lambda [arg1 [,arg2,.....argn]]:expression</code></pre><p>如下实例：</p><pre><code>sum = lambda arg1, arg2: arg1 + arg2#调用sum函数print &quot;Value of total : &quot;, sum( 10, 20 )print &quot;Value of total : &quot;, sum( 20, 20 )</code></pre><p>以上实例输出结果：</p><pre><code>Value of total :  30Value of total :  40</code></pre><p>Lambda函数能接收任何数量的参数但只能返回一个表达式的值</p><p>匿名函数不能直接调用print，因为lambda需要一个表达式</p><h2 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h2><h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><ol><li><p>自己定义函数 </p><blockquote><blockquote><blockquote><p>def fun(a, b, opt):<br>…     print “a =”, a<br>…     print “b =”, b<br>…     print “result =”, opt(a, b)<br>…<br>fun(1, 2, lambda x,y:x+y)<br>a = 1<br>b = 2<br>result = 3</p></blockquote></blockquote></blockquote></li><li><p>作为内置函数的参数</p></li></ol><h4 id="想一想，下面的数据如何指定按age或name排序？"><a href="#想一想，下面的数据如何指定按age或name排序？" class="headerlink" title="想一想，下面的数据如何指定按age或name排序？"></a>想一想，下面的数据如何指定按age或name排序？</h4><pre><code>stus = [    {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18},     {&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:19},     {&quot;name&quot;:&quot;wangwu&quot;, &quot;age&quot;:17}]</code></pre><h4 id="按name排序："><a href="#按name排序：" class="headerlink" title="按name排序："></a>按name排序：</h4><pre><code>&gt;&gt;&gt; stus.sort(key = lambda x:x[&apos;name&apos;])&gt;&gt;&gt; stus[{&apos;age&apos;: 19, &apos;name&apos;: &apos;lisi&apos;}, {&apos;age&apos;: 17, &apos;name&apos;: &apos;wangwu&apos;}, {&apos;age&apos;: 18, &apos;name&apos;: &apos;zhangsan&apos;}]</code></pre><h4 id="按age排序："><a href="#按age排序：" class="headerlink" title="按age排序："></a>按age排序：</h4><pre><code>&gt;&gt;&gt; stus.sort(key = lambda x:x[&apos;age&apos;])&gt;&gt;&gt; stus[{&apos;age&apos;: 17, &apos;name&apos;: &apos;wangwu&apos;}, {&apos;age&apos;: 18, &apos;name&apos;: &apos;zhangsan&apos;}, {&apos;age&apos;: 19, &apos;name&apos;: &apos;lisi&apos;}]</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 递归函数</title>
      <link href="/2018/01/08/cnblog_8241349/"/>
      <url>/2018/01/08/cnblog_8241349/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-递归函数👈的摘要"><a href="#这是👉python-递归函数👈的摘要" class="headerlink" title="这是👉python 递归函数👈的摘要"></a><a href="/2018/01/08/cnblog_8241349/">这是👉python 递归函数👈的摘要</a></h1><a id="more"></a><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>举个例子，我们来计算阶乘 <code>n! = 1 * 2 * 3 * ... * n</code></p><h4 id="看阶乘的规律"><a href="#看阶乘的规律" class="headerlink" title="看阶乘的规律"></a>看阶乘的规律</h4><pre><code>1! = 12! = 2 × 1 = 2 × 1!3! = 3 × 2 × 1 = 3 × 2!4! = 4 × 3 × 2 × 1 = 4 × 3!...n! = n × (n-1)!</code></pre><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180108154510394-1346038869.png" alt=""></p><p>说白了，递归函数，就是自己调用自己！</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 内置函数</title>
      <link href="/2018/01/04/cnblog_8191328/"/>
      <url>/2018/01/04/cnblog_8191328/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-内置函数👈的摘要"><a href="#这是👉python-内置函数👈的摘要" class="headerlink" title="这是👉python 内置函数👈的摘要"></a><a href="/2018/01/04/cnblog_8191328/">这是👉python 内置函数👈的摘要</a></h1><a id="more"></a><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><p>接下来，我们就一起来看看python里的内置函数。截止到python版本3.6.2，现在python一共为我们提供了 <strong>68个内置函数</strong><br>。它们就是python提供给你直接可以拿来使用的所有函数。这些函数有些我们已经用过了，有些我们还没用到过，还有一些是被封印了，必须等我们学了新知识才能解开封印的。那今天我们就一起来认识一下python的内置函数。这么多函数，我们该从何学起呢？</p><table><thead><tr><th></th><th></th><th>Built-in Functions</th><th></th></tr></thead><tbody><tr><td>abs()</td><td>dict()</td><td>help()</td><td>min()</td><td>setattr()  </td></tr><tr><td>all()</td><td>dir()</td><td>hex()</td><td>next()</td><td>slice()  </td></tr><tr><td>any()</td><td>divmod()</td><td>id()</td><td>object()</td><td>sorted()  </td></tr><tr><td>ascii()</td><td>enumerate()</td><td>input()</td><td>oct()</td><td>staticmethod()  </td></tr><tr><td>bin()</td><td>eval()</td><td>int()</td><td>open()</td><td>str()  </td></tr><tr><td>bool()</td><td>exec()</td><td>isinstance()</td><td>ord()</td><td>sum()  </td></tr><tr><td>bytearray()</td><td>filter()</td><td>issubclass()</td><td>pow()</td><td>super()  </td></tr><tr><td>bytes()</td><td>float()</td><td>iter()</td><td>print()</td><td>tuple()  </td></tr><tr><td>callable()</td><td>format()</td><td>len()</td><td>property()</td><td>type()  </td></tr><tr><td>chr()</td><td>frozenset()</td><td>list()</td><td>range()</td><td>vars()  </td></tr><tr><td>classmethod()</td><td>getattr()</td><td>locals()</td><td>repr()</td><td>zip()  </td></tr><tr><td>compile()</td><td>globals()</td><td>map()</td><td>reversed()</td><td><strong>import</strong>()  </td></tr><tr><td>complex()</td><td>hasattr()</td><td>max()</td><td>round()</td><td></td></tr><tr><td>delattr()</td><td>hash()</td><td>memoryview()</td><td>set()</td><td></td></tr></tbody></table><p> 总结下图</p><p><a href="https://www.processon.com/view/link/5a547096e4b0c09052338cae" title="ss" target="_blank" rel="noopener"><img src="http://on-img.com/chart_image/5a4d90b8e4b0ee0fb8cc8b23.png" alt="思维导图"></a></p><p>点一下图片，有惊喜😂</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用pyInstaller打包py文件为exe文件</title>
      <link href="/2018/01/03/cnblog_8185308/"/>
      <url>/2018/01/03/cnblog_8185308/</url>
      <content type="html"><![CDATA[<h1 id="这是👉使用pyInstaller打包py文件为exe文件👈的摘要"><a href="#这是👉使用pyInstaller打包py文件为exe文件👈的摘要" class="headerlink" title="这是👉使用pyInstaller打包py文件为exe文件👈的摘要"></a><a href="/2018/01/03/cnblog_8185308/">这是👉使用pyInstaller打包py文件为exe文件👈的摘要</a></h1><a id="more"></a><p>安装 pip install pyinstaller</p><p> ①， 打包成一个文件：</p><p>_                        python pyinstaller.py –onefile  yourprogram.py<br> ②，修改exe的图标（D:\BabyWandH\src\faviconw.ico为图标的存放路径）：<br>                        python pyinstaller.py –onefile  --icon=D:\BabyWandH\src\faviconw.ico   yourprogram.py _</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201801/1301576-20180103192552534-2012446106.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 生成器</title>
      <link href="/2018/01/03/cnblog_8183674/"/>
      <url>/2018/01/03/cnblog_8183674/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-生成器👈的摘要"><a href="#这是👉python-生成器👈的摘要" class="headerlink" title="这是👉python 生成器👈的摘要"></a><a href="/2018/01/03/cnblog_8183674/">这是👉python 生成器👈的摘要</a></h1><a id="more"></a><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="1-什么是生成器"><a href="#1-什么是生成器" class="headerlink" title="1. 什么是生成器"></a>1. 什么是生成器</h2><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><h2 id="2-创建生成器方法1"><a href="#2-创建生成器方法1" class="headerlink" title="2. 创建生成器方法1"></a>2. 创建生成器方法1</h2><p>要创建一个生成器，有很多种方法。第一种方法很简单，只要把一个列表生成式的 [ ] 改成 ( )</p><pre><code>In [15]: L = [ x*2 for x in range(5)]In [16]: LOut[16]: [0, 2, 4, 6, 8]In [17]: G = ( x*2 for x in range(5))In [18]: GOut[18]: &lt;generator object &lt;genexpr&gt; at 0x7f626c132db0&gt;In [19]:</code></pre><p>创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) ， L 是一个列表，而 G<br>是一个生成器。我们可以直接打印出L的每一个元素，但我们怎么打印出G的每一个元素呢？如果要一个一个打印出来，可以通过 next()<br>函数获得生成器的下一个返回值：</p><pre><code>In [19]: next(G)Out[19]: 0In [20]: next(G)Out[20]: 2In [21]: next(G)Out[21]: 4In [22]: next(G)Out[22]: 6In [23]: next(G)Out[23]: 8In [24]: next(G)---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-24-380e167d6934&gt; in &lt;module&gt;()----&gt; 1 next(G)StopIteration: In [25]:In [26]: G = ( x*2 for x in range(5))In [27]: for x in G:   ....:     print(x)   ....:     02468In [28]:</code></pre><p>生成器保存的是算法，每次调用 next(G) ，就计算出 G 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration<br>的异常。当然，这种不断调用 next() 实在是太变态了，正确的方法是使用 for<br>循环，因为生成器也是可迭代对象。所以，我们创建了一个生成器后，基本上永远不会调用 next() ，而是通过 for 循环来迭代它，并且不需要关心<br>StopIteration 异常。</p><h2 id="3-创建生成器方法2"><a href="#3-创建生成器方法2" class="headerlink" title="3. 创建生成器方法2"></a>3. 创建生成器方法2</h2><p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的 for 循环无法实现的时候，还可以用函数来实现。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><pre><code>In [28]: def fib(times):   ....:     n = 0   ....:     a,b = 0,1   ....:     while n&lt;times:   ....:         print(b)   ....:         a,b = b,a+b   ....:         n+=1   ....:     return &apos;wilson&apos;   ....: In [29]: fib(5)11235Out[29]: &apos;wilson&apos;</code></pre><p>仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p><p>也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了：</p><pre><code>In [30]: def fib(times):   ....:     n = 0   ....:     a,b = 0,1   ....:     while n&lt;times:   ....:         yield b   ....:         a,b = b,a+b   ....:         n+=1   ....:     return &apos;done&apos;   ....: In [31]: F = fib(5)In [32]: next(F)Out[32]: 1In [33]: next(F)Out[33]: 1In [34]: next(F)Out[34]: 2In [35]: next(F)Out[35]: 3In [36]: next(F)Out[36]: 5In [37]: next(F)---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-37-8c2b02b4361a&gt; in &lt;module&gt;()----&gt; 1 next(F)StopIteration: done</code></pre><p>在上面fib 的例子，我们在循环过程中不断调用 yield<br>，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用 next()<br>来获取下一个返回值，而是直接使用 for 循环来迭代：</p><pre><code>In [38]: for n in fib(5):   ....:     print(n)   ....:     11235In [39]:</code></pre><p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：</p><pre><code>In [39]: g = fib(5)In [40]: while True:   ....:     try:   ....:         x = next(g)   ....:         print(&quot;value:%d&quot;%x)         ....:     except StopIteration as e:   ....:         print(&quot;生成器返回值:%s&quot;%e.value)   ....:         break   ....:     value:1value:1value:2value:3value:5生成器返回值:doneIn [41]:</code></pre><h2 id="4-send"><a href="#4-send" class="headerlink" title="4. send"></a>4. send</h2><p>例子：执行到yield时，gen函数作用暂时保存，返回i的值;temp接收下次c.send(“python”)，send发送过来的值，c.next()等价c.send(None)</p><pre><code>In [10]: def gen():   ....:     i = 0   ....:     while i&lt;5:   ....:         temp = yield i   ....:         print(temp)   ....:         i+=1   ....:</code></pre><h4 id="使用next函数"><a href="#使用next函数" class="headerlink" title="使用next函数"></a>使用next函数</h4><pre><code>In [11]: f = gen()In [12]: next(f)Out[12]: 0In [13]: next(f)NoneOut[13]: 1In [14]: next(f)NoneOut[14]: 2In [15]: next(f)NoneOut[15]: 3In [16]: next(f)NoneOut[16]: 4In [17]: next(f)None---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-17-468f0afdf1b9&gt; in &lt;module&gt;()----&gt; 1 next(f)StopIteration:</code></pre><h4 id="使用-next-方法"><a href="#使用-next-方法" class="headerlink" title="使用__next__()方法"></a>使用<code>__next__()</code>方法</h4><pre><code>In [18]: f = gen()In [19]: f.__next__()Out[19]: 0In [20]: f.__next__()NoneOut[20]: 1In [21]: f.__next__()NoneOut[21]: 2In [22]: f.__next__()NoneOut[22]: 3In [23]: f.__next__()NoneOut[23]: 4In [24]: f.__next__()None---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-24-39ec527346a9&gt; in &lt;module&gt;()----&gt; 1 f.__next__()StopIteration:</code></pre><h4 id="使用send"><a href="#使用send" class="headerlink" title="使用send"></a>使用send</h4><pre><code>In [43]: f = gen()In [44]: f.__next__()Out[44]: 0In [45]: f.send(&apos;haha&apos;)hahaOut[45]: 1In [46]: f.__next__()NoneOut[46]: 2In [47]: f.send(&apos;haha&apos;)hahaOut[47]: 3In [48]:</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。</p><p>生成器不仅”记住”了它数据状态；生成器还”记住”了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。</p><p>生成器的特点：</p><ol><li>节约内存</li><li>迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的</li></ol>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 迭代器</title>
      <link href="/2018/01/03/cnblog_8183568/"/>
      <url>/2018/01/03/cnblog_8183568/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-迭代器👈的摘要"><a href="#这是👉python-迭代器👈的摘要" class="headerlink" title="这是👉python 迭代器👈的摘要"></a><a href="/2018/01/03/cnblog_8183568/">这是👉python 迭代器👈的摘要</a></h1><a id="more"></a><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><h2 id="1-可迭代对象"><a href="#1-可迭代对象" class="headerlink" title="1. 可迭代对象"></a>1. 可迭代对象</h2><p>以直接作用于 for 循环的数据类型有以下几种：</p><p>一类是集合数据类型，如 list 、 tuple 、 dict 、 set 、 str 等；</p><p>一类是 generator ，包括生成器和带 yield 的generator function。</p><p>这些可以直接作用于 for 循环的对象统称为可迭代对象： Iterable 。</p><h2 id="2-判断是否可以迭代"><a href="#2-判断是否可以迭代" class="headerlink" title="2. 判断是否可以迭代"></a>2. 判断是否可以迭代</h2><p>可以使用 isinstance() 判断一个对象是否是 Iterable 对象：</p><pre><code>In [50]: from collections import IterableIn [51]: isinstance([], Iterable)Out[51]: TrueIn [52]: isinstance({}, Iterable)Out[52]: TrueIn [53]: isinstance(&apos;abc&apos;, Iterable)Out[53]: TrueIn [54]: isinstance((x for x in range(10)), Iterable)Out[54]: TrueIn [55]: isinstance(100, Iterable)Out[55]: False</code></pre><p>而生成器不但可以作用于 for 循环，还可以被 next() 函数不断调用并返回下一个值，直到最后抛出 StopIteration<br>错误表示无法继续返回下一个值了。</p><h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3.迭代器"></a>3.迭代器</h2><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</p><p>可以使用 isinstance() 判断一个对象是否是 Iterator 对象：</p><pre><code>In [56]: from collections import IteratorIn [57]: isinstance((x for x in range(10)), Iterator)Out[57]: TrueIn [58]: isinstance([], Iterator)Out[58]: FalseIn [59]: isinstance({}, Iterator)Out[59]: FalseIn [60]: isinstance(&apos;abc&apos;, Iterator)Out[60]: FalseIn [61]: isinstance(100, Iterator)Out[61]: False</code></pre><h2 id="4-iter-函数"><a href="#4-iter-函数" class="headerlink" title="4.iter()函数"></a>4.iter()函数</h2><p>生成器都是 Iterator 对象，但 list 、 dict 、 str 虽然是 Iterable ，却不是 Iterator 。</p><p>把 list 、 dict 、 str 等 Iterable 变成 Iterator 可以使用 iter() 函数：</p><pre><code>In [62]: isinstance(iter([]), Iterator)Out[62]: TrueIn [63]: isinstance(iter(&apos;abc&apos;), Iterator)Out[63]: True</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>凡是可作用于 for 循环的对象都是 Iterable 类型；</li><li>凡是可作用于 next() 函数的对象都是 Iterator 类型</li><li>集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象。</li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 装饰器</title>
      <link href="/2017/12/28/cnblog_8134274/"/>
      <url>/2017/12/28/cnblog_8134274/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-装饰器👈的摘要"><a href="#这是👉python-装饰器👈的摘要" class="headerlink" title="这是👉python 装饰器👈的摘要"></a><a href="/2017/12/28/cnblog_8134274/">这是👉python 装饰器👈的摘要</a></h1><a id="more"></a><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，所以这也是Python面试中必问的问题，但对于好多初次接触这个知识的人来讲，这个功能有点绕，自学时直接绕过去了，然后面试问到了就挂了，因为装饰器是程序开发的基础知识，这个都不会，别跟人家说你会Python,<br>看了下面的文章，保证你学会装饰器。</p><h2 id="1、先明白这段代码"><a href="#1、先明白这段代码" class="headerlink" title="1、先明白这段代码"></a>1、先明白这段代码</h2><pre><code>#### 第一波 ####def foo():    print(&apos;foo&apos;)foo     #表示是函数foo()   #表示执行foo函数#### 第二波 ####def foo():    print(&apos;foo&apos;)foo = lambda x: x + 1foo()   # 执行下面的lambda表达式，而不再是原来的foo函数，因为foo这个名字被重新指向了另外一个匿名函数</code></pre><h2 id="2、需求来了"><a href="#2、需求来了" class="headerlink" title="2、需求来了"></a>2、需求来了</h2><p>初创公司有N个业务部门，1个基础平台部门，基础平台负责提供底层的功能，如：数据库操作、redis调用、监控API等功能。业务部门使用基础功能时，只需调用基础平台提供的功能即可。如下：</p><pre><code>############### 基础平台提供的功能如下 ###############def f1():    print(&apos;f1&apos;)def f2():    print(&apos;f2&apos;)def f3():    print(&apos;f3&apos;)def f4():    print(&apos;f4&apos;)############### 业务部门A 调用基础平台提供的功能 ###############f1()f2()f3()f4()############### 业务部门B 调用基础平台提供的功能 ###############f1()f2()f3()f4()</code></pre><p>目前公司有条不紊的进行着，但是，以前基础平台的开发人员在写代码时候没有关注验证相关的问题，即：基础平台的提供的功能可以被任何人使用。现在需要对基础平台的所有功能进行重构，为平台提供的所有功能添加验证机制，即：执行功能前，先进行验证。</p><h4 id="老大把工作交给-Low-B，他是这么做的："><a href="#老大把工作交给-Low-B，他是这么做的：" class="headerlink" title="老大把工作交给 Low B，他是这么做的："></a>老大把工作交给 Low B，他是这么做的：</h4><blockquote><p>跟每个业务部门交涉，每个业务部门自己写代码，调用基础平台的功能之前先验证。诶，这样一来基础平台就不需要做任何修改了。太棒了，有充足的时间泡妹子…</p></blockquote><p>当天Low B 被开除了…</p><h4 id="老大把工作交给-Low-BB，他是这么做的："><a href="#老大把工作交给-Low-BB，他是这么做的：" class="headerlink" title="老大把工作交给 Low BB，他是这么做的："></a>老大把工作交给 Low BB，他是这么做的：</h4><pre><code>############### 基础平台提供的功能如下 ############### def f1():    # 验证1    # 验证2    # 验证3    print(&apos;f1&apos;)def f2():    # 验证1    # 验证2    # 验证3    print(&apos;f2&apos;)def f3():    # 验证1    # 验证2    # 验证3    print(&apos;f3&apos;)def f4():    # 验证1    # 验证2    # 验证3    print(&apos;f4&apos;)############### 业务部门不变 ############### ### 业务部门A 调用基础平台提供的功能### f1()f2()f3()f4()### 业务部门B 调用基础平台提供的功能 ### f1()f2()f3()f4()</code></pre><p>过了一周 Low BB 被开除了…</p><h4 id="老大把工作交给-Low-BBB，他是这么做的："><a href="#老大把工作交给-Low-BBB，他是这么做的：" class="headerlink" title="老大把工作交给 Low BBB，他是这么做的："></a>老大把工作交给 Low BBB，他是这么做的：</h4><blockquote><p>只对基础平台的代码进行重构，其他业务部门无需做任何修改</p></blockquote><pre><code>############### 基础平台提供的功能如下 ############### def check_login():    # 验证1    # 验证2    # 验证3    passdef f1():    check_login()    print(&apos;f1&apos;)def f2():    check_login()    print(&apos;f2&apos;)def f3():    check_login()    print(&apos;f3&apos;)def f4():    check_login()    print(&apos;f4&apos;)</code></pre><p>老大看了下Low BBB 的实现，嘴角漏出了一丝的欣慰的笑，语重心长的跟Low BBB聊了个天：</p><h5 id="老大说："><a href="#老大说：" class="headerlink" title="老大说："></a>老大说：</h5><p>写代码要遵循<code>开放封闭</code>原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：</p><ul><li>封闭：已实现的功能代码块</li><li>开放：对扩展开发</li></ul><p>如果将开放封闭原则应用在上述需求中，那么就不允许在函数 f1 、f2、f3、f4的内部进行修改代码，老板就给了Low BBB一个实现方案：</p><pre><code>def w1(func):    def inner():        # 验证1        # 验证2        # 验证3        func()    return inner@w1def f1():    print(&apos;f1&apos;)@w1def f2():    print(&apos;f2&apos;)@w1def f3():    print(&apos;f3&apos;)@w1def f4():    print(&apos;f4&apos;)</code></pre><p>对于上述代码，也是仅仅对基础平台的代码进行修改，就可以实现在其他人调用函数 f1 f2 f3 f4 之前都进行【验证】操作，并且其他业务部门无需做任何操作。</p><p>Low BBB心惊胆战的问了下，这段代码的内部执行原理是什么呢？</p><p>老大正要生气，突然Low BBB的手机掉到地上，恰巧屏保就是Low BBB的女友照片，老大一看一紧一抖，喜笑颜开，决定和Low BBB交个好朋友。</p><p>详细的开始讲解了：</p><p>单独以f1为例：</p><pre><code>def w1(func):    def inner():        # 验证1        # 验证2        # 验证3        func()    return inner@w1def f1():    print(&apos;f1&apos;)</code></pre><p>python解释器就会从上到下解释代码，步骤如下：</p><ol><li>def w1(func): ==&gt;将w1函数加载到内存</li><li>@w1</li></ol><p>没错， 从表面上看解释器仅仅会解释这两句代码，因为函数在 没有被调用之前其内部代码不会被执行。</p><p>从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章， @函数名 是python的一种语法糖。</p><h3 id="上例-w1内部会执行一下操作："><a href="#上例-w1内部会执行一下操作：" class="headerlink" title="上例@w1内部会执行一下操作："></a>上例@w1内部会执行一下操作：</h3><h4 id="执行w1函数"><a href="#执行w1函数" class="headerlink" title="执行w1函数"></a>执行w1函数</h4><blockquote><p>执行w1函数 ，并将 @w1 下面的函数作为w1函数的参数，即：@w1 等价于 w1(f1) 所以，内部就会去执行：</p></blockquote><blockquote><pre><code>def inner():</code></pre></blockquote><blockquote><pre><code>#验证 1</code></pre></blockquote><blockquote><pre><code>#验证 2</code></pre></blockquote><blockquote><pre><code>#验证 3</code></pre></blockquote><blockquote><pre><code>f1()     # func是参数，此时 func 等于 f1</code></pre></blockquote><blockquote><pre><code>return inner# 返回的 inner，inner代表的是函数，非执行函数 ,其实就是将原来的 f1 函数塞进另外一个函数中</code></pre></blockquote><h4 id="w1的返回值"><a href="#w1的返回值" class="headerlink" title="w1的返回值"></a>w1的返回值</h4><blockquote><p>将执行完的w1函数返回值 赋值 给@w1下面的函数的函数名f1 即将w1的返回值再重新赋值给 f1，即：</p></blockquote><blockquote><pre><code>新f1 = def inner():</code></pre></blockquote><blockquote><pre><code>#验证 1</code></pre></blockquote><blockquote><pre><code>#验证 2</code></pre></blockquote><blockquote><pre><code>#验证 3</code></pre></blockquote><blockquote><pre><code>原来f1()</code></pre></blockquote><blockquote><pre><code>return inner</code></pre></blockquote><blockquote></blockquote><blockquote><p>所以，以后业务部门想要执行 f1 函数时，就会执行 新f1 函数，在新f1 函数内部先执行验证，再执行原来的f1函数，然后将原来f1<br>函数的返回值返回给了业务调用者。</p></blockquote><p>如此一来， 即执行了验证的功能，又执行了原来f1函数的内容，并将原f1函数返回值 返回给业务调用着</p><p>Low BBB 你明白了吗？要是没明白的话，我晚上去你家帮你解决吧！！！</p><h2 id="3-再议装饰器"><a href="#3-再议装饰器" class="headerlink" title="3. 再议装饰器"></a>3. 再议装饰器</h2><pre><code>#定义函数：完成包裹数据def makeBold(fn):    def wrapped():        return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;    return wrapped#定义函数：完成包裹数据def makeItalic(fn):    def wrapped():        return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot;    return wrapped@makeBolddef test1():    return &quot;hello world-1&quot;@makeItalicdef test2():    return &quot;hello world-2&quot;@makeBold@makeItalicdef test3():    return &quot;hello world-3&quot;print(test1()))print(test2()))print(test3()))运行结果:&lt;b&gt;hello world-1&lt;/b&gt;&lt;i&gt;hello world-2&lt;/i&gt;&lt;b&gt;&lt;i&gt;hello world-3&lt;/i&gt;&lt;/b&gt;</code></pre><h2 id="4-装饰器-decorator-功能"><a href="#4-装饰器-decorator-功能" class="headerlink" title="4. 装饰器(decorator)功能"></a>4. 装饰器(decorator)功能</h2><ol><li>引入日志</li><li>函数执行时间统计</li><li>执行函数前预备处理</li><li>执行函数后清理功能</li><li>权限校验等场景</li><li>缓存</li></ol><h2 id="5-装饰器示例"><a href="#5-装饰器示例" class="headerlink" title="5. 装饰器示例"></a>5. 装饰器示例</h2><h3 id="例1-无参数的函数"><a href="#例1-无参数的函数" class="headerlink" title="例1:无参数的函数"></a>例1:无参数的函数</h3><pre><code>from time import ctime, sleepdef timefun(func):    def wrappedfunc():        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))        func()    return wrappedfunc@timefundef foo():    print(&quot;I am foo&quot;)foo()sleep(2)foo()</code></pre><p>上面代码理解装饰器执行行为可理解成</p><pre><code>foo = timefun(foo)#foo先作为参数赋值给func后,foo接收指向timefun返回的wrappedfuncfoo()#调用foo(),即等价调用wrappedfunc()#内部函数wrappedfunc被引用，所以外部函数的func变量(自由变量)并没有释放#func里保存的是原foo函数对象</code></pre><h3 id="例2-被装饰的函数有参数"><a href="#例2-被装饰的函数有参数" class="headerlink" title="例2:被装饰的函数有参数"></a>例2:被装饰的函数有参数</h3><pre><code>from time import ctime, sleepdef timefun(func):    def wrappedfunc(a, b):        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))        print(a, b)        func(a, b)    return wrappedfunc@timefundef foo(a, b):    print(a+b)foo(3,5)sleep(2)foo(2,4)</code></pre><h3 id="例3-被装饰的函数有不定长参数"><a href="#例3-被装饰的函数有不定长参数" class="headerlink" title="例3:被装饰的函数有不定长参数"></a>例3:被装饰的函数有不定长参数</h3><pre><code>from time import ctime, sleepdef timefun(func):    def wrappedfunc(*args, **kwargs):        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))        func(*args, **kwargs)    return wrappedfunc@timefundef foo(a, b, c):    print(a+b+c)foo(3,5,7)sleep(2)foo(2,4,9)</code></pre><h3 id="例4-装饰器中的return"><a href="#例4-装饰器中的return" class="headerlink" title="例4:装饰器中的return"></a>例4:装饰器中的return</h3><pre><code>from time import ctime, sleepdef timefun(func):    def wrappedfunc():        print(&quot;%s called at %s&quot;%(func.__name__, ctime()))        func()    return wrappedfunc@timefundef foo():    print(&quot;I am foo&quot;)@timefundef getInfo():    return &apos;----hahah---&apos;foo()sleep(2)foo()print(getInfo())</code></pre><p>执行结果:</p><pre><code>foo called at Fri Nov  4 21:55:35 2016I am foofoo called at Fri Nov  4 21:55:37 2016I am foogetInfo called at Fri Nov  4 21:55:37 2016None</code></pre><p>如果修改装饰器为<code>return func()</code>，则运行结果：</p><pre><code>foo called at Fri Nov  4 21:55:57 2016I am foofoo called at Fri Nov  4 21:55:59 2016I am foogetInfo called at Fri Nov  4 21:55:59 2016----hahah---</code></pre><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>一般情况下为了让装饰器更通用，可以有return</li></ul><h3 id="例5-装饰器带参数-在原有装饰器的基础上，设置外部变量"><a href="#例5-装饰器带参数-在原有装饰器的基础上，设置外部变量" class="headerlink" title="例5:装饰器带参数,在原有装饰器的基础上，设置外部变量"></a>例5:装饰器带参数,在原有装饰器的基础上，设置外部变量</h3><pre><code>#decorator2.pyfrom time import ctime, sleepdef timefun_arg(pre=&quot;hello&quot;):    def timefun(func):        def wrappedfunc():            print(&quot;%s called at %s %s&quot;%(func.__name__, ctime(), pre))            return func()        return wrappedfunc    return timefun@timefun_arg(&quot;itcast&quot;)def foo():    print(&quot;I am foo&quot;)@timefun_arg(&quot;python&quot;)def too():    print(&quot;I am too&quot;)foo()sleep(2)foo()too()sleep(2)too()</code></pre><p>可以理解为</p><pre><code>foo()==timefun_arg(&quot;itcast&quot;)(foo)()</code></pre><h3 id="例6：类装饰器（扩展，非重点）"><a href="#例6：类装饰器（扩展，非重点）" class="headerlink" title="例6：类装饰器（扩展，非重点）"></a>例6：类装饰器（扩展，非重点）</h3><p>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了<br><code>__call__()</code> 方法，那么这个对象就是callable的。</p><pre><code>class Test():    def __call__(self):        print(&apos;call me!&apos;)t = Test()t()  # call me</code></pre><p>类装饰器demo</p><pre><code>class Test(object):    def __init__(self, func):        print(&quot;---初始化---&quot;)        print(&quot;func name is %s&quot;%func.__name__)        self.__func = func    def __call__(self):        print(&quot;---装饰器中的功能---&quot;)        self.__func()#说明：#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象#    并且会把test这个函数名当做参数传递到__init__方法中#    即在__init__方法中的func变量指向了test函数体##2. test函数相当于指向了用Test创建出来的实例对象##3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法##4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用#    所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体@Testdef test():    print(&quot;----test---&quot;)test()showpy()#如果把这句话注释，重新运行程序，依然会看到&quot;--初始化--&quot;</code></pre><p>运行结果如下：</p><pre><code>---初始化---func name is test---装饰器中的功能-------test---</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 三元运算符</title>
      <link href="/2017/12/28/cnblog_8134268/"/>
      <url>/2017/12/28/cnblog_8134268/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-三元运算符👈的摘要"><a href="#这是👉python-三元运算符👈的摘要" class="headerlink" title="这是👉python 三元运算符👈的摘要"></a><a href="/2017/12/28/cnblog_8134268/">这是👉python 三元运算符👈的摘要</a></h1><a id="more"></a><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><h3 id="接收结果的变量-条件为真的结果-if-条件-else-条件为假的结果"><a href="#接收结果的变量-条件为真的结果-if-条件-else-条件为假的结果" class="headerlink" title="接收结果的变量 = 条件为真的结果 if 条件 else 条件为假的结果"></a>接收结果的变量 = 条件为真的结果 if 条件 else 条件为假的结果</h3><p>怎么样是不是很简单！😝 <strong>  </strong></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 函数进阶</title>
      <link href="/2017/12/27/cnblog_8125951/"/>
      <url>/2017/12/27/cnblog_8125951/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-函数进阶👈的摘要"><a href="#这是👉python-函数进阶👈的摘要" class="headerlink" title="这是👉python 函数进阶👈的摘要"></a><a href="/2017/12/27/cnblog_8125951/">这是👉python 函数进阶👈的摘要</a></h1><a id="more"></a><h3 id="试着画了一个思维导图发现还真不错"><a href="#试着画了一个思维导图发现还真不错" class="headerlink" title="试着画了一个思维导图发现还真不错"></a>试着画了一个思维导图发现还真不错</h3><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171228190556897-561734959.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 函数</title>
      <link href="/2017/12/27/cnblog_8124173/"/>
      <url>/2017/12/27/cnblog_8124173/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-函数👈的摘要"><a href="#这是👉python-函数👈的摘要" class="headerlink" title="这是👉python 函数👈的摘要"></a><a href="/2017/12/27/cnblog_8124173/">这是👉python 函数👈的摘要</a></h1><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>总结一：</strong></p><p><strong>定义：</strong> def 关键词开头，空格之后接函数名称和圆括号()，最后还有一个”:”。</p><p>def 是固定的，不能变，必须是连续的def三个字母，不能分开。。。它们要相亲相爱的在一起。</p><p>空格 为了将def关键字和函数名分开，必须空(四声)，当然你可以空2格、3格或者你想空多少都行，但正常人还是空1格。</p><p>函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并能表达函数功能</p><p>括号：是必须加的，先别问为啥要有括号，总之加上括号就对了！</p><p><strong>注释：</strong> 每一个函数都应该对功能和参数进行相应的说明，应该写在函数下面第一行。以增强代码的可读性。</p><p><strong>调用：</strong> 就是  <strong>函数名()</strong>  要记得加上括号，好么好么好么</p><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>只需要在函数的最后加上一个return，return后面写上返回的值就可以了。</p><p><strong>return关键字的作用</strong></p><p>return 是一个关键字，在pycharm里，你会看到它变成蓝色了。你必须一字不差的把这个单词给背下来。</p><p>这个词翻译过来就是 “返回”，所以我们管写在return后面的值叫”返回值”</p><p>要研究返回值，我们还要知道返回值有几种情况：分别是没有返回值、返回一个值、返回多个值</p><p><strong>没有返回值</strong></p><p>不写return的情况下，会默认返回一个None：我们写的第一个函数，就没有写return，这就是没有返回值的一种情况。</p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p><strong>实参与形参</strong></p><p>参数还有分别：</p><p>我们调用函数时传递的这个”hello world”被称为 <strong>实际参数，</strong> 因为这个是实际的要交给函数的内容，简称 <strong>实参。</strong></p><p>定义函数时的s1，只是一个变量的名字，被称为 <strong>形式参数</strong> ，因为在定义函数的时候它只是一个形式，表示这里有一个参数，简称 <strong>形参</strong> 。</p><pre><code>1.定义：def 关键词开头，空格之后接函数名称和圆括号()。2.参数：圆括号用来接收参数。若传入多个参数，参数之间用逗号分割。  　　　　参数可以定义多个，也可以不定义。  　　　　参数有很多种，如果涉及到多种参数的定义，应始终遵循位置参数、*args、默认参数、**kwargs顺序定义。  　　　　如上述定义过程中某参数类型缺省，其他参数依旧遵循上述排序3.注释：函数的第一行语句应该添加注释。4.函数体：函数内容以冒号起始，并且缩进。5.返回值：return [表达式] 结束函数。不带表达式的return相当于返回 Nonedef 函数名(参数1,参数2,*args,默认参数,**kwargs):        &quot;&quot;&quot;注释：函数功能和参数说明&quot;&quot;&quot;        函数体        ……        return 返回值  1.函数名()    函数名后面+圆括号就是函数的调用。2.参数：    圆括号用来接收参数。    若传入多个参数：        应按先位置传值，再按关键字传值        具体的传入顺序应按照函数定义的参数情况而定3.返回值    如果函数有返回值，还应该定义&quot;变量&quot;接收返回值    如果返回值有多个，也可以用多个变量来接收，变量数应和返回值数目一致无返回值的情况：函数名()有返回值的情况：变量 = 函数名()多个变量接收多返回值：变量1，变量2，... = 函数名()</code></pre>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Win10(PowerShell)下Python命令行tab自动补全</title>
      <link href="/2017/12/26/cnblog_8116853/"/>
      <url>/2017/12/26/cnblog_8116853/</url>
      <content type="html"><![CDATA[<h1 id="这是👉Win10-PowerShell-下Python命令行tab自动补全👈的摘要"><a href="#这是👉Win10-PowerShell-下Python命令行tab自动补全👈的摘要" class="headerlink" title="这是👉Win10(PowerShell)下Python命令行tab自动补全👈的摘要"></a><a href="/2017/12/26/cnblog_8116853/">这是👉Win10(PowerShell)下Python命令行tab自动补全👈的摘要</a></h1><a id="more"></a><p><strong>用Python，直接通过命令行的方式进行调试简单的程序。  </strong></p><p><strong>win10（PowerShell）奈何没有Tab补全，操作实在麻烦。</strong></p><p><strong>网上搜一下学会了，记录一下，复习用，哈哈哈</strong></p><h1 id="环境：win10-64位-python2-python3"><a href="#环境：win10-64位-python2-python3" class="headerlink" title="环境：win10   64位  python2,python3"></a><strong>环境：win10   64位  python2,python3</strong></h1><h2 id="一：安装pyreadline模块"><a href="#一：安装pyreadline模块" class="headerlink" title="一：安装pyreadline模块"></a>一：安装pyreadline模块</h2><pre><code>pip install pyreadline # python2pip3 install pyreadline # python3</code></pre><h2 id="二、编写tab-py"><a href="#二、编写tab-py" class="headerlink" title="二、编写tab.py"></a>二、编写tab.py</h2><p><strong>文件保存在..\Python2\Lib\tab.py</strong></p><pre><code>例如：D:\Program Files\Python2\Lib\tab.py   python2 python3要使用TAb自动补全都要在对应的lib中建立tab.py文件  #python Tabimport sys   import readline   import rlcompleter   import atexit   import os    readline.parse_and_bind(&apos;tab: complete&apos;)   # windowshistfile = os.path.join(os.environ[&apos;HOMEPATH&apos;], &apos;.pythonhistory&apos;)   # linux# histfile = os.path.join(os.environ[&apos;HOME&apos;], &apos;.pythonhistory&apos;)   try:       readline.read_history_file(histfile)   except IOError:       pass   atexit.register(readline.write_history_file, histfile)   del os, histfile, readline, rlcompleter  </code></pre><h2 id="三、效果测试"><a href="#三、效果测试" class="headerlink" title="三、效果测试"></a>三、效果测试</h2><p><strong>使用import tab引入tab补全</strong></p><p><strong># python2</strong></p><p><strong><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171226104410775-2000736178.png" alt=""></strong></p><p><strong># python3</strong></p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171226104504275-2109285223.png" alt=""></p><h1 id="经测试发现，python2-需要import-tab-才支持自动补全，然后python3不需要导入tab就可以支持自动补全，不知道是不是我的比较特殊😂"><a href="#经测试发现，python2-需要import-tab-才支持自动补全，然后python3不需要导入tab就可以支持自动补全，不知道是不是我的比较特殊😂" class="headerlink" title="经测试发现，python2 需要import tab 才支持自动补全，然后python3不需要导入tab就可以支持自动补全，不知道是不是我的比较特殊😂"></a>经测试发现，python2 需要import tab 才支持自动补全，然后python3不需要导入tab就可以支持自动补全，不知道是不是我的比较特殊😂</h1>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python文件操作</title>
      <link href="/2017/12/25/cnblog_8110891/"/>
      <url>/2017/12/25/cnblog_8110891/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python文件操作👈的摘要"><a href="#这是👉python文件操作👈的摘要" class="headerlink" title="这是👉python文件操作👈的摘要"></a><a href="/2017/12/25/cnblog_8110891/">这是👉python文件操作👈的摘要</a></h1><a id="more"></a><p><strong>python/文件操作:</strong></p><h2 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1.打开文件"></a>1.打开文件</h2><p>1</p><p>2</p><p>3</p><p>|</p><p><code>使用`</code>open<code></code>()`</p><p><code>文件句柄 `</code>=<code></code>open<code>(</code>‘文件路径’<code>,</code>‘模式’<code></code>)`  </p><p>—|—  </p><h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h2><p>1</p><p>|</p><p><code>打开文件时，需要指定文件路径和以何等方式打开文件，</code></p><p><code>打开后，即可获取该文件句柄，日后通过此文件句柄对该文件操作。</code>  </p><p>—|—  </p><h2 id="打开文件的模式有："><a href="#打开文件的模式有：" class="headerlink" title="打开文件的模式有："></a>打开文件的模式有：</h2><pre><code>r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】w，只写模式【不可读；不存在则创建；存在则清空内容】x， 只写模式【不可读；不存在则创建，存在则报错】a， 追加模式【可读；   不存在则创建；存在则只追加内容】&quot;+&quot; 表示可以同时读写某个文件r+， 读写【可读，可写】w+，写读【可读，可写】x+ ，写读【可读，可写】a+， 写读【可读，可写】 &quot;b&quot;表示以字节的方式操作rb  或 r+bwb 或 w+bxb 或 w+bab 或 a+b 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码3.关闭文件  使用close()补充：with语句自带使用close()方法, 这也是为了防止打开文件忘记关闭比如：with open() as f_read:#打开文件是不需要添加close()的。</code></pre><p><strong>二.文件操作</strong></p><pre><code>1.read文件名.read(n)：读取指定个数的字符，文件从光标位置开始注意：python3版本读取的是字符        python2版本读取的是字节在读取完第一次字符时，第二次读取从上次读取完的字符开始比如：f.readline 读取一行，光标到下一行行首f.readlines 显示列表结果，每一个元素是一行内容行与字符串的拼接使用join用法文件名.join([文件名，&quot;需要添加的字符串&quot;])循环整个文件，并在一行中拼接使用for循环2.writef =open(name,mode=w) 修改文件可读权限文件名.write(&quot;&quot;)   覆盖文件信息文件名.write(&quot;\n&quot;) 换行f =open(name,mode=&quot;a&quot;)追加信息，原来文件信息不变f =open(name,mode=&quot;x&quot;)原有的文件不覆盖，会报错；没有的文件重新创建f=write(&quot;&quot;)把内容添加到内存，在一定时间内显示出来f.writelines([&quot;11\n&quot;,&quot;22\n&quot;])写多行f.truncate() 截断  只能在写权限操作**3.可读可写模式：  **f = open(&quot;test&quot;,mode=&quot;r&quot;,encoding=&quot;utf8&quot;)data = f.read(5)data2 = f.read(6)print(data)print(data2)得到的答案是globalr+  追加写    默认光标在开始位置w+  首先会覆盖,清空，然后再写，seek调整a+  总是在最后位置添加。光标在文件最后位置    无论光标在什么位置，一定是追加写：    想读取内容：seek调增4.flush操作f=flush(&quot;&quot;) 直接显示,内容直接存储在硬盘上比如：进度条操作sys.stdout.write(&quot;&quot;)相当于print　　sys.stdout 文件　　循环打印#import sysfor i in range(10):　　sys.stdout.write(&quot;#&quot;)　　sys.stdout.flush()　　import time　　time.sleep(0.5)显示百分比import sysfor i in range(6):    s = &quot;\r%s%% %s&quot;%(i,&quot;?&quot;*i)    sys.stdout.write(s)    sys.stdout.flush()    import time    time.sleep(0.5)</code></pre><p><strong>二.其他操作</strong></p><pre><code>**1.tell和seek：**</code></pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>|</p><p><code>`</code>tell：查询文件中光标位置`</p><p><code>`</code>seek：光标定位`</p><p><code>f = open(`</code>‘file’<code>,</code>‘r’<code></code>)`</p><p><code>print(f.tell())  #光标默认在起始位置</code></p><p><code>f.seek(10)    #把光标定位到第10个字符之后</code></p><p><code>print(f.tell())  #输出10</code></p><p><code>f.close()</code></p><p><code>----------------------</code></p><p><code>f = open(`</code>‘file’<code>,</code>‘w’<code></code>)`</p><p><code>print(f.tell())  #先清空内容，光标回到0位置</code></p><p><code>f.seek(10)</code></p><p><code>print(f.tell())</code></p><p><code>f.close()</code></p><p><code>----------------------</code></p><p><code>f = open(`</code>‘file’<code>,</code>‘a’<code></code>)`</p><p><code>print(f.tell())  #光标默认在最后位置</code></p><p><code>f.write（`</code>‘你好 世界’<code></code>）`</p><p><code>print(f.tell())  #光标向后9个字符，仍在最后位置</code></p><p><code>f.close()</code>  </p><p>—|—  </p><pre><code>**2.flush 同步将数据从缓冲转移到磁盘：**</code></pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>|</p><p><code>示例，实现进度条功能</code></p><p><code>import sys,time  #导入sys和time模块</code></p><p><code>for</code> <code>i `</code>in<code></code>range(40):`</p><p><code>`</code>sys.stdout.write(<code>&#39;*&#39;</code>)`</p><p><code>`</code>sys.stdout.flush()  #flush的作用相当于照相，拍一张冲洗一张`</p><p><code>`</code>time.sleep(0.2)`</p><p><code>下面代码也能够实现相同的功能</code></p><p><code>import time</code></p><p><code>for</code> <code>i `</code>in<code></code>range(40):`</p><p><code>`</code>print(<code>&#39;*&#39;</code>,end=<code>&#39;&#39;</code>,flush=True) #print中的flush参数`</p><p><code>`</code>time.sleep(0.2)`  </p><p>—|—  </p><pre><code>**2.truncate 截断：**</code></pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>|</p><p><code>不能是r模式下执行，</code></p><p><code>w模式下，已经清空所有数据，使用truncate没有任何意义，</code></p><p><code>a模式下，截断指定位置后的内容。</code></p><p><code>`</code>f = open(<code>&#39;file&#39;</code>,<code>&#39;a&#39;</code>)`</p><p><code>`</code>f.truncate(6) #只显示6个字节的内容（6个英文字符或三个汉字），后面的内容被清空。`  </p><p>—|—</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 集合 深浅拷贝</title>
      <link href="/2017/12/22/cnblog_8085041/"/>
      <url>/2017/12/22/cnblog_8085041/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-集合-深浅拷贝👈的摘要"><a href="#这是👉python-集合-深浅拷贝👈的摘要" class="headerlink" title="这是👉python 集合 深浅拷贝👈的摘要"></a><a href="/2017/12/22/cnblog_8085041/">这是👉python 集合 深浅拷贝👈的摘要</a></h1><a id="more"></a><h2 id="一，集合。"><a href="#一，集合。" class="headerlink" title="一，集合。"></a>一，集合。</h2><p>集合是无序的，不重复的数据集合，它里面的元素是可哈希的(不可变类型)，但是集合本身是不可哈希（所以集合做不了字典的键）的。以下是集合最重要的两点：</p><p>去重，把一个列表变成集合，就自动去重了。</p><p>关系测试，测试两组数据之前的交集、差集、并集等关系。</p><p>1，集合的创建。</p><pre><code>set1 = set({1, 2, 3, 4, 5, &quot;hh&quot;})  set2 = {1, 2, 3, 4, 5, &quot;hh&quot;}  print(set1,set2)  # {1, 2, 3, 4, 5, &apos;hh&apos;} {1, 2, 3, 4, 5, &apos;hh&apos;}</code></pre><p>2，集合的增。</p><pre><code>set1 = {&apos;alex&apos;,&apos;wusir&apos;,&apos;ritian&apos;,&apos;egon&apos;,&apos;barry&apos;}set1.add(&apos;景女神&apos;)print(set1)#update：迭代着增加set1.update(&apos;A&apos;)print(set1)set1.update(&apos;老师&apos;)print(set1)set1.update([1,2,3])print(set1)</code></pre><p>3，集合的删。</p><pre><code>set1 = {&apos;alex&apos;,&apos;wusir&apos;,&apos;ritian&apos;,&apos;egon&apos;,&apos;barry&apos;}set1.remove(&apos;alex&apos;)  # 删除一个元素print(set1)set1.pop()  # 随机删除一个元素print(set1)set1.clear()  # 清空集合print(set1)del set1  # 删除集合print(set1)</code></pre><p>4，集合的其他操作：</p><p>4.1 交集。（&amp;  或者 intersection）</p><pre><code>set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 &amp; set2)  # {4, 5}print(set1.intersection(set2))  # {4, 5}</code></pre><p>4.2 并集。（| 或者 union）</p><pre><code>set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 | set2)  # {1, 2, 3, 4, 5, 6, 7}  print(set2.union(set1))  # {1, 2, 3, 4, 5, 6, 7}</code></pre><p>4.3 差集。（- 或者 difference）</p><pre><code>set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 - set2)  # {1, 2, 3}print(set1.difference(set2))  # {1, 2, 3}</code></pre><p>  4.4反交集。 （^ 或者 symmetric_difference）</p><pre><code>set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 ^ set2)  # {1, 2, 3, 6, 7, 8}print(set1.symmetric_difference(set2))  # {1, 2, 3, 6, 7, 8}</code></pre><p>4.5子集与超集</p><pre><code>set1 = {1,2,3}set2 = {1,2,3,4,5,6}print(set1 &lt; set2)print(set1.issubset(set2))  # 这两个相同，都是说明set1是set2子集。print(set2 &gt; set1)print(set2.issuperset(set1))  # 这两个相同，都是说明set2是set1超集。</code></pre><p>5，frozenset不可变集合，让集合变成不可变类型。</p><pre><code>s = frozenset(&apos;barry&apos;)print(s,type(s))  # frozenset({&apos;a&apos;, &apos;y&apos;, &apos;b&apos;, &apos;r&apos;}) &lt;class &apos;frozenset&apos;&gt;</code></pre><h2 id="二，深浅copy"><a href="#二，深浅copy" class="headerlink" title="二，深浅copy"></a>二，深浅copy</h2><p>1，先看赋值运算。</p><pre><code>l1 = [1,2,3,[&apos;barry&apos;,&apos;alex&apos;]]l2 = l1l1[0] = 111print(l1)  # [111, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]]print(l2)  # [111, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]]l1[3][0] = &apos;wusir&apos;print(l1)  # [111, 2, 3, [&apos;wusir&apos;, &apos;alex&apos;]]print(l2)  # [111, 2, 3, [&apos;wusir&apos;, &apos;alex&apos;]]</code></pre><p>对于赋值运算来说，l1与l2指向的是同一个内存地址，所以他们是完全一样的。</p><p>2，浅拷贝copy。</p><pre><code>l1 = [1,2,3,[&apos;barry&apos;,&apos;alex&apos;]]l2 = l1.copy()print(l1,id(l1))  # [1, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2380296895816print(l2,id(l2))  # [1, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2380296895048l1[1] = 222  print(l1,id(l1))  # [1, 222, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2593038941128  print(l2,id(l2))  # [1, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2593038941896l1[3][0] = &apos;wusir&apos;print(l1,id(l1[3]))  # [1, 2, 3, [&apos;wusir&apos;, &apos;alex&apos;]] 1732315659016print(l2,id(l2[3]))  # [1, 2, 3, [&apos;wusir&apos;, &apos;alex&apos;]] 1732315659016</code></pre><p>对于浅copy来说，第一层创建的是新的内存地址，而从第二层开始，指向的都是同一个内存地址，所以，对于第二层以及更深的层数来说，保持一致性。</p><p>3，深拷贝deepcopy。</p><pre><code>import copyl1 = [1,2,3,[&apos;barry&apos;,&apos;alex&apos;]]l2 = copy.deepcopy(l1)print(l1,id(l1))  # [1, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2915377167816print(l2,id(l2))  # [1, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2915377167048l1[1] = 222print(l1,id(l1))  # [1, 222, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2915377167816print(l2,id(l2))  # [1, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2915377167048l1[3][0] = &apos;wusir&apos;print(l1,id(l1[3]))  # [1, 222, 3, [&apos;wusir&apos;, &apos;alex&apos;]] 2915377167240print(l2,id(l2[3]))  # [1, 2, 3, [&apos;barry&apos;, &apos;alex&apos;]] 2915377167304</code></pre><p>对于深copy来说，两个是完全独立的，改变任意一个的任何元素（无论多少层），另一个绝对不改变。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python小整数与str数据池，编码关系</title>
      <link href="/2017/12/22/cnblog_8084380/"/>
      <url>/2017/12/22/cnblog_8084380/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python小整数与str数据池，编码关系👈的摘要"><a href="#这是👉python小整数与str数据池，编码关系👈的摘要" class="headerlink" title="这是👉python小整数与str数据池，编码关系👈的摘要"></a><a href="/2017/12/22/cnblog_8084380/">这是👉python小整数与str数据池，编码关系👈的摘要</a></h1><a id="more"></a><p><strong>1、小数据池：数字，字符串</strong></p><p>数字的范围-5 —256</p><p>字符串：1，不能有特殊字符</p><p>2，s<em>20 还是一个地址，s</em>21以后都是两个地址</p><hr><p><strong>2、编码关系：ascii</strong></p><pre><code>            A : 00000010  8位 一个字节   unicode     A : 00000000 00000001 00000010 00000100 32位  四个字节              中：00000000 00000001 00000010 00000110 32位  四个字节  utf-8      A :  00100000 8位 一个字节            中 :  00000001 00000010 00000110 24位 三个字节  gbk        A : 00000110  8位 一个字节           中  : 00000010 00000110 16位 两个字节  1，各个编码之间的二进制，是不能互相识别的，会产生乱码。  2，文件的储存，传输，不能是unicode（只能是utf-8 utf-16 gbk,gb2312,ascii等） **  py3:     ** str 在内存中是用unicode编码。          bytes类型          对于英文：               str  ：表现形式：s = &apos;alex&apos;                      编码方式： 010101010  unicode              bytes ：表现形式：s = b&apos;alex&apos;                      编码方式： 000101010  utf-8 gbk。。。。          对于中文：               str  ：表现形式：s = &apos;中国&apos;                      编码方式： 010101010  unicode              bytes ：表现形式：s = b&apos;x\e91\e91\e01\e21\e31\e32&apos;                      编码方式： 000101010  utf-8 gbk.... **  3、is 与== 区别**</code></pre><p>is判断的是a对象是否就是b对象，是通过id来判断的<br>==判断的是a对象的值是否和b对象的值相等，是通过value来判断的</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 字典的操作</title>
      <link href="/2017/12/20/cnblog_8073028/"/>
      <url>/2017/12/20/cnblog_8073028/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-字典的操作👈的摘要"><a href="#这是👉python-字典的操作👈的摘要" class="headerlink" title="这是👉python 字典的操作👈的摘要"></a><a href="/2017/12/20/cnblog_8073028/">这是👉python 字典的操作👈的摘要</a></h1><a id="more"></a><h2 id="可变类型与不可变类型"><a href="#可变类型与不可变类型" class="headerlink" title="可变类型与不可变类型"></a>可变类型与不可变类型</h2><h2 id="（字典的键必须是不可变类型的即时可哈希的）"><a href="#（字典的键必须是不可变类型的即时可哈希的）" class="headerlink" title="（字典的键必须是不可变类型的即时可哈希的）"></a>（字典的键必须是不可变类型的即时可哈希的）</h2><p>不可变类型，值不可以改变：（可哈希）</p><ul><li>数值类型 int, long, bool, float</li><li>字符串 str</li><li>元组 tuple</li></ul><p>可变类型，值可以改变：（不可哈希）</p><ul><li>列表 list</li><li>字典 dict</li></ul><p><strong>字典的常见操作：</strong></p><p>#增加</p><p>变量名[‘键’] = 数据</p><p>如果在使用 变量名[‘键’] = 数据 时，这个”键”在字典中，存在，覆盖这个键值对。不存在，那么就会新增这个元素</p><p>dict.setdefault(“键值”，”数据”)</p><p>有键值对不做任何操作，没有键值就会增加</p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>dict.pop(“键值”)</p><p>有返回值，按键删除，如果没有此建会报错</p><p>dict.pop（”键值”, None）</p><p>按键删除，None可换成提示，没有键值会返回提示，有键值会直接删除</p><p>dict.popitem()</p><p>在不同python版本中不同：</p><p>python3.6之前dict={x:x}print打印无序的，popitem()删除的时候是删除打印后的第一个</p><p>python3.6   dict打印是有序的，即如何设置的就如何打印，popitem()删除的时候就是删除的最后一个</p><p>dict.clear()</p><p>清空字典</p><p>del dict[键值]</p><p>del可以删除整个字典，也可以按键删除</p><h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>dict[“键值”]=val</p><p>直接根据键值对其赋值，如果键值不存在，会直接增加对应键值对</p><p>dict.update(dict1)</p><p>把dict1 的键值对覆盖到dict中</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>dict.keys()</p><p>遍历键值</p><p>dict.values()</p><p>遍历值</p><p>dict.item()</p><p>遍历元素</p><p>dict.get(“键值”)</p><p>根据键值查找值，可以自定义返回值，未找到时有返回值，比如dict.get(“键值”，”未找到”)</p><p>dict[“键值”]</p><p>找不到报错，找到返回对应的值</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 列表的常见操作</title>
      <link href="/2017/12/19/cnblog_8064765/"/>
      <url>/2017/12/19/cnblog_8064765/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-列表的常见操作👈的摘要"><a href="#这是👉python-列表的常见操作👈的摘要" class="headerlink" title="这是👉python 列表的常见操作👈的摘要"></a><a href="/2017/12/19/cnblog_8064765/">这是👉python 列表的常见操作👈的摘要</a></h1><a id="more"></a><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="列表的相关操作"><a href="#列表的相关操作" class="headerlink" title="列表的相关操作"></a>列表的相关操作</h1><p>列表中存放的数据是可以进行修改的，比如”增”、”删”、”改””</p><h2 id="添加元素-“增”append-extend-insert"><a href="#添加元素-“增”append-extend-insert" class="headerlink" title="添加元素(“增”append, extend, insert)"></a><1>添加元素(“增”append, extend, insert)</1></h2><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>通过append可以向列表添加元素</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219112216615-1747891122.png" alt=""></p><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><p>通过extend可以将另一个集合中的元素逐一添加到列表中</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219112343428-613389749.png" alt=""></p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>insert(index, object) 在指定位置index前插入元素object</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219112634771-2093233925.png" alt=""></p><h2 id="修改元素-“改”"><a href="#修改元素-“改”" class="headerlink" title="修改元素(“改”)"></a><2>修改元素(“改”)</2></h2><p>修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219112842584-925729548.png" alt=""></p><h2 id="查找元素-“查”in-not-in-index-count"><a href="#查找元素-“查”in-not-in-index-count" class="headerlink" title="查找元素(“查”in, not in, index, count)"></a><3>查找元素(“查”in, not in, index, count)</3></h2><p>所谓的查找，就是看看指定的元素是否存在</p><h4 id="in-not-in"><a href="#in-not-in" class="headerlink" title="in, not in"></a>in, not in</h4><p>python中查找的常用方法为：</p><ul><li>in（存在）,如果存在那么结果为true，否则为false</li><li>not in（不存在），如果不存在那么结果为true，否则false</li></ul><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219113141131-1759742458.png" alt=""></p><h4 id="index-count"><a href="#index-count" class="headerlink" title="index, count"></a>index, count</h4><p>index和count与字符串中的用法相同</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219113427459-78060384.png" alt=""></p><h2 id="删除元素-“删”del-pop-remove"><a href="#删除元素-“删”del-pop-remove" class="headerlink" title="删除元素(“删”del, pop, remove)"></a><4>删除元素(“删”del, pop, remove)</4></h2><p>类比现实生活中，如果某位同学调班了，那么就应该把这个条走后的学生的姓名删除掉；在开发中经常会用到删除这种功能。</p><p>列表元素的常用删除方法有：</p><ul><li>del：根据下标进行删除</li><li>pop：删除最后一个元素</li><li>remove：根据元素的值进行删除</li></ul><p>del list[num]</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219113631662-1282975084.png" alt=""></p><p>list.pop(“xxx”)</p><p>注：有返回值，返回删除的值</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219113956959-1662731657.png" alt=""></p><p> list.remove(“xxx”)</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219114315162-312782036.png" alt=""></p><h2 id="排序-sort-reverse"><a href="#排序-sort-reverse" class="headerlink" title="排序(sort, reverse)"></a><5>排序(sort, reverse)</5></h2><p>sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。</p><p>reverse方法是将list逆置。</p><p>list.sort()</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219114443678-1347963350.png" alt=""></p><p>list.reverse()</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219114617943-207621419.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python字符串Str方法</title>
      <link href="/2017/12/19/cnblog_8063941/"/>
      <url>/2017/12/19/cnblog_8063941/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python字符串Str方法👈的摘要"><a href="#这是👉python字符串Str方法👈的摘要" class="headerlink" title="这是👉python字符串Str方法👈的摘要"></a><a href="/2017/12/19/cnblog_8063941/">这是👉python字符串Str方法👈的摘要</a></h1><a id="more"></a><h4 id="find"><a href="#find" class="headerlink" title="find"></a><1>find</1></h4><p>检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1</p><p>使用方法：str.find(“xx”,0,len(str))</p><h4 id="index"><a href="#index" class="headerlink" title="index"></a><2>index</2></h4><p>跟find()方法一样，只不过如果str不在 mystr中会报一个异常.</p><p>使用方法：str.index(“xx”)</p><h4 id="count"><a href="#count" class="headerlink" title="count"></a><3>count</3></h4><p>返回 str在start和end之间 在 mystr里面出现的次数</p><p>使用方法：str.count(“xx”,0,len(str))</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a><4>replace</4></h4><p>把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.</p><p>使用方法：str.replace(str1, str2, str.count(str1))</p><h4 id="split"><a href="#split" class="headerlink" title="split"></a><5>split</5></h4><p>以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串</p><p>使用方法：str.split(“ “, 2)</p><h4 id="capitalize"><a href="#capitalize" class="headerlink" title="capitalize"></a><6>capitalize</6></h4><p>把字符串的第一个字符大写</p><p>使用方法：str.capitalize()</p><h4 id="title"><a href="#title" class="headerlink" title="title"></a><7>title</7></h4><p>把字符串的每个单词首字母大写</p><p>使用方法：str.title()</p><h4 id="startswith"><a href="#startswith" class="headerlink" title="startswith"></a><8>startswith</8></h4><p>检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False</p><p>使用方法：str.starswith(“obj”)</p><h4 id="endswith"><a href="#endswith" class="headerlink" title="endswith"></a><9>endswith</9></h4><p>检查字符串是否以obj结束，如果是返回True,否则返回 False.</p><p>使用方法：str.endswith(“obj”)</p><h4 id="lower"><a href="#lower" class="headerlink" title="lower"></a><10>lower</10></h4><p>转换 mystr 中所有大写字符为小写</p><p>使用方法：str.lower()</p><h4 id="upper"><a href="#upper" class="headerlink" title="upper"></a><11>upper</11></h4><p>转换 mystr 中的小写字母为大写</p><p>使用方法：str.upper()</p><h4 id="ljust"><a href="#ljust" class="headerlink" title="ljust"></a><12>ljust</12></h4><p>返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</p><p>使用方法：str.ljust(5)</p><h4 id="rjust"><a href="#rjust" class="headerlink" title="rjust"></a><13>rjust</13></h4><p>返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</p><p>使用方法：str.rjust(width)</p><h4 id="center"><a href="#center" class="headerlink" title="center"></a><14>center</14></h4><p>返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</p><p>使用方法：str.center(width)</p><h4 id="lstrip"><a href="#lstrip" class="headerlink" title="lstrip"></a><15>lstrip</15></h4><p>删除 str 左边的空白字符</p><p>使用方法：str.lstrip()</p><h4 id="rstrip"><a href="#rstrip" class="headerlink" title="rstrip"></a><16>rstrip</16></h4><p>删除 str 字符串末尾的空白字符</p><p>使用方法：str.rstrip()</p><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a><17>strip</17></h4><p>删除str字符串两端的空白字符</p><p>使用方法：str.strip()</p><h3 id="rfind"><a href="#rfind" class="headerlink" title="rfind"></a><18>rfind</18></h3><p>类似于 find()函数，不过是从右边开始查找.</p><p>使用方法：str.rfind(“xx”)</p><h3 id="rindex"><a href="#rindex" class="headerlink" title="rindex"></a><19>rindex</19></h3><p>类似于 index()，不过是从右边开始.</p><p>使用方法：str.rindex(“xx”)</p><h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a><20>partition</20></h3><p>把mystr以str分割成三部分,str前，str和str后</p><p>使用方法：mystr.partition(str)</p><h3 id="rpartition"><a href="#rpartition" class="headerlink" title="rpartition"></a><21>rpartition</21></h3><p>类似于 partition()函数,不过是从右边开始.</p><p>使用方法：mystr.rpartition(str)</p><h3 id="splitlines"><a href="#splitlines" class="headerlink" title="splitlines"></a><22>splitlines</22></h3><p>按照行分隔，返回一个包含各行作为元素的列表</p><p>使用方法：mystr.splitlines()</p><h3 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha"></a><23>isalpha</23></h3><p>如果 mystr 所有字符都是字母 则返回 True,否则返回 False</p><p>使用方法：str.isalpha()</p><h3 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit"></a><24>isdigit</24></h3><p>如果 mystr 只包含数字则返回 True 否则返回 False.</p><p>使用方法：str.isdigit()</p><h3 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum"></a><25>isalnum</25></h3><p>如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False</p><p>使用方法：str.isalnum()</p><h3 id="isspace"><a href="#isspace" class="headerlink" title="isspace"></a><26>isspace</26></h3><p>如果 mystr 中只包含空格，则返回 True，否则返回 False.</p><p>使用方法：str.isspace()</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a><27>join</27></h3><p>mystr 中每个字符后面插入str,构造出一个新的字符串</p><p>使用方法：str.join(str)</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 的基础数据类型</title>
      <link href="/2017/12/19/cnblog_8063770/"/>
      <url>/2017/12/19/cnblog_8063770/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python-的基础数据类型👈的摘要"><a href="#这是👉python-的基础数据类型👈的摘要" class="headerlink" title="这是👉python 的基础数据类型👈的摘要"></a><a href="/2017/12/19/cnblog_8063770/">这是👉python 的基础数据类型👈的摘要</a></h1><a id="more"></a><p>Number（数字）</p><ul><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Sets（集合）</li><li>Dictionary（字典）</li></ul><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219084855537-1893809811.png" alt=""></p><p><strong>使用type()可以查看变量类型</strong></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win10 下的python虚拟环境安装使用（使用powershell）</title>
      <link href="/2017/12/18/cnblog_8056860/"/>
      <url>/2017/12/18/cnblog_8056860/</url>
      <content type="html"><![CDATA[<h1 id="这是👉win10-下的python虚拟环境安装使用（使用powershell）👈的摘要"><a href="#这是👉win10-下的python虚拟环境安装使用（使用powershell）👈的摘要" class="headerlink" title="这是👉win10 下的python虚拟环境安装使用（使用powershell）👈的摘要"></a><a href="/2017/12/18/cnblog_8056860/">这是👉win10 下的python虚拟环境安装使用（使用powershell）👈的摘要</a></h1><a id="more"></a><h1 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h1><p>若要使用python虚拟环境进行开发，首先需要安装virtualenv。<br>命令： <strong>pip install virtualenv</strong></p><p><strong><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171218113953584-1692206869.png" alt=""></strong></p><p>我已经装过了😁</p><h1 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h1><p>命令： <strong>virtualenv [自定义虚拟环境名称]</strong></p><p><strong><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171218114216584-1123975780.png" alt=""></strong></p><p>运行完以后会在当前路径下生成你的虚拟环境</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171218114341178-1763068844.png" alt=""></p><p>还有另外一种创建虚拟环境的命令，上面是默认的使用python3</p><p>如果想使用指定的python版本创建虚拟环境  命令如下：</p><p><strong>virtualenv -p [python所在的路径+python运行文件的名字（加后缀名）] + 虚拟环境名</strong></p><p><strong><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171218114810818-800385131.png" alt=""></strong></p><p>同样能达到效果</p><h1 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h1><p>命令： <strong>[虚拟环境名称]\scripts\activate</strong></p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171218115316678-2008079370.png" alt=""></p><p>可能有点慢😥</p><h4 id="退出虚拟环境："><a href="#退出虚拟环境：" class="headerlink" title="退出虚拟环境："></a>退出虚拟环境：</h4><p>命令： <strong>deactivate</strong></p><p><strong><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171218115720209-1124809931.png" alt=""></strong></p><p>删除虚拟环境，直接删除环境目录就可以了，简单粗暴</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python运算符优先级</title>
      <link href="/2017/12/18/cnblog_8056277/"/>
      <url>/2017/12/18/cnblog_8056277/</url>
      <content type="html"><![CDATA[<h1 id="这是👉python运算符优先级👈的摘要"><a href="#这是👉python运算符优先级👈的摘要" class="headerlink" title="这是👉python运算符优先级👈的摘要"></a><a href="/2017/12/18/cnblog_8056277/">这是👉python运算符优先级👈的摘要</a></h1><a id="more"></a><p><strong>对于or与and运算</strong></p><p><strong>其一, 在不加括号时候, and优先级大于or</strong></p><p><strong>其二, x or y 的值只可能是x或y. x为真就是x, x为假就是y</strong></p><p><strong>第三, x and y 的值只可能是x或y. x为真就是y, x为假就是x</strong></p><p><strong><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171218100432756-740672471.png" alt=""></strong></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gbk,utf-8,unicode编码，单位换算</title>
      <link href="/2017/12/18/cnblog_8056251/"/>
      <url>/2017/12/18/cnblog_8056251/</url>
      <content type="html"><![CDATA[<h1 id="这是👉gbk-utf-8-unicode编码，单位换算👈的摘要"><a href="#这是👉gbk-utf-8-unicode编码，单位换算👈的摘要" class="headerlink" title="这是👉gbk,utf-8,unicode编码，单位换算👈的摘要"></a><a href="/2017/12/18/cnblog_8056251/">这是👉gbk,utf-8,unicode编码，单位换算👈的摘要</a></h1><a id="more"></a><p>Unicode 英文，中文都是用两个字节</p><p>utf-8 英文是1个字节，中文用3个字节</p><p>Gbk  英文是1个字节，中文是2个字节</p><p><img src="http://images2017.cnblogs.com/blog/1301576/201712/1301576-20171219091534600-79016776.png" alt=""></p><p>Bit,Bytes,Kb,Mb,Gb,Tb之间的转换关系。</p><p>8Bit = 1Bytes</p><p>1024Bytes = 1Kb</p><p>1024Kb = 1Mb</p><p>1024Mb = 1Gb</p><p>1024GB = 1TB</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 博客园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客园 </tag>
            
            <tag> 搬家 </tag>
            
            <tag> cnblogs </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>404 Not Found 页面走丢了😭</title>
      <link href="//404.html"/>
      <url>//404.html</url>
      <content type="html"><![CDATA[<hr><h1 id="👉回主页"><a href="#👉回主页" class="headerlink" title="👉回主页"></a><a href="https://wevsmy.github.io" target="_blank" rel="noopener">👉回主页</a></h1>]]></content>
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="wilson"><a href="#wilson" class="headerlink" title="wilson"></a>wilson</h1><ul><li>Email:<a href="mailto:wevsmy@gmail.com" target="_blank" rel="noopener">wevsmy@gmail.com</a></li><li>Homepage:<a href="https://wevsmy.github.io" target="_blank" rel="noopener">Wilson’s Blog</a></li><li>GitHub:<a href="https://github.com/wevsmy" target="_blank" rel="noopener">@wilson</a></li><li>Weibo:<a href="https://weibo.com/wevsmy" target="_blank" rel="noopener">@wilson</a></li></ul><hr><h1 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h1><p>长方体混凝土瞬间移动攻城狮<br>专职Python后端开发<br>略懂前端，略懂脚本，略懂机器学习</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
